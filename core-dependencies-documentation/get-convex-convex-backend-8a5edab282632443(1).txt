Directory structure:
└── get-convex-convex-backend/
    ├── README.md
    ├── BUILD.md
    ├── CONTRIBUTING.md
    ├── LICENSE.md
    ├── crates/
    │   ├── AGENTS.md
    │   ├── backend_harness/
    │   │   └── README.md
    │   ├── convex/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── CONTRIBUTING.md
    │   │   └── sync_types/
    │   │       └── README.md
    │   ├── database/
    │   │   └── README.md
    │   ├── fivetran_common/
    │   │   └── fivetran_sdk/
    │   │       └── README.md
    │   ├── fivetran_destination/
    │   │   ├── README.md
    │   │   ├── docs/
    │   │   │   ├── overview.md
    │   │   │   └── setup-guide.md
    │   │   └── src/
    │   │       └── tests/
    │   │           └── fixtures/
    │   │               └── README.md
    │   ├── fivetran_source/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   └── docs/
    │   │       ├── overview.md
    │   │       └── setup-guide.md
    │   ├── isolate/
    │   │   └── README.md
    │   ├── load_generator/
    │   │   └── README.md
    │   ├── log_streaming/
    │   │   └── README.md
    │   ├── pb/
    │   │   └── README.md
    │   └── simulation/
    │       └── README.md
    ├── demo/
    │   ├── README.md
    │   └── convex/
    │       └── README.md
    ├── npm-packages/
    │   ├── README.md
    │   ├── AGENTS.md
    │   ├── dep-upgrade-notes.md
    │   ├── @convex-dev/
    │   │   ├── codemod/
    │   │   │   ├── README.md
    │   │   │   └── test/
    │   │   │       └── explicit-ids/
    │   │   │           └── sample-convex-project/
    │   │   │               └── convex/
    │   │   │                   └── README.md
    │   │   ├── design-system/
    │   │   │   ├── README.md
    │   │   │   └── pages/
    │   │   │       └── README.md
    │   │   ├── eslint-plugin/
    │   │   │   ├── README.md
    │   │   │   └── CHANGELOG.md
    │   │   ├── platform/
    │   │   │   └── README.md
    │   │   ├── react-query/
    │   │   │   ├── README.md
    │   │   │   ├── CHANGELOG.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   └── workos/
    │   │       └── README.md
    │   ├── component-tests/
    │   │   ├── README.md
    │   │   └── projects/
    │   │       ├── basic/
    │   │       │   └── convex/
    │   │       │       └── README.md
    │   │       ├── empty/
    │   │       │   └── convex/
    │   │       │       └── README.md
    │   │       ├── http_actions/
    │   │       │   └── convex/
    │   │       │       └── README.md
    │   │       ├── mounted/
    │   │       │   └── convex/
    │   │       │       └── README.md
    │   │       ├── schema_with_index/
    │   │       │   └── convex/
    │   │       │       └── README.md
    │   │       └── with-schema/
    │   │           └── convex/
    │   │               └── README.md
    │   ├── components/
    │   │   ├── README.md
    │   │   ├── ratelimiter/
    │   │   │   └── README.md
    │   │   └── triggers/
    │   │       └── README.md
    │   ├── convex/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── CONTRIBUTING.md
    │   │   ├── api-extractor-configs/
    │   │   │   ├── README.md
    │   │   │   └── reports/
    │   │   │       └── server.api.md
    │   │   └── src/
    │   │       ├── common/
    │   │       │   └── README.md
    │   │       └── server/
    │   │           └── README.md
    │   ├── convex-ai-chat/
    │   │   ├── README.md
    │   │   └── convex/
    │   │       └── README.md
    │   ├── convex-chat-speculative/
    │   │   └── convex/
    │   │       └── README.md
    │   ├── dashboard/
    │   │   └── README.md
    │   ├── dashboard-common/
    │   │   ├── README.md
    │   │   └── src/
    │   │       └── pages/
    │   │           └── README.md
    │   ├── dashboard-self-hosted/
    │   │   └── README.md
    │   ├── demos/
    │   │   ├── README.md
    │   │   ├── args-validation/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── clerk/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── convex-test/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── cron-jobs/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── custom-errors/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── dall-e-storage-action/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── file-storage/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── file-storage-with-http/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── giphy-action/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── html/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── http/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── nextjs-app-router/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── nextjs-pages-router/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── node/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── pagination/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── presence-facepile/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── presence-typing-indicator/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── prewarming/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── python-quickstart/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── react-native/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── react-query/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── relational-data-modeling/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── scheduling/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── search/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── sessions/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── system-tables/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── tour-chat/
    │   │   │   ├── 0-start/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── 1-smileys/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── 2-likes/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   └── 3-ai/
    │   │   │       ├── README.md
    │   │   │       └── convex/
    │   │   │           └── README.md
    │   │   ├── tutorial/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── typescript/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── users-and-auth/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── users-and-clerk/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── users-and-clerk-webhooks/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── vector-search/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   └── zod-validation-ts/
    │   │       ├── README.md
    │   │       └── convex/
    │   │           └── README.md
    │   ├── docs/
    │   │   ├── README.md
    │   │   ├── docs/
    │   │   │   ├── _betaAdmonition.mdx
    │   │   │   ├── _betaContactUsAdmonition.mdx
    │   │   │   ├── _convexValues.mdx
    │   │   │   ├── _proFeatureUpsell.mdx
    │   │   │   ├── agents.mdx
    │   │   │   ├── ai.mdx
    │   │   │   ├── auth.mdx
    │   │   │   ├── chef.mdx
    │   │   │   ├── cli.md
    │   │   │   ├── components.mdx
    │   │   │   ├── dashboard.md
    │   │   │   ├── database.mdx
    │   │   │   ├── deployment-api.mdx
    │   │   │   ├── deployment-platform-api.mdx
    │   │   │   ├── error.mdx
    │   │   │   ├── eslint.mdx
    │   │   │   ├── file-storage.mdx
    │   │   │   ├── functions.mdx
    │   │   │   ├── home.mdx
    │   │   │   ├── management-api.mdx
    │   │   │   ├── platform-apis.mdx
    │   │   │   ├── production.mdx
    │   │   │   ├── quickstarts.mdx
    │   │   │   ├── realtime.mdx
    │   │   │   ├── scheduling.mdx
    │   │   │   ├── search.mdx
    │   │   │   ├── self-hosting.mdx
    │   │   │   ├── streaming-export-api.mdx
    │   │   │   ├── streaming-import-api.mdx
    │   │   │   ├── testing.mdx
    │   │   │   ├── agents/
    │   │   │   │   ├── agent-usage.mdx
    │   │   │   │   ├── context.mdx
    │   │   │   │   ├── debugging.mdx
    │   │   │   │   ├── files.mdx
    │   │   │   │   ├── getting-started.mdx
    │   │   │   │   ├── human-agents.mdx
    │   │   │   │   ├── messages.mdx
    │   │   │   │   ├── playground.mdx
    │   │   │   │   ├── rag.mdx
    │   │   │   │   ├── rate-limiting.mdx
    │   │   │   │   ├── streaming.mdx
    │   │   │   │   ├── threads.mdx
    │   │   │   │   ├── tools.mdx
    │   │   │   │   ├── usage-tracking.mdx
    │   │   │   │   └── workflows.mdx
    │   │   │   ├── ai/
    │   │   │   │   ├── convex-mcp-server.mdx
    │   │   │   │   ├── using-cursor.mdx
    │   │   │   │   ├── using-github-copilot.mdx
    │   │   │   │   └── using-windsurf.mdx
    │   │   │   ├── auth/
    │   │   │   │   ├── _under_the_hood.mdx
    │   │   │   │   ├── auth0.mdx
    │   │   │   │   ├── clerk.mdx
    │   │   │   │   ├── convex-auth.mdx
    │   │   │   │   ├── database-auth.mdx
    │   │   │   │   ├── debug.mdx
    │   │   │   │   ├── functions-auth.mdx
    │   │   │   │   ├── advanced/
    │   │   │   │   │   ├── custom-auth.mdx
    │   │   │   │   │   └── custom-jwt.mdx
    │   │   │   │   └── authkit/
    │   │   │   │       ├── auto-provision.mdx
    │   │   │   │       ├── index.mdx
    │   │   │   │       └── troubleshooting.md
    │   │   │   ├── cli/
    │   │   │   │   ├── background-agents.mdx
    │   │   │   │   ├── deploy-key-types.mdx
    │   │   │   │   └── local-deployments-for-dev.mdx
    │   │   │   ├── client/
    │   │   │   │   ├── android.md
    │   │   │   │   ├── javascript.mdx
    │   │   │   │   ├── open-api.mdx
    │   │   │   │   ├── python.md
    │   │   │   │   ├── react-native.mdx
    │   │   │   │   ├── react.mdx
    │   │   │   │   ├── rust.md
    │   │   │   │   ├── svelte.md
    │   │   │   │   ├── swift.md
    │   │   │   │   ├── vue.md
    │   │   │   │   ├── android/
    │   │   │   │   │   └── data-types.md
    │   │   │   │   ├── javascript/
    │   │   │   │   │   ├── bun.mdx
    │   │   │   │   │   ├── node.mdx
    │   │   │   │   │   └── script-tag.mdx
    │   │   │   │   ├── nextjs/
    │   │   │   │   │   ├── app-router/
    │   │   │   │   │   │   ├── index.mdx
    │   │   │   │   │   │   └── server-rendering.mdx
    │   │   │   │   │   └── pages-router/
    │   │   │   │   │       ├── index.mdx
    │   │   │   │   │       └── quickstart-nextjs-pages-router.mdx
    │   │   │   │   ├── react/
    │   │   │   │   │   ├── optimistic-updates.mdx
    │   │   │   │   │   └── project-setup.md
    │   │   │   │   ├── swift/
    │   │   │   │   │   └── data-types.md
    │   │   │   │   ├── tanstack/
    │   │   │   │   │   ├── tanstack-query/
    │   │   │   │   │   │   └── index.mdx
    │   │   │   │   │   └── tanstack-start/
    │   │   │   │   │       ├── clerk.mdx
    │   │   │   │   │       └── index.mdx
    │   │   │   │   └── vue/
    │   │   │   │       └── nuxt.md
    │   │   │   ├── components/
    │   │   │   │   ├── authoring.mdx
    │   │   │   │   ├── understanding.mdx
    │   │   │   │   └── using.mdx
    │   │   │   ├── dashboard/
    │   │   │   │   ├── projects.md
    │   │   │   │   ├── teams.md
    │   │   │   │   └── deployments/
    │   │   │   │       ├── data.md
    │   │   │   │       ├── deployments.md
    │   │   │   │       ├── files.md
    │   │   │   │       ├── functions.md
    │   │   │   │       ├── health.md
    │   │   │   │       ├── history.md
    │   │   │   │       ├── logs.md
    │   │   │   │       ├── schedules.md
    │   │   │   │       └── settings.md
    │   │   │   ├── database/
    │   │   │   │   ├── backup-restore.mdx
    │   │   │   │   ├── document-ids.mdx
    │   │   │   │   ├── pagination.mdx
    │   │   │   │   ├── schemas.mdx
    │   │   │   │   ├── types.md
    │   │   │   │   ├── writing-data.mdx
    │   │   │   │   ├── advanced/
    │   │   │   │   │   ├── occ.md
    │   │   │   │   │   ├── schema-philosophy.md
    │   │   │   │   │   └── system-tables.mdx
    │   │   │   │   ├── import-export/
    │   │   │   │   │   ├── export.mdx
    │   │   │   │   │   ├── import-export.mdx
    │   │   │   │   │   └── import.mdx
    │   │   │   │   └── reading-data/
    │   │   │   │       ├── filters.mdx
    │   │   │   │       ├── reading-data.mdx
    │   │   │   │       └── indexes/
    │   │   │   │           ├── indexes-and-query-perf.md
    │   │   │   │           └── indexes.md
    │   │   │   ├── file-storage/
    │   │   │   │   ├── delete-files.mdx
    │   │   │   │   ├── file-metadata.mdx
    │   │   │   │   ├── serve-files.mdx
    │   │   │   │   ├── store-files.mdx
    │   │   │   │   └── upload-files.mdx
    │   │   │   ├── functions/
    │   │   │   │   ├── actions.mdx
    │   │   │   │   ├── bundling.mdx
    │   │   │   │   ├── debugging.mdx
    │   │   │   │   ├── http-actions.mdx
    │   │   │   │   ├── internal-functions.mdx
    │   │   │   │   ├── mutation-functions.mdx
    │   │   │   │   ├── query-functions.mdx
    │   │   │   │   ├── runtimes.mdx
    │   │   │   │   ├── validation.mdx
    │   │   │   │   └── error-handling/
    │   │   │   │       ├── application-errors.mdx
    │   │   │   │       └── error-handling.mdx
    │   │   │   ├── generated-api/
    │   │   │   │   ├── api.md
    │   │   │   │   ├── data-model.md
    │   │   │   │   ├── index.md
    │   │   │   │   └── server.md
    │   │   │   ├── http-api/
    │   │   │   │   └── index.md
    │   │   │   ├── platform-apis/
    │   │   │   │   ├── embedded-dashboard.mdx
    │   │   │   │   └── oauth-applications.mdx
    │   │   │   ├── production/
    │   │   │   │   ├── contact.md
    │   │   │   │   ├── environment-variables.mdx
    │   │   │   │   ├── multiple-repos.mdx
    │   │   │   │   ├── pause-deployment.mdx
    │   │   │   │   ├── project-configuration.mdx
    │   │   │   │   ├── hosting/
    │   │   │   │   │   ├── custom.mdx
    │   │   │   │   │   ├── hosting.mdx
    │   │   │   │   │   ├── netlify.mdx
    │   │   │   │   │   ├── preview-deployments.mdx
    │   │   │   │   │   └── vercel.mdx
    │   │   │   │   ├── integrations/
    │   │   │   │   │   ├── exception-reporting.mdx
    │   │   │   │   │   ├── integrations.mdx
    │   │   │   │   │   ├── streaming-import-export.md
    │   │   │   │   │   └── log-streams/
    │   │   │   │   │       ├── legacy-event-schema.mdx
    │   │   │   │   │       └── log-streams.mdx
    │   │   │   │   └── state/
    │   │   │   │       ├── limits.mdx
    │   │   │   │       └── state.mdx
    │   │   │   ├── quickstart/
    │   │   │   │   ├── android.mdx
    │   │   │   │   ├── bun.mdx
    │   │   │   │   ├── nextjs.mdx
    │   │   │   │   ├── nodejs.mdx
    │   │   │   │   ├── nuxt.mdx
    │   │   │   │   ├── python.mdx
    │   │   │   │   ├── react-native.mdx
    │   │   │   │   ├── react.mdx
    │   │   │   │   ├── remix.mdx
    │   │   │   │   ├── rust.mdx
    │   │   │   │   ├── script-tag.mdx
    │   │   │   │   ├── svelte.mdx
    │   │   │   │   ├── swift.mdx
    │   │   │   │   ├── tanstack-start.mdx
    │   │   │   │   └── vue.mdx
    │   │   │   ├── scheduling/
    │   │   │   │   ├── cron-jobs.mdx
    │   │   │   │   └── scheduled-functions.mdx
    │   │   │   ├── search/
    │   │   │   │   ├── text-search.mdx
    │   │   │   │   └── vector-search.mdx
    │   │   │   ├── testing/
    │   │   │   │   ├── ci.mdx
    │   │   │   │   ├── convex-backend.mdx
    │   │   │   │   └── convex-test.mdx
    │   │   │   ├── tutorial/
    │   │   │   │   ├── actions.mdx
    │   │   │   │   ├── index.mdx
    │   │   │   │   └── scale.mdx
    │   │   │   └── understanding/
    │   │   │       ├── index.mdx
    │   │   │       ├── workflow.mdx
    │   │   │       ├── zen.mdx
    │   │   │       └── best-practices/
    │   │   │           ├── best-practices.mdx
    │   │   │           ├── other-recommendations.mdx
    │   │   │           └── typescript.mdx
    │   │   └── src/
    │   │       └── plugins/
    │   │           └── zoom-vanilla/
    │   │               └── README.md
    │   ├── js-integration-tests/
    │   │   ├── README.md
    │   │   └── convex/
    │   │       └── README.md
    │   ├── node-executor/
    │   │   └── README.md
    │   ├── package-tests/
    │   │   └── README.md
    │   ├── private-demos/
    │   │   ├── README.md
    │   │   ├── actions/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── bundle-size/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── cjs-typescript/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── clerk-initial-auth/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── components-api-import/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── components-api-import-ts/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── components-legacy/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── components-legacy-ts/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── components-npm/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── components-poc/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── components-ts-alias/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── convex-tour-chat-tutorial/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── cron/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── deploy-speed-test/
    │   │   │   └── README.md
    │   │   ├── http/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── javascript/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── javascript-old-syntax/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── middleware/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── nextjs-15-app/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── nextjs-15-app-clerk/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── nextjs-app-router-snippets/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── npm-showcase/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── openauth-react/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── pagination-adversarial/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── pagination-visualization/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── quickstarts/
    │   │   │   ├── README.md
    │   │   │   ├── bun/
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── expo/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── nextjs/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── nextjs-app-dir/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── nextjs-app-dir-14/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── nextjs-app-dir-js/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── nodejs/
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── nuxt/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── react-vite/
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── react-vite-ts/
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── remix/
    │   │   │   │   ├── README.md
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   ├── sveltekit/
    │   │   │   │   ├── README.md
    │   │   │   │   └── src/
    │   │   │   │       └── convex/
    │   │   │   │           └── README.md
    │   │   │   ├── tanstack-start/
    │   │   │   │   └── convex/
    │   │   │   │       └── README.md
    │   │   │   └── vue/
    │   │   │       ├── README.md
    │   │   │       └── convex/
    │   │   │           └── README.md
    │   │   ├── rust-wasm/
    │   │   │   └── README.md
    │   │   ├── snippets/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── static-codegen/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── static-codegen-ts/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── tanstack-start/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── tanstack-start-clerk/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── tanstack-start-workos/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── test-data/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── test-project/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── text-importer/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── tsgo-test/
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── tutorial/
    │   │   │   └── README.md
    │   │   ├── typescript-exact-optional-property-types/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── typescript-modern/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── typescript-old/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── uses-ents/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── vector-importer/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   ├── vector-search/
    │   │   │   ├── README.md
    │   │   │   └── convex/
    │   │   │       └── README.md
    │   │   └── waitlist/
    │   │       ├── README.md
    │   │       └── convex/
    │   │           └── README.md
    │   ├── publishing-tests/
    │   │   └── README.md
    │   ├── retention-tester/
    │   │   ├── README.md
    │   │   └── convex/
    │   │       └── README.md
    │   ├── scenario-runner/
    │   │   └── README.md
    │   ├── shared-cursors/
    │   │   └── convex/
    │   │       └── README.md
    │   ├── simulation/
    │   │   └── convex/
    │   │       └── README.md
    │   ├── system-udfs/
    │   │   └── convex/
    │   │       ├── README.md
    │   │       └── _system/
    │   │           └── cli/
    │   │               └── README.md
    │   ├── udf-runtime/
    │   │   └── README.md
    │   ├── udf-tests/
    │   │   ├── README.md
    │   │   ├── convex/
    │   │   │   └── README.md
    │   │   └── wasm/
    │   │       └── README.md
    │   └── version/
    │       ├── README.md
    │       └── convex/
    │           └── README.md
    └── self-hosted/
        ├── README.md
        ├── CHANGELOG.md
        ├── advanced/
        │   ├── benchmarking.md
        │   ├── dashboard.md
        │   ├── disabling_logging.md
        │   ├── hosting_on_own_infra.md
        │   ├── knobs.md
        │   ├── postgres_or_mysql.md
        │   ├── running_binary_directly.md
        │   ├── s3_storage.md
        │   ├── upgrading.md
        │   ├── devcontainer/
        │   │   └── README.md
        │   ├── fly/
        │   │   └── README.md
        │   └── railway/
        │       └── README.md
        └── docker-build/
            └── README.md

================================================
FILE: README.md
================================================
<p align="center">
<picture>
  <source media="(prefers-color-scheme: dark)" srcset="https://static.convex.dev/logo/convex-logo-light.svg" width="600">
  <source media="(prefers-color-scheme: light)" srcset="https://static.convex.dev/logo/convex-logo.svg" width="600">
  <img alt="Convex logo" src="https://static.convex.dev/logo/convex-logo.svg" width="600">
</picture>
</p>

[Convex](https://convex.dev) is the open-source reactive database designed to
make life easy for web app developers, whether human or LLM. Fetch data and
perform business logic with strong consistency by writing pure TypeScript.

Convex provides a database, a place to write your server functions, and client
libraries. It makes it easy to build and scale dynamic live-updating apps.
[Read the docs to learn more](https://docs.convex.dev/understanding/).

Development of the Convex backend is led by the Convex team. We
[welcome bug fixes](./CONTRIBUTING.md) and
[love receiving feedback](https://discord.gg/convex). We keep this repository
synced with any internal development work within a handful of days.

## Getting Started

Visit our [documentation](https://docs.convex.dev/) to learn more about Convex
and follow our getting started guides.

The easiest way to build with Convex is through our
[cloud platform](https://www.convex.dev/plans), which includes a generous free
tier and lets you focus on building your application without worrying about
infrastructure. Many small applications and side-projects can operate entirely
on the free tier with zero cost and zero maintenance.

## Self Hosting

The self-hosted product includes most features of the cloud product, including
the dashboard and CLI. Self-hosted Convex works well with a variety of tools
including Neon, Fly.io, Vercel, Netlify, RDS, Sqlite, Postgres, and more.

You can either use Docker (recommended) or a prebuilt binary to self host
Convex. Check out our [self-hosting guide](./self-hosted/README.md) for detailed
instructions. Community support for self-hosting is available in the
`#self-hosted` channel on [Discord](https://discord.gg/convex).

## Community & Support

- Join our [Discord community](https://discord.gg/convex) for help and
  discussions.
- Report issues when building and using the open source Convex backend through
  [GitHub Issues](https://github.com/get-convex/convex-backend/issues)
- By submitting pull requests, you confirm that Convex can use, modify, copy,
  and redistribute the contribution, under the terms of its choice.

## Building from source

See [BUILD.md](./BUILD.md).

## Disclaimers

- If you choose to self-host, we recommend following the self-hosting guide. If
  you are instead building from source, make sure to change your instance secret
  and admin key from the defaults in the repo.
- Convex is battle tested most thoroughly on Linux and Mac. On Windows, it has
  less experience. If you run into issues, please message us on
  [Discord](https://convex.dev/community) in the `#self-hosted` channel.
- Convex self-hosted builds contain a beacon to help Convex improve the product.
  The information is minimal and anonymous and helpful to Convex, but if you
  really want to disable it, you can set the `--disable-beacon` flag on the
  backend binary. The beacon's messages print in the log and only include
  - A random identifier for your deployment (not used elsewhere)
  - Migration version of your database
  - Git rev of the backend
  - Uptime of the backend

## Repository layout

- `crates/` contains Rust code

  - Main binary
    - `local_backend/` is an application server on top of the `Runtime`. This is
      the serving edge for the Convex cloud.

- `npm-packages/` contains both our public and internal TypeScript packages.
  - Internal packages
    - `udf-runtime/` sets up the user-defined functions JS environment for
      queries and mutations
    - `udf-tests/` is a collection of functions used in testing the isolate
      layer
    - `system-udfs/` contains functions used by the Convex system e.g. the CLI



================================================
FILE: BUILD.md
================================================
# Building from source

## Installing dependencies

You will need to first install the following dependencies if you don't already
have them on your machine:

To use the scripts set up in this repo:

- [`Just`](https://github.com/casey/just)
  - Just is used to execute scripts set up in the `Justfile`.
  - To install it see
    [Packages](https://github.com/casey/just?tab=readme-ov-file#packages), for
    example `cargo install just` or `brew install just`

To run the Convex CLI:

- [Node.js](https://nodejs.org/en)
  - Make sure you have the version specified in `.nvmrc`
  - We recommend installing Node.js via
    [nvm](https://github.com/nvm-sh/nvm#installing-and-updating).
  - Run `nvm use` from the root of the repo.

To [build the backend from source](#building-from-source):

- Cargo
  - The convex local backend is written in Rust. Cargo is the build system.
  - We recommend installing Cargo via [rustup](https://rustup.rs/).
- The Rust nightly version specified in `rust-toolchain`
  - Assuming you installed Rust/Cargo with `rustup`, this will install
    automatically.
- Rush
  - `npm clean-install --prefix scripts`
  - We manage the packages in a monorepo using [Rush](https://rushjs.io/).
- Convex JavaScript dependencies
  - `just rush install`

### Building from source

Build and run the local backend from the source in this repo:

```sh
just run-local-backend
```

## Provisioning a demo app locally

This example will go through running the backend with the included demo project.

**1. Start the backend**

[Run the backend](#running-the-convex-backend)

If this fails with an error "persisted db metadata ..." you might need to erase
the local database, in root directory run `rm convex_local_backend.sqlite3`.

**2. Develop against the backend**

The Convex CLI watches for changes in the application source code and pushes the
code to backend.

To make the local backend run the included demo project, do:

```bash
cd npm-packages/demos/tutorial
npm i
just convex dev
```

The `convex` script in `Justfile` automatically adds appropriate `--url` and
`--admin-key` flags to point the CLI to the local backend.

To run the client web application you can run the demo Vite server via:

```bash
npm run dev:frontend
```

Note that unlike the hosted Convex workflow, we don't want to run the
`dev:backend` command since `convex dev` is already running.

_The following CLI commands may be useful when interacting with your backend:_

- `just convex data` - Lists tables in your Convex deployment
- `just convex env` - Allows you to list/set/update/delete environment variables
- `just convex logs` - Streams out log lines to the terminal (it includes all
  successful executions if `--success` is passed in)
- `just convex import` - Allows you to import tables
- `just convex export` - Allows you to export tables

If you're using both the local backend and the hosted cloud platform, make sure
to run `npx convex dev` or `just convex dev` before you start testing your
client. The `dev` command will take care of updating your `.env.local` file with
the correct `CONVEX_URL`.



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing

Please share any general questions, feature requests, or product feedback in our
[Convex Discord Community](https://convex.dev/community). We're particularly
excited to see what you build on Convex!

Please ensure that rust code is formatted with
[cargo fmt](https://github.com/rust-lang/rustfmt) and markdown files are
formatted with [prettier](https://prettier.io/).

Convex is a fast moving project developed by a dedicated team. We're excited to
contribute to the community by releasing this code, but we want to manage
expectations as well.

- We value a cohesive developer experience for folks building applications
  across all of our languages and platforms.
- We value transparency in how we operate.

Smaller PRs that affect documentation, comments, or small bugfixes are easy to
review and integrate. For any larger or more fundamental changes, get in touch
with us on Discord before you put in too much work to see if it's consistent
with our product plans. We are generally unlikely to take large or fundamental
changes as community contributions. We think carefully about how our APIs
contribute to a cohesive product in line with our roadmap, so we cannot promise
that larger PRs will get the same level of attention.

Instructions for building and running Convex packages locally:

- [Building the backend and CLI from source](BUILD.md)
- [Running the dashboard](npm-packages/dashboard-self-hosted/README.md)

Note: If you just want to self-host Convex and not modify the codebase, we
recommend using the pre-built Docker image or binary. See the
[self-hosted README](self-hosted/README.md) for more information.

By submitting pull requests, you confirm that Convex can use, modify, copy, and
redistribute the contribution, under the terms of its choice.



================================================
FILE: LICENSE.md
================================================
# Functional Source License, Version 1.1, Apache 2.0 Future License

## Abbreviation

FSL-1.1-Apache-2.0

## Notice

Copyright 2025 Convex, Inc.

## Terms and Conditions

### Licensor ("We")

The party offering the Software under these Terms and Conditions.

### The Software

The "Software" is each version of the software that we make available under
these Terms and Conditions, as indicated by our inclusion of these Terms and
Conditions with the Software.

### License Grant

Subject to your compliance with this License Grant and the Patents,
Redistribution and Trademark clauses below, we hereby grant you the right to
use, copy, modify, create derivative works, publicly perform, publicly display
and redistribute the Software for any Permitted Purpose identified below.

### Permitted Purpose

A Permitted Purpose is any purpose other than a Competing Use. A Competing Use
means making the Software available to others in a commercial product or service
that:

1. substitutes for the Software;

2. substitutes for any other product or service we offer using the Software that
   exists as of the date we make the Software available; or

3. offers the same or substantially similar functionality as the Software.

Permitted Purposes specifically include using the Software:

1. for your internal use and access;

2. for non-commercial education;

3. for non-commercial research; and

4. in connection with professional services that you provide to a licensee using
   the Software in accordance with these Terms and Conditions.

### Patents

To the extent your use for a Permitted Purpose would necessarily infringe our
patents, the license grant above includes a license under our patents. If you
make a claim against any party that the Software infringes or contributes to the
infringement of any patent, then your patent license to the Software ends
immediately.

### Redistribution

The Terms and Conditions apply to all copies, modifications and derivatives of
the Software.

If you redistribute any copies, modifications or derivatives of the Software,
you must include a copy of or a link to these Terms and Conditions and not
remove any copyright notices provided in or with the Software.

### Disclaimer

THE SOFTWARE IS PROVIDED "AS IS" AND WITHOUT WARRANTIES OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING WITHOUT LIMITATION WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, TITLE OR NON-INFRINGEMENT.

IN NO EVENT WILL WE HAVE ANY LIABILITY TO YOU ARISING OUT OF OR RELATED TO THE
SOFTWARE, INCLUDING INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, EVEN
IF WE HAVE BEEN INFORMED OF THEIR POSSIBILITY IN ADVANCE.

### Trademarks

Except for displaying the License Details and identifying us as the origin of
the Software, you have no right under these Terms and Conditions to use our
trademarks, trade names, service marks or product names.

## Grant of Future License

We hereby irrevocably grant you an additional license to use the Software under
the Apache License, Version 2.0 that is effective on the second anniversary of
the date we make the Software available. On or after that date, you may use the
Software under the Apache License, Version 2.0, in which case the following will
apply:

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License.

You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.



================================================
FILE: crates/AGENTS.md
================================================
# Rust crates

## Development workflow

```sh
# After each change
just format-rust

# When a change is ready
just lint-rust
cargo build -p <package>
cargo test -p <package>
cargo test -p <package> "test_name" # for a specific test or test group
```



================================================
FILE: crates/backend_harness/README.md
================================================
Backend Harness library which provides methods that spin up / spin down a
backend for testing. Supports production backends and local process backends.

Other scripts can use the backend-harness library to manage backend coming up /
going down (eg load tester)

There's a small binary included to show off how to use backend-harness



================================================
FILE: crates/convex/README.md
================================================
# Convex

The official Rust client for [Convex](https://convex.dev/).

![GitHub](https://img.shields.io/github/license/get-convex/convex-rs)

Convex is the backend application platform with everything you need to build
your product.

This Rust client can write and read data from a Convex backend with queries,
mutations, and actions. Get up and running at
[docs.convex.dev](https://docs.convex.dev/introduction/).

[Join us on Discord](https://www.convex.dev/community) to share what you're
working on or get your questions answered.

# Installation

Add the following to your `Cargo.toml` file

```toml
[dependencies]
convex = "*"
```

# Example

```rust
let mut client = ConvexClient::new(DEPLOYMENT_URL).await?;
let mut subscription = client.subscribe("getCounter", vec![]).await?;
while let Some(new_val) = subscription.next().await {
    println!("Counter updated to {new_val:?}");
}
```

# Documentation

Check out the full convex documentation at
[docs.convex.dev](https://docs.convex.dev/introduction/) The rust API docs are
available on [docs.rs](https://docs.rs/convex/latest/convex/)

# MSRV

The Convex rust client works on stable rust 1.71.1 and higher. It also works on
nightly.

# Debug Logging

The Convex Rust Client uses the
[tracing](https://docs.rs/tracing/latest/tracing/) crate for logging. One common
way of initializing is via `tracing_subscriber`. Then, you can see debug logging
by running your program with `RUST_LOG=convex=debug`.

```rust
tracing_subscriber::fmt()
    .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
    .init();
```

By default, this will emit all logs, including internal logs from the client.
Logs from your Convex backend will show up under the `convex_logs` target at
Level=DEBUG. If you want to isolate just those logs, please refer to the
[tracing_subscriber documentation](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/layer/index.html#filtering-with-layers).



================================================
FILE: crates/convex/CHANGELOG.md
================================================
# 0.10.2

- Fix for deadlock between client and websocket worker tasks
- Update `tokio` dependency

# 0.10.1

- Bump sync_types version and depend on it

# 0.10.0

- Fix for panic in query subscriptions
- Bump rust-version minimum from 1.71.1 to 1.80.1

# 0.9.0

- Add `ConvexClientBuilder` pattern for constructing `ConvexClient`
- Add support for `on_state_change` for handling reconnects.
- Bump rust-version minimum from 1.65.0 to 1.71.1
- Update `url` dependency.

# 0.8.1

Remove native-tls-vendored dependency for tokio-tungstenite. Rely on requested
features instead.

# 0.8.0

- Support for passing through a client_id to ConvexClient
- Dependency upgrades

# 0.7.0

- Several dependency upgrades

# 0.6.0

- Remove support for Set and Map Convex types. These types are deprecated.
- Add comprehensive support for ConvexError with `data` payload as part of the
  `FunctionResult` enum.
- Better support for emitting loglines

# 0.5.0

- Prelim support for ConvexError, encoded into an anyhow::Error. Eventual plan
  is to expose a separate catchable type, but just getting something out
  quickly. PRs accepted!

# 0.4.0

- Expose an alternate cleaner JSON export format on Value. The clean format is
  lossy in some cases (eg both integers and strings are encoded as JSON
  strings).
- Expose native-tls-vendored feature

# 0.3.1

- Fix compilation with `--features=testing`
- Minor syntactic changes to quickstart

# 0.3.0

- Remove `Value::Id` since document IDs are `Value::String`s for Convex
  functions starting from NPM version 0.17
- Minor improvements to convex_chat_client example
- Minor improvements in convex_sync_types

# 0.2.0

- BUGFIX: Client occasionally used to get stuck in a hot loop after network
  disconnect.
- Tweak backoff params for better performance across network disconnect.
- Minor improvements to convex_chat_client example
- Minor fix to running tests
- Bump tokio-tungstenite to 0.18
- Minor improvements in convex_sync_types

# 0.1.2

Yanked and re-released as 0.2.0

# 0.1.1

- Fix race between mutation result and dropping a subscription.
- Minor logging/error message improvements.

# 0.1.0

- Initial release.
- Support for queries, subscriptions, mutations, actions



================================================
FILE: crates/convex/CONTRIBUTING.md
================================================
# Contributing

Contributions are welcome!

Please share any general questions, feature requests, or product feedback in our
[Convex Discord Community](https://convex.dev/community). We're particularly
excited to see what you build on Convex!

Please ensure that rust code is formatted with
[cargo fmt](https://github.com/rust-lang/rustfmt) and markdown files are
formatted with [prettier](https://prettier.io/).

Run tests with

```
cargo test -p {crate}
```

Convex is a fast moving project developed by a dedicated team. We're excited to
contribute to the community by releasing this code, but we want to manage
expectations as well.

- We are a small company with a lot of product surface area.
- We value a cohesive developer experience for folks building applications
  across all of our languages and platforms.
- We value transparency in how we operate.

We're excited for community PRs. Be aware we may not get to it for a while.
Smaller PRs that only affect documentation/comments are easier to review and
integrate. For any larger or more fundamental changes, get in touch with us on
Discord before you put in too much work to see if it's consistent with our short
term plan. We think carefully about how our APIs contribute to a cohesive
product, so chatting up front goes a long way.

# Docs contributions

Docs are located in the `npm-packages/docs` directory. See the README there for
more info.



================================================
FILE: crates/convex/sync_types/README.md
================================================
# Convex Sync Types

Internal sync types for the Convex protocol required for building a subscription
client.

For a fully built client using tokio, see

https://crates.io/crates/convex/

https://github.com/get-convex/convex-rs



================================================
FILE: crates/database/README.md
================================================
# Architecture diagram (9/9/2022)

## At Rest: The SnapshotManager

First, let's look at what the `Database` looks like at rest. The primary
structure is the `SnapshotManager`, which maintains many different `Snapshot`s
at different `Timestamp`s.

```text

                                              ┌───────────────────────────┐
                                              │                           │
                                              │                           │
                                              │         Database          │
                                              │                           │
                                              │                           │
                                              └───────────────────────────┘
                                                            │
                                                            │
                                                            │
                                                            │
                                                            ▼
┌───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│SnapshotManager                                                                                                        │
│                                                           .                                                           │
│                                                           .                                                           │
│                                                           .                                                           │
│                                                                                                                       │
│ ┌───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────┐ │
│ │   Timestamp   │                                             Snapshot                                              │ │
│ └───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────┘ │
│ ┌───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────┐ │
│ │   Timestamp   │                                             Snapshot                                              │ │
│ └───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────┘ │
│ ┌───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────┐ │
│ │               │Snapshot◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟┌──────────────────────────────────────────────────┐◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│DatabaseIndex                                     │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ ┌──────────────────────────────────────────────┐ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │DatabaseIndexMetadata                         │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ ┌──────────────────────────────────────────┐ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │indexes: OrdMap                           │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │ ┌────────────┬─────────────────────────┐ │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │ │            │Index                    │ │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │ │            │  ┌────────────────────┐ │ │ │ │◟◟│ │
│ │               │◟◟┌───────────────────────────────────────┐◟◟│ │ │ │            │  │      IndexId       │ │ │ │ │◟◟│ │
│ │               │◟◟│DatabaseTableMetadata                  │◟◟│ │ │ │            │  └────────────────────┘ │ │ │ │◟◟│ │
│ │               │◟◟│ ┌───────────────────────────────────┐ │◟◟│ │ │ │            │  ┌────────────────────┐ │ │ │ │◟◟│ │
│ │               │◟◟│ │tables: OrdMap                     │ │◟◟│ │ │ │            │  │IndexMetadata       │ │ │ │ │◟◟│ │
│ │               │◟◟│ │ ┌───────────┬───────────────────┐ │ │◟◟│ │ │ │            │  │ ┌────────────────┐ │ │ │ │ │◟◟│ │
│ │               │◟◟│ │ │           │TableSummary       │ │ │◟◟│ │ │ │ IndexName  │  │ │   IndexName    │ │ │ │ │ │◟◟│ │
│ │               │◟◟│ │ │           │ ┌───────────────┐ │ │ │◟◟│ │ │ │            │  │ └────────────────┘ │ │ │ │ │◟◟│ │
│ │               │◟◟│ │ │           │ │     Shape     │ │ │ │◟◟│ │ │ │            │  │ ┌────────────────┐ │ │ │ │ │◟◟│ │
│ │               │◟◟│ │ │ TableName │ └───────────────┘ │ │ │◟◟│ │ │ │            │  │ │ IndexedFields  │ │ │ │ │ │◟◟│ │
│ │               │◟◟│ │ │           │ ┌───────────────┐ │ │ │◟◟│ │ │ │            │  │ └────────────────┘ │ │ │ │ │◟◟│ │
│ │               │◟◟│ │ │           │ │  total_size   │ │ │ │◟◟│ │ │ │            │  │ ┌────────────────┐ │ │ │ │ │◟◟│ │
│ │               │◟◟│ │ │           │ └───────────────┘ │ │ │◟◟│ │ │ │            │  │ │   IndexState   │ │ │ │ │ │◟◟│ │
│ │               │◟◟│ │ └───────────┴───────────────────┘ │ │◟◟│ │ │ │            │  │ └────────────────┘ │ │ │ │ │◟◟│ │
│ │   Timestamp   │◟◟│ └───────────────────────────────────┘ │◟◟│ │ │ │            │  └────────────────────┘ │ │ │ │◟◟│ │
│ │               │◟◟│ ┌───────────────────────────────────┐ │◟◟│ │ │ └────────────┴─────────────────────────┘ │ │ │◟◟│ │
│ │               │◟◟│ │           num_documents           │ │◟◟│ │ └──────────────────────────────────────────┘ │ │◟◟│ │
│ │               │◟◟│ └───────────────────────────────────┘ │◟◟│ │ ┌──────────────────────────────────────────┐ │ │◟◟│ │
│ │               │◟◟│ ┌───────────────────────────────────┐ │◟◟│ │ │             indexes_by_table             │ │ │◟◟│ │
│ │               │◟◟│ │             user_size             │ │◟◟│ │ └──────────────────────────────────────────┘ │ │◟◟│ │
│ │               │◟◟│ └───────────────────────────────────┘ │◟◟│ │ ┌──────────────────────────────────────────┐ │ │◟◟│ │
│ │               │◟◟│ ┌───────────────────────────────────┐ │◟◟│ │ │             num_user_indexes             │ │ │◟◟│ │
│ │               │◟◟│ │            system_size            │ │◟◟│ │ └──────────────────────────────────────────┘ │ │◟◟│ │
│ │               │◟◟│ └───────────────────────────────────┘ │◟◟│ └──────────────────────────────────────────────┘ │◟◟│ │
│ │               │◟◟└───────────────────────────────────────┘◟◟│ ┌──────────────────────────────────────────────┐ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │in_memory_indexes: OrdMap                     │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ ┌─────────┬────────────────────────────────┐ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │         │IndexMap: OrdMap                │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │         │ ┌───────────┬────────────────┐ │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │         │ │           │   Timestamp    │ │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │ IndexId │ │  Vec<u8>  ├────────────────┤ │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │         │ │           │ PackedDocument │ │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │         │ └───────────┴────────────────┘ │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ │         │                                │ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │ └─────────┴────────────────────────────────┘ │ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ └──────────────────────────────────────────────┘ │◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟└──────────────────────────────────────────────────┘◟◟│ │
│ │               │◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟◟│ │
│ └───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────┘ │
│ ┌───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────┐ │
│ │   Timestamp   │                                             Snapshot                                              │ │
│ └───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────┘ │
│ ┌───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────┐ │
│ │   Timestamp   │                                             Snapshot                                              │ │
│ └───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                                                       │
│                                                           .                                                           │
│                                                           .                                                           │
│                                                           .                                                           │
│                                                                                                                       │
└───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

```

Each `Snapshot` has two important types of system metadata: table metadata and
index metadata.

### Table metadata

Each table in the database has a row in the `_tables` table (including the
`_tables` table itself), and this information is always kept in memory within
the `TableRegistry` struct. Each table has its `TableSummary`, its current
`Shape` and total size, and we store the total number and size of all the
documents in the system.

### Index metadata

Every index has an entry in the `_index` table, and every table (including the
`_index` table) has its default `by_id` index. Similar to tables, we store this
information in-memory in the `IndexRegistry` struct. Each index has its name,
index ID, indexed fields, and current backfill state.

The `DatabaseIndexManager` stores the index metadata along with a few indexes
for system tables we always keep in memory.

### Wrap-up: Snapshot

This in-memory state gives the system enough information to know how to query
the `Persistence` at a given snapshot. It's designed to be a small amount of
information in-memory that's quick to load at startup.

# Active Transactions

WIP.

# Committing Transactions

WIP.



================================================
FILE: crates/fivetran_common/fivetran_sdk/README.md
================================================
This folder is a mirror of https://github.com/fivetran/fivetran_sdk at a pinned
revision. Vendoring this source lets us avoid depending on the network during
our builds.

When upgrading, be sure to select a rev off the `production` or `v2` tag of the
sdk :

- https://github.com/fivetran/fivetran_sdk/tree/production
- https://github.com/fivetran/fivetran_sdk/tree/v2



================================================
FILE: crates/fivetran_destination/README.md
================================================
# Fivetran Destination Connector

This crate contains a destination connector allowing developers using Convex to
replicate the data they have in other data sources to their Convex deployments.

The connector consists of a gRPC server hosted on the Fivetran infrastructure.
It communicates with the Convex deployment using the HTTP API it provides.

## Installation

Make sure you have Git and Cargo installed. We recommend installing Cargo via
[rustup](https://rustup.rs/).

```
git clone https://github.com/get-convex/convex-backend.git
cd convex-backend
cargo build --release -p fivetran_destination
```

You can then find the executable file in
`convex-backend/target/release/fivetran_destination`.

## Usage

You can start the connector by starting its binary:

```
$ ./fivetran_destination
{"level":"INFO","message":"Starting the destination on 0.0.0.0:50052","message-origin":"sdk_destination"}
```

You can change the port used using the optional `--port` parameter:

```
$ ./fivetran_destination --port 1337
{"level":"INFO","message":"Starting the destination on 0.0.0.0:1337","message-origin":"sdk_destination"}
```

## Implementation

Unlike the
[Fivetran source connector](https://github.com/get-convex/convex-backend/tree/main/crates/fivetran_source),
the destination connector does not manage the state of the synchronization
mechanism. This is done by Fivetran, which will call the relevant gRPC API
endpoints depending on the state of the data source.



================================================
FILE: crates/fivetran_destination/docs/overview.md
================================================
---
name: Convex
title: Fivetran for Convex | Configuration and documentation
description: Connect data sources to Convex with our partner-built Convex destination connector. Explore documentation and start syncing your applications, databases, events, files, and more.
menuPosition: 55
hidden: true
---

# Convex {% badge text="Partner-Built" /%} {% availabilityBadge connector="convex_destination" /%}

[Convex](https://convex.dev) is a full-stack TypeScript development platform with product-centric APIs. It can replace your database and server functions.

> NOTE: Fivetran supports Convex as both a partner-built [database connector](/docs/databases/convex) and a partner-built destination.

> NOTE: This destination is [partner-built](/docs/partner-built-program). For any questions related to the Convex destination and its documentation, refer to Convex's support team. For SLA details, see [Convex's Status and Guarantees documentation](https://docs.convex.dev/production/state).

---

## Setup guide

Follow our [step-by-step Convex setup guide](/docs/destinations/convex/setup-guide) to connect Convex as a destination with Fivetran.

---

## Schema information

Fivetran tries to replicate the database and columns from your data source to your Convex destination according to Fivetran's [standard database update strategies](/docs/databases#transformationandmappingoverview).

Once Fivetran connects to your Convex destination, the connector will attempt to load your data.
It may ask you to update your `convex/schema.ts` in your destination to match the format of your source.
Once the `convex/schema.ts` matches the source format, data will continue to sync.

### Type transformation mapping

The Convex destination extracts data from your source, and it matches supported [Fivetran data types](/docs/destinations#datatypes) to [Convex data types](https://docs.convex.dev/database/types).

We use the following data type conversions:

| Fivetran Type | Convex Type | Equivalence |
| ------------- | ----------- | ----------- |
| BOOLEAN       | Boolean     | Exact       |
| SHORT         | Float64     | Inexact     |
| INT           | Float64     | Inexact     |
| LONG          | Int64       | Exact       |
| DECIMAL       | String      | Inexact     |
| FLOAT         | Float64     | Inexact     |
| DOUBLE        | Float64     | Exact       |
| NAIVEDATE     | String      | Inexact     |
| NAIVEDATETIME | String      | Inexact     |
| UTCDATETIME   | Float64     | Inexact     |
| BINARY        | Bytes       | Exact       |
| STRING        | String      | Exact       |
| NULL          | Null        | Exact       |
| JSON          | Object      | Inexact     |

> NOTE: Short/Int are converted to float64 for ease of use in javascript (as `number`). There is no data loss as `Number.MAX_SAFE_INTEGER = 2^53 - 1`. Decimal is converted to STRING to ensure no data loss (e.g. "1234.5678").

> NOTE: Naive date uses standard string representation of `YYYY-MM-DD`. Naive datetime uses standard string representation of `YYYY-MM-DD HH:MM:SS`.

> NOTE: UTC datetime uses milliseconds since UNIX epoch.

### Fivetran-generated data

Fivetran adds a single `fivetran` column containing a Convex object to the source data.
Some of the columns (`synced`, `deleted`) are for internal purposes.

### Table and column name transformations

If your source table is `default.cars`, then your Convex table will be named `default_cars`.
Convex deployments do not have a concept of namespaced tables, so it uses this notation to preserve
the namespace information.

Column names that begin with `_` are not supported in Convex. Instead, those columns are synced to the
destination nested within the `fivetran.columns` column. For example, a column named `_line` would be synced as a nested column named `fivetran.columns.line`.



================================================
FILE: crates/fivetran_destination/docs/setup-guide.md
================================================
---
name: Setup Guide
title: Fivetran for Convex | Destination Setup Guide
description: Read step-by-step instructions on how to connect your Convex deployment as a destination using Fivetran.
menuPosition: 0
hidden: true
---

# Convex Setup Guide {% badge text="Partner-Built" /%} {% availabilityBadge connector="convex_destination" /%}

Follow our setup guide to connect Fivetran to Convex as a destination. 

> NOTE: This destination is [partner-built](/docs/partner-built-program). For any questions related to the Convex destination and its documentation, refer to Convex's support team. For SLA details, see [Convex's Status and Guarantees documentation](https://docs.convex.dev/production/state).

---

## Prerequisites

To connect your Convex deployment to Fivetran, you need the following:
- A [Convex account](https://dashboard.convex.dev).
- A Convex deployment. See [Convex's documentation](https://docs.convex.dev/) to get started.
- Your Convex deployment's URL (e.g., `https://jaded-raven-991.convex.cloud`).
- Your Convex deployment's deploy key. You can find both the deployment URL and deploy key on the [Production Deployment Settings](https://docs.convex.dev/dashboard/deployments/deployment-settings) page. 

---

## Setup instructions

### <span class="step-item">Find your deployment credentials</span>

1. Go to your deployment on the [Convex Dashboard](https://dashboard.convex.dev/).
2. Go to the [Production Deployment Settings](https://docs.convex.dev/dashboard/deployments/deployment-settings).
3. Find your **deployment URL** and **deploy key** and make a note of them. You will need them to configure Fivetran.

### <span class="step-item">Complete Fivetran configuration</span>

1. Log in to your [Fivetran account](https://fivetran.com/login).
2. Go to the **Destinations** page and click **Add destination**.
3. Enter a **Destination name** of your choice and then click **Add**.
4. Select Convex as the destination type.
5. Enter your [deployment credentials](#findyourdeploymentcredentials).
6. Click **Save & Test**. Fivetran tests and validates connection to your Convex deployment.

### <span class="step-item">Using Convex destination with a source connector</span>

1. In your Fivetran dashboard, click **Connectors > Add Connector**.
2. Select and configure a data source of your choice.
3. Select the [Convex destination you connected to](#completefivetranconfiguration).
4. Start your initial sync by clicking **Sync Now**.
5. The initial sync may fail with a user action to update [convex/schema.ts](https://docs.convex.dev/database/schemas).
   Follow the instructions in the error message to update your `schema.ts`. The error message will give you code to
   copy-paste into your `schema.ts`. It may take around 20 minutes for the error to appear.
6. Deploy your `schema.ts` with `npx convex deploy`.
7. Retry your initial sync by clicking **Sync Now**.

The example below is a sample `schema.ts` for a source with a single table `email.cars`.
```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

const fivetranTables = {
  email_cars: defineTable({
    description: v.union(v.string(), v.null()),
    fivetran: v.object({
      columns: v.object({
        directory: v.union(v.string(), v.null()),
        file: v.union(v.string(), v.null()),
        line: v.union(v.int64(), v.null()),
        modified: v.union(v.float64(), v.null()),
      }),
      synced: v.float64(),
    }),
    make: v.union(v.string(), v.null()),
    model: v.union(v.string(), v.null()),
    price: v.union(v.float64(), v.null()),
    year: v.union(v.int64(), v.null()),
  })
    .index("by_fivetran_synced", ["fivetran.synced"])
    .index("by_primary_key", [
      "fivetran.columns.directory",
      "fivetran.columns.file",
      "fivetran.columns.line",
      "fivetran.columns.modified",
    ]),
};

export default defineSchema({
  ...fivetranTables,
});
```

---

## Related articles

[<i aria-hidden="true" class="material-icons">description</i> Destination Overview](/docs/destinations/convex)

<b> </b>

[<i aria-hidden="true" class="material-icons">home</i> Documentation Home](/docs/getting-started)



================================================
FILE: crates/fivetran_destination/src/tests/fixtures/README.md
================================================
These test fixtures originate from the
[MotherDuck Fivetran Destination connector](https://github.com/MotherDuck-Open-Source/motherduck-fivetran-connector/tree/main)
repository, published under the
[MIT license](https://github.com/MotherDuck-Open-Source/motherduck-fivetran-connector/blob/main/LICENSE).



================================================
FILE: crates/fivetran_source/README.md
================================================
# Fivetran Source Connector

This crate contains a source connector allowing developers using Convex to
replicate the data they store in Convex to other databases.

The connector consists of a gRPC server hosted on the Fivetran infrastructure.
This server retrieves the data it needs using the HTTP API described
[in the Convex docs](https://docs.convex.dev/http-api/).

## Installation

Make sure you have Git and Cargo installed. We recommend installing Cargo via
[rustup](https://rustup.rs/).

```
git clone https://github.com/get-convex/convex-backend.git
cd convex-backend
cargo build --release -p fivetran_source
```

You can then find the executable file in
`convex-backend/target/release/fivetran_source`.

## Usage

You can start the connector by starting its binary:

```
$ ./fivetran_source
Starting the connector on [::]:50051
```

You can change the port used using the optional `--port` parameter:

```
$ ./fivetran_source --port 1337
Starting the connector on [::]:1337
```

## Sync Mechanism

The data synchronization happens in two steps:

- During the initial synchronization, the connector uses the
  [`list_snapshot`](https://docs.convex.dev/http-api/#get-apilist_snapshot) API
  to copy all documents.
- During subsequent synchronizations, the connector uses the
  [`document_deltas`](https://docs.convex.dev/http-api/#get-apidocument_deltas)
  API to only apply changes from documents that were modified since the last
  synchronization.

![Flowchart showing the synchronization mechanism.](flow.png)



================================================
FILE: crates/fivetran_source/CHANGELOG.md
================================================
# 2.0.1

- Improve error messages for failed API calls.

# 2.0.0

- Add support for Convex components.
- Add support for partial component, table, and column selection.
- This version requires a full historical resync for existing connections.

# 0.6.0

- Update rust nightly version in .rust-toolchain
- Remove deprecated set/map support
- Add gzip support to connector

# 0.5.0

- Emit a TRUNCATE op before the first write to any given table (in case it's a
  resync)
- Skip emitting an initial sync snapshot before the first page.

# 0.4.0

- Revert the `_convex_cursor` changes.
- Few updates to loglines
- docs updates

# 0.3.0

- Support a `_convex_cursor` table with a single column `cursor` which holds the
  `document_deltas` cursor representing the most recent sync.
- Add documentation to docs/

# 0.2.0

- Bump `convex` dep to 0.5.0
- Use /test_streaming_export_connection and /get_tables_and_columns endpoints
  rather than json_schemas json_schemas has stricter requirements around nested
  schemas than what fivetran requires.



================================================
FILE: crates/fivetran_source/docs/overview.md
================================================
---
name: Convex
title: Convex connector for Fivetran
description: Documentation and setup guide for the Convex connector for Fivetran
---

# Convex {% badge text="Partner-Built" /%} {% availabilityBadge connector="convex" /%}

[Convex](https://convex.dev) is a full-stack TypeScript development platform. Replace your database, server functions, and glue code.

{% note %}
This connector is [partner-built](/docs/partner-built-program). For any questions related to the Convex connector and its documentation, refer to Convex's support team. For details on SLA, see [Convex's Status and Guarantees documentation](https://docs.convex.dev/production/state).
{% /note %}

----

## Features

{% featureTable connector="convex" /%}

-----

{% partial file="saas-supported-deployment-models.template.md" /%}

-----

## Setup guide

Follow the [step-by-step Convex setup guide](/docs/connectors/databases/convex/setup-guide) to connect your Convex database with Fivetran.

---

## Sync overview

Once Fivetran is connected to your Convex deployment, the connection fetches an initial consistent snapshot of all data from your Convex database. Once the initial sync is complete, the connection uses Change data capture (CDC) to efficiently incrementally sync updates at a newer consistent view of your Convex deployment. You can configure the frequency of these updates.

---

## Configuration

To configure a Convex connection, you need your deployment URL and deploy key. You can find both on your project's [Production Deployment Settings page](https://docs.convex.dev/dashboard/deployments/deployment-settings).

---

## Schema information

Fivetran tries to replicate the database and columns from your configured Convex deployment to your destination according to Fivetran's [standard database update strategies](/docs/connectors/databases#transformationandmappingoverview).

### Type transformations and mapping

As the connection extracts your data, it matches [Convex data types](https://docs.convex.dev/database/types) to types that Fivetran supports.

The following table illustrates how the connection transforms your Convex data types into Fivetran-supported types:

| Convex Type | Fivetran Type | Fivetran Supported |
| ----------- | ------------- | ------------------ |
| Id          | STRING        | True               |
| Null        | NULL          | True               |
| Int64       | LONG          | True               |
| Float64     | DOUBLE        | True               |
| Boolean     | BOOLEAN       | True               |
| String      | STRING        | True               |
| Bytes       | BINARY        | True               |
| Array       | JSON          | True               |
| Object      | JSON          | True               |

{% note %}
The `_creationTime` system field  in each document is special-cased to convert into a UTC_DATETIME, despite being stored as a Float64 inside of Convex.
{% /note %}

{% note %}
Nested types inside Object and Array are serialized as JSON using the [JSON format for export](https://docs.convex.dev/database/types).
{% /note %}

### Nested data

Convex documents are represented as JSON [by using conversions](https://docs.convex.dev/database/types). If the first-level field is a simple data type, the connection will map it to its own type. If it's a complex nested data type such as an array or JSON data, it maps to a JSON type without unpacking. The connection does not automatically unpack nested JSON objects to separate tables in the destination. Any nested JSON objects are preserved as is in the destination so that you can use JSON processing functions.

For example, the following Convex document:

```json
{"street"  : "Main St."
"city"     : "New York"
"country"  : "US"
"phone"    : "(555) 123-5555"
"zip code" : 12345
"people"   : ["John", "Jane", "Adam"]
"car"      : {"make" : "Honda",
              "year" : 2014,
              "type" : "AWD"}
}
```

is converted to the following table when the connection loads it into your destination:

| \_id | street   | city     | country | phone          | zip code | people                   | car                                               |
| ---- | -------- | -------- | ------- | -------------- | -------- | ------------------------ | ------------------------------------------------- |
| 1    | Main St. | New York | US      | (555) 123-5555 | 12345    | ["John", "Jane", "Adam"] | {"make" : "Honda", "year" : 2014, "type" : "AWD"} |

### Fivetran-generated data

Fivetran adds the following column to every table in your destination:

- `_fivetran_synced` (UTC TIMESTAMP) indicates the time when Fivetran last successfully synced the row. It is added to every table.
- `_fivetran_deleted` (BOOLEAN) indicates if the column was deleted in the source.

Fivetran adds these columns to give you insight into the state of your data and the progress of your data syncs. For more information about these columns, see [our System Columns and Tables documentation](/docs/core-concepts/system-columns-and-tables).

### Excluding source data

If you don’t want to sync all the data from your Convex database, you can exclude Convex components, tables, and fields from your syncs on your Fivetran dashboard. To do so, go to your Convex connection details page and uncheck the objects you would like to omit from syncing. 

For more information, see our [Data Blocking documentation](/docs/using-fivetran/features/data-blocking-column-hashing).

{% important %}
If you modify your source data inclusion settings after data has already been synced, the existing data will not be modified retroactively. If you need to apply the new settings to the existing data, [trigger a historical re-sync](/docs/connectors/troubleshooting/trigger-historical-re-syncs).
{% /important %}



================================================
FILE: crates/fivetran_source/docs/setup-guide.md
================================================
---
name: Setup Guide
title: Convex connector by Fivetran | Setup Guide
description: Read step-by-step instructions on how to connect your Convex deployment with your destination using Fivetran connectors.
menuPosition: 0
---


# Convex Setup Guide {% badge text="Partner-Built" /%} {% availabilityBadge connector="convex" /%}

Follow the setup guide to connect Convex to Fivetran.

> NOTE: This connector is [partner-built](/docs/partner-built-program). For any questions related to Convex connector and its documentation, contact Convex's support team. For details on SLA, see [Convex's Status and Guarantees documentation](https://docs.convex.dev/production/state).

---

## Prerequisites

To connect your Convex deployment to Fivetran, you need the following:
- A Convex account on the [Professional plan](https://www.convex.dev/plans).
- A Convex deployment. See [Convex's documentation](https://docs.convex.dev/) to get started.
- Your Convex deployment's URL (for example, `https://jaded-raven-991.convex.cloud`).
- Your Convex deployment's deploy key. You can find both the deployment URL and deploy key on the [Production Deployment Settings](https://docs.convex.dev/dashboard/deployments/deployment-settings) page.

---

## Setup instructions

### <span class="step-item">Find your deployment credentials</span>

1. Go to your deployment on the [Convex dashboard](https://dashboard.convex.dev/).
2. Go to the [Production Deployment Settings](https://docs.convex.dev/dashboard/deployments/deployment-settings).
3. Find your deployment URL and deploy key and make a note of them. You will need them to configure Fivetran.

### <span class="step-item">Finish Fivetran configuration</span>

1. In your [connection setup form](/docs/using-fivetran/fivetran-dashboard/connectors#addanewconnection), enter a **Destination schema prefix**. This prefix applies to each replicated schema and cannot be changed once your connection is created.
2. Enter the **Deployment URL** you found.
3. Enter your **Deploy Key** you found.
4. Click **Save & Test**. Fivetran tests and validates our connection to your Convex deployment. Upon successful completion of the setup tests, you can sync your data using Fivetran.

### Setup tests

Fivetran performs the following tests to ensure that we can connect to your Convex deployment.

- Validating that your deployment credentials.
- Ensuring you are on a [Convex Professional plan](https://www.convex.dev/plans).

---

## Related articles

[<i aria-hidden="true" class="material-icons">description</i> Connector Overview](/docs/connectors/databases/convex)

<b> </b>

[<i aria-hidden="true" class="material-icons">account_tree</i> Schema Information](/docs/connectors/databases/convex#schemainformation)

<b> </b>

[<i aria-hidden="true" class="material-icons">home</i> Documentation Home](/docs/getting-started)



================================================
FILE: crates/isolate/README.md
================================================
# JS Runtime Environment

There are a few ways user code can interact with our system.

1. There's a global `Convex` object that's created very early in
   `initialization::setup_context` and populated soon after when executing
   `setup.js`. We pass this global object as the first argument to all UDFs.
2. The `Convex.syscall` method, installed in `initialization::setup_context` and
   implemented within `syscalls.rs` provides the API for the user to interact
   with the database.
3. Helpers within `setup.js` provide bindings, like `Convex.get` for interacting
   with the database without having to use `Convex.syscall` directly.
4. The user can also import system modules under `convex:/system` that will
   eventually include code derived from our npm package. For example, we'll
   eventually have a custom `Int64` object that will be available for the user
   to create themselves within UDF execution.

# Argument and return value serialization (as of 2021-11-10)

```
                             Arguments                     Return value

                       ┌───────────────────┐           ┌───────────────────┐
                       │ Convex Value (JS) │           │ Convex Value (JS) │
                       └───────────────────┘           └───────────────────┘
                                 │                               ▲
                          convexReplacer                         │
                                 │                         convexReviver
 Browser                         ▼                               │
                   ┌──────────────────────────┐    ┌──────────────────────────┐
                   │ JSON-serializable object │    │ JSON-serializable object │
                   └──────────────────────────┘    └──────────────────────────┘
                                 │                               ▲
                          JSON.serialize                         │
                                 │                          JSON.parse
                                 ▼                               │
                          ┌─────────────┐                 ┌─────────────┐
─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   String    ├ ─ ─ ─ ─ ─ ─ ─ ─ ┤   String    ├ ─ ─ ─ ─ ─ ─ ─ ─ ─
                          └─────────────┘                 └─────────────┘
                                 │                               ▲
                        serde::Deserialize                       │
                                 │                       serde::Serialize
                                 ▼                               │
                     ┌──────────────────────┐        ┌──────────────────────┐
 Rust                │ Convex Value (Rust)  │        │ Convex Value (Rust)  │
                     └──────────────────────┘        └──────────────────────┘
                                 │                               ▲
                         serde::Serialize                        │
                                 │                      serde::Deserialize
                                 ▼                               │
                        ┌────────────────┐              ┌────────────────┐
─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤     String     │─ ─ ─ ─ ─ ─ ─ ┤     String     │─ ─ ─ ─ ─ ─ ─ ─ ─
                        └────────────────┘              └────────────────┘
                                 │                               ▲
                            JSON.parse                           │
                                 │                        JSON.serialize
                                 ▼                               │
                   ┌──────────────────────────┐    ┌──────────────────────────┐
                   │ JSON-serializable object │    │ JSON-serializable object │
                   └──────────────────────────┘    └──────────────────────────┘
                                 │                               ▲
                           convexReviver                         │
 V8                              │                        convexReplacer
                                 ▼                               │
                       ┌───────────────────┐           ┌───────────────────┐
                       │ Convex Value (JS) │           │ Convex Value (JS) │
                       └───────────────────┘           └───────────────────┘
                                 │                               ▲
                                 │                               │
                                 │    ┌─────────────────────┐    │
                                 │    │                     │    │
                                 └───▶│    User UDF code    │────┘
                                      │                     │
                                      └─────────────────────┘
```



================================================
FILE: crates/load_generator/README.md
================================================
# LoadGenerator

LoadGenerator is a powerful load testing and benchmarking tool designed to
evaluate Convex's performance under various workloads. It helps measure:

- Function latency and throughput
- Performance under different load patterns
- Overall system stability

The tool works by:

0. Provisioning a Convex instance (or pointing at an existing Convex instance).
1. Sending predefined or custom scenarios to
   [ScenarioRunner](../../npm-packages/scenario-runner/README.md)
2. Collecting performance metrics from the executed scenarios
3. Generating detailed statistics reports with latency metrics
4. Optionally sending metrics to production monitoring systems (e.g., Datadog)

### Architecture

```
  ┌──────────┐
  │  Stats   │
  │  Report  │        ┌────────────────┐           ┌───────────────────┐           ┌───────────────┐
  └──────────┘        │                │           │                   │ queries,  │               │
        ▲             │                │ Scenarios │                   │ mutations │               │
        └─────────┬───│ LoadGenerator  │──────────▶│  ScenarioRunner   │──────────▶│    Backend    │
┌──────────────┐  │   │                │◀──────────│                   │◀──────────│               │
│              │  │   │                │  Events   │                   │           │               │
│   Metrics    │  │   └────────────────┘           └───────────────────┘           └───────────────┘
│  Collector   │◀─┘
│(e.g. Datadog)│
│              │
└──────────────┘
```

## Usage

From the root `convex` directory, run the following for usage instructions:

```shell
cargo run -p load_generator --bin load-generator -- --help
```

See the Justfile for details on running preconfigured workloads automatically.

If you want tracing, make sure to add `RUST_LOG=info` before your run command.

## Instructions for using LoadGenerator to benchmark self-hosted Convex

1. Push scenario-runner functions to your self-hosted Convex backend. Do not run
   this against your production instance! This will replace your functions. Use
   a separate Convex backend set up for testing only.

   ```sh
   cd npm-packages/scenario-runner
   npx convex deploy --admin-key=<your-admin-key> --url=<your-backend-url>
   ```

2. Run LoadGenerator against your self-hosted Convex backend. See the
   `workloads` directory for example workloads. You can specify a rate to run
   each scenario at, in number of requests per second (see
   [workloads/prod.json](workloads/prod.json)), or the number of threads to run
   continuous requests on in benchmark mode (see
   [workloads/benchmark_query.json](workloads/benchmark_query.json)).

   ```sh
   cd ../../crates/load_generator
   just self-hosted crates/load_generator/workloads/<your-workload>.json  --existing-instance-url <your-backend-url> --existing-instance-admin-key <your-admin-key>
   ```

## Writing custom scenarios

You can also write your own Convex functions to run with LoadGenerator by adding
them to the `convex` folder in
[`npm-packages/scenario-runner`](../../npm-packages/scenario-runner/convex/).
Make sure the function name takes no arguments, then drop it in your workload
config as a `RunFunction` scenario, push your functions, and run LoadGenerator
with the path to your new workload config!

```json
{
  "name": "your_new_workload",
  "scenarios": [
    {
      "name": "RunFunction",
      "path": "<your-new-module>:<your-function-name>",
      "fn_type": "mutation", // or "query" or "action"
      "rate": 5 // whatever rate you'd like, or benchmark threads
    }
  ]
}
```



================================================
FILE: crates/log_streaming/README.md
================================================
## Log Streaming

### Concepts

`LogManager`: the main router/aggregation point for logging events.

`LogSource`: a source that creates and buffers logs for the `LogManager` to
query.

`LogSink`: a dynamically-attachable log receiver. Subscribes to `LogManager`.

### Adding a new LogSink

See `sinks/datadog.rs` for an example of a simple sink. The following steps are
necessary:

1. Write the sink implementation which implements `LogSink` in `sinks/`
2. Provide a `start` method that configures your sink and returns a
   `LogSinkClient`. This is how the `LogManager` communicates with your
   `LogSink` and is able to send it events.
3. Create a backend endpoint similar to `/api/datadog_integration` which accepts
   a `post` method to create the integration. This should collect the necessary
   configuration parameters and update the `_log_sinks` table.
4. Add a new `LogSinkType` and `LogSinkConfig` with an associated configuration
   with an associated config which can be stores in the DB model.
5. Update the switch in `LogManager::config_to_log_sink_client` to call `start`
   on your `LogSink` with the necessary configuration params.
6. If configured correctly, now the `LogManager` will forward logs to your sink
   once the sink is configured and subscribed to!



================================================
FILE: crates/pb/README.md
================================================
# Protobuf files

## How to add a new protobuf file

1.  Create a few called <package_name>.proto in protos/
2.  Make sure to use the same "package" pragma as the file name in the body of
    the proto
3.  Specify any message schemas in that proto file.

How to use the resultant protobufs:

This package will automatically generate modules that contain all your message
structs. So given a file called foo.proto with `message Bar`, your crate can
import the generated struuct like so:

    use pb::foo::Bar;



================================================
FILE: crates/simulation/README.md
================================================
```bash
ELLE_DOT_PATH=/tmp/elle.dot RUST_BACKTRACE=1 RUST_LOG=simulation=error cargo test test_elle -- --nocapture; dot -Tsvg /tmp/elle.dot > /tmp/elle.svg
```



================================================
FILE: demo/README.md
================================================
# Convex tutorial

You're just a few minutes away from having a chat app powered by Convex.

Follow the tutorial at
[docs.convex.dev/tutorial](https://docs.convex.dev/tutorial) for instructions.



================================================
FILE: demo/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/README.md
================================================
## About

npm-packages contains the cli, demos, tutorials, tests, scripts and more. We use
Rush for package management, so don't run `npm install` in these directories.
See the main convex/README.md file for details.

## Adding a new convex package

To add a new package that uses convex, follow these steps instead of our
quickstart:

1. Create a new subdirectory
2. Copy the contents of the npm-packages/tutorial into the subdirectory
3. Update `"name"` in your new `package.json` file to match your subdirectory
   name
4. Add your new package to
   [rush](https://github.com/get-convex/convex/blob/main/npm-packages/rush.json#L296)
5. Run `just rush update` to install dependencies

## Running a convex package

You can run projects against either a local backend, or against prod.

If your project requires changes that have not yet been deployed, you'll need to
test against a local backend.

To use a local backend:

1. Run `just run-local-backend`
2. In a separate terminal window, run `just convex dev`

To use a local big-brain (runs both backend and big brain locally):

1. Run `just run-big-brain`
2. Copy the `Test with:` line output by big-brain:

`2023-07-12T19:07:07.422400Z INFO big_brain::model: Test with: CONVEX_PROVISION_HOST=http://0.0.0.0:8050 npx convex dev --override-auth-url "https://cheerful-lake-55-staging.authkit.app/" " --override-auth-client "XXXXXXXXX"`

3. Paste it into another terminal that's in your convex directory.

To run against prod:

Just run `npx convex dev`



================================================
FILE: npm-packages/AGENTS.md
================================================
# TypeScript monorepo

## Development workflow

When doing changes in `/npm-packages/<package>`:

```sh
# After each modification
just format-js

# When the change is ready
just lint-js
just rush build -t <package>

# To run a specific test file
cd npm-packages/<package>/
npm run test -- <file>
```

## Dependencies management

This project uses Rush to manage dependencies.

After modifying the dependencies of a package, run `just rush update`.

## Code organization

- **Client**: the JavaScript/React libraries for Convex,
  `npm-packages/convex/src/`
- **CLI**: the command-line tool for Convex users (`npx convex`),
  `npm-packages/convex/src/cli/`
- **Dashboard**: the web user interface for Convex users
  - `npm-packages/dashboard/` for the Convex Cloud dashboard
    (https://dashboard.convex.dev/)
  - `npm-packages/dashboard-self-hosted/` for the self-hosted build of the
    dashboard
  - `npm-packages/dashboard-common/` for code that’s common to both dashboard
    versions
  - `npm-packages/@convex-dev/design-system/` for UI elements
  - `npm-packages/system-udfs/` for Convex functions the dashboard/CLI can call
    on deployments
- **Docs**: public docs at https://docs.convex.dev/, `npm-packages/docs/`



================================================
FILE: npm-packages/dep-upgrade-notes.md
================================================
# npm dependency notes

Rush pushes us toward using a single a version of each dependency in the
monorepo. Our version choices are compromises between the competing needs of

- staying up to date enough to cutting edge to be able to pull in security
  updates
- staying up to date because we like nice things
- shipping very compatible client code
- using old AND new versions in demos and tests that are representative of
  customer use cases.

We can use multiple versions by adding the less common one to
allowedAlternativeVersions in
npm-packages/common/config/rush/common-versions.json

# Rush

We don't really need Rush, we mostly use features of pnpm. We could replace Rush
with Turborepo if we wanted to.

See rush.json for notes on what version we use.

# node version

Node.js 20 is the expected version for the whole repo. We no longer run
integration tests with Node.js 18.

We're rolling out configurable Node.js versions for Lambda functions ("use
node") and function runner / local backend now expect Node.js 18, 20, or 22.

# JS build systems

npm-packages/convex is built with custom esbuild + tsc scripts. zshy looks
great, we've just moved a few simple packages over but we may be able to use it
for npm-packages/convex.

# Dependencies that are hard to upgrade

Run `just rush update --full` to upgrade withing semver specs. If this doesn't
work we need to narrow our semver requirement spec for that library.

Run `just rush upgrade-interactive` to upgrade libraries beyond their current
semver spec. See notes below for these libraries.

### react and react-dom

We may need to support React 17 for a long time because React 18 includes
significant implementation changes.

We can upgrade to 18, but we should create a test project that uses 17.

React 19 has been released. For types, keep using React 18 to ensure our code is
compatible. Clerk does something like this.

### TypeScript

We should be more aggressive here. Currently we require 5.0.3 as a minimum. We
can go up from here.

### jwt-decode

This is a unbundled dep, we had issues when we upgraded.
https://github.com/get-convex/convex/pull/30674

### Chalk

We want to stay on version 4 of chalk forever (well until ship the CLI as CJS,
version 5 is an esm-only build but we want to need to bundle CJS into our CLI.

### openid-client

It's a rewrite, will need to test carefully.

### Inquirer

Just haven't gotten to it, breaking changes are probably simple

### Commander

dunno

### Vitest 1->2

Big changes

### esbuild

macOS 10.15 Catalina no longer supported in esbuild@0.24.0, maybe we care

### typedoc

A bit of custom work to do, we have patched versions of some libraries in docs
that depend on this. Maybe this means we can get rid of them!

### sentry/node 8

esm something or other

### abortcontroller-polyfill

1.7.7
(https://github.com/mo/abortcontroller-polyfill/commit/575383ecb91a0f77a571b59e9c4e223832f032d9
maybe?) breaks something



================================================
FILE: npm-packages/@convex-dev/codemod/README.md
================================================
# @convex-dev/codemod

Automatic codemods to help you migrate your codebase to newer versions of
Convex.

## Usage

```bash
npx @convex-dev/codemod <transform>
```

Run `npx @convex-dev/codemod --help` for more options.



================================================
FILE: npm-packages/@convex-dev/codemod/test/explicit-ids/sample-convex-project/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/@convex-dev/design-system/README.md
================================================
# Convex Design System

The Convex Design System is a collection of components that are used to build
Convex UIs (dashboard, Chef, etc).



================================================
FILE: npm-packages/@convex-dev/design-system/pages/README.md
================================================
don't delete this directory for now. it's needed for eslint to work.



================================================
FILE: npm-packages/@convex-dev/eslint-plugin/README.md
================================================
# @convex-dev/eslint-plugin

ESLint plugin for Convex to prevent common issues and enforce best practices for
files in the `convex/` directory.

# Setup

See [docs.convex.dev/eslint](https://docs.convex.dev/eslint).

# Contributing notes

Currently there is no `@convex-dev/eslint-config` package, but we could add one
for ESLint 8 users to make configuration slightly easier: they could use

```js
module.exports = { extends: ["@convex-dev"] };
```

and some TypeScript parser configuration could occur here.

Adding a eslint-config package only matters for ESLint 8, in ESLint 9 there's no
need for a separate package.



================================================
FILE: npm-packages/@convex-dev/eslint-plugin/CHANGELOG.md
================================================
# Changelog

### unreleased

### 0.0.0-alpha.0



================================================
FILE: npm-packages/@convex-dev/platform/README.md
================================================
# Convex management APIs

A client wrapping the management APIs available at

https://provision.convex.dev/v1/openapi.json

as well as the deployment APIs available on every Convex backend.

This wrapper is used for integration tests and examples.

It is not currently published to npm.

## Updating the API spec

### Management API specs (big_brain)

Run `cargo test -p big_brain test_api_specs_match` to rebuild the management API
specs, `cargo test -p local_backend test_api_specs_match` to rebuild the
deployment API specs, and `npm run generateApiSpec` to rebuild the clients.

This updates:

- `management-openapi.json` - Platform management API
- `dashboard-management-openapi.json` - Dashboard management API

### Deployment API specs (local_backend)

Run `cargo test -p local_backend test_api_specs_match` to rebuild the deployment
API specs.

This updates:

- `deployment-openapi.json` - Public deployment API (queries, mutations,
  actions)
- `dashboard-deployment-openapi.json` - Dashboard deployment API (admin
  operations)



================================================
FILE: npm-packages/@convex-dev/react-query/README.md
================================================
# @convex-dev/react-query

Instead of polling you subscribe to receive update from server-side query
functions in a Convex deployment. Convex is a database with server-side
(db-side? like stored procedures) functions that update reactively.

New results for all relevant subscriptions are pushed to the client where they
update at the same time so data is never stale and there's no need to call
`queryClient.invalidateQueries()`.

## Setup

See [./src/example.tsx](./src/example.tsx) for a real example. The general
pattern:

1. Create a ConvexClient and ConvexQueryClient. Set the global default
   `queryKeyHashFn` to `convexQueryClient.hashFn()` and `queryFn` to
   `convexQueryClient.queryFn()`. Connect the ConvexQueryClient to the React
   Query QueryClient.

```ts
const convexClient = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL);
const convexQueryClient = new ConvexQueryClient(convexClient);
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryKeyHashFn: convexQueryClient.hashFn(),
      queryFn: convexQueryClient.queryFn(),
    },
  },
});
convexQueryClient.connect(queryClient);
```

2. Use `useQuery()` with the `convexQuery` options factory function called with
   an `api` object imported from `../convex/_generated/server` and the arguments
   for this query function. These two form the query key.

```ts
const { isPending, error, data } = useQuery({
  ...convexQuery(api.repos.get, { repo: "made/up" }),
  gcTime: 10000, // unsubscribe after 10s of no use
});
```

`staleTime` is set to `Infinity` beacuse this data is never stale; it's
proactively updated whenever the query result updates on the server. (see
[tkdodo's post](https://tkdodo.eu/blog/using-web-sockets-with-react-query#increasing-staletime)
for more about this) If you like, customize the `gcTime` to the length of time a
query subscription should remain active after all `useQuery()` hooks using it
have unmounted.

If you need to use a Convex Action as a query, it won't be reactive; you'll get
all the normal tools from React Query to refetch it.

# Differences from using TanStack Query with `fetch`

New query results are pushed from the server, so a `staleTime` of `Infinity`
should be used.

Your app will remain subscribed to a query until the `gcTime` has elapsed. Tune
this for your app: it's usually a good tradeoff to use a value of at least a
couple seconds.

# Example

To run this example:

- `npm install`
- `npm run dev`

# Mutations and Actions

If you wrap your app in a `ConvexProvider` you'll be able to use convex hooks
like `useConvexMutation` and `useConvexAction`.:

```tsx
<ConvexProvider client={convex}>
  <QueryClientProvider client={queryClient}>
    <App />
  </QueryClientProvider>
</ConvexProvider>
```

You can use this mutation function directly or wrap it in a TanStack Query
`useMutation`:

```ts
const mutationFn = useConvexMutation(api.board.createColumn);
const { mutate } = useMutation({ mutationFn });
```

```ts
const { mutate } = useMutation({
  mutationFn: useConvexAction(api.time.getTotal),
});
```

# Authentication

**Note:** The example app includes a basic Convex Auth implementation for
reference.

TanStack Query isn't opionated about auth; an auth code might be a an element of
a query key like any other. With Convex it's not necessary to add an additional
key for an auth code; auth is an implicit argument to all Convex queries and
these queries will be retried when authentication info changes.

Convex auth is typically done via JWT: some query functions will fail if
requested before calling `convexReactClinet.setAuth()` with a function that
provides the token.

Auth setup looks just like it's recommended in
[Convex docs](https://docs.convex.dev/auth), which make use of components that
use native convex hooks. For Clerk, this might look like this: a `ClerkProvider`
for auth, a `ConvexProviderWithClerk` for the convex client, and a
`QueryClient`.

```
<ClerkProvider publishableKey="pk_test_...">
  <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </ConvexProviderWithClerk>
</ClerkProvider>
```

See the [Convex Auth docs](https://docs.convex.dev/auth) for setup instructions.

# TODO

- auth
- paginated queries
- cleanup / unsubscribe in useEffect; something with hot reloading may not be
  working right

# Contributing

After cloning this repo run `npm i` to install dependencies. This package uses
[tshy](https://github.com/isaacs/tshy) to publish an ESM. If there's ever demand
for a CJS build we can add "cjs" to the "dialects" section of "tshy" config in
the package.json.

To publish an alpha release, update the version in package.json to something
like `0.0.0-alpha.1` and run `just rush-pnpm publish --tag alpha`.

To publish a regular release, update the version in package.json to something
like `0.1.2` and run `just rush-pnpm publish`.



================================================
FILE: npm-packages/@convex-dev/react-query/CHANGELOG.md
================================================
# Changelog

### 0.0.0-alpha.4

Fix type inference for initialData when it is a wider type like `[]`.



================================================
FILE: npm-packages/@convex-dev/react-query/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/@convex-dev/workos/README.md
================================================
[Empty file]


================================================
FILE: npm-packages/component-tests/README.md
================================================
# component-tests

This directory is used for application-level component tests.

The application-level component tests go through the push codepath to analyze,
upload modules, and set up the component model in system tables in the database.

These tests simulate a push by reading from pre-written `StartPushRequest`s from
the `isolate/build.rs` script, which runs
`npx convex deploy --start-push-request` for convex projects in the `projects`
directory in this directory.

## Adding new convex projects to test component layouts

To test a new component layout,

1. Add a project to the `projects` directory. The project should have a `convex`
   folder inside and `convex.config.ts` (If your test does not use components,
   use `udf-tests`).
2. Add the project to `COMPONENT_TESTS_PROJECTS` in `isolate/build.rs.
3. Add the project to `rush.json`.
4. Run `just rush update`.
5. Write your tests in `application/src/tests/components.rs`.

## Adding new components

To test a new component, add the component to this directory (`component-tests`)
and `COMPONENTS` in `isolate/build.rs`. Use it in a project in the `projects`
directory by installing it in the project's `convex.config.ts`.



================================================
FILE: npm-packages/component-tests/projects/basic/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/component-tests/projects/empty/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/component-tests/projects/http_actions/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/component-tests/projects/mounted/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/component-tests/projects/schema_with_index/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/component-tests/projects/with-schema/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/components/README.md
================================================
These libraries are components, primarly published on npm at
@convex-dev/componentName.



================================================
FILE: npm-packages/components/ratelimiter/README.md
================================================
# Testing component

This package exists to test components when a different copy of convex is
installed, so uses `"injected": true` for the convex dependency.

This is no longer the canonical Convex component. See
https://github.com/get-convex/ratelimiter-component for the actual rate limter
components or
https://github.com/get-convex/templates/tree/main/template-component for the
template that powers

```
npx create-convex@latest --component
```

# Structure of a Convex Component

Components are expected to expose the entry point convex.config.js. The on-disk
location of this file must be a directory containing implementation files. These
files should be compiled to ESM, not CommonJS.

The package.json should contain `"type": "module"` and the tsconfig.json should
contain `"moduleResolution": "Bundler"` or Node16 in order to import other
component definitions.

In addition to convex.config.js, a component may expose other exports.

A client that wraps communication with the component for use in the Convex
environment is typically exposed as a named export `MyComponentClient` or
`MyComponent` imported from the root package.

```
import { MyComponentClient } from "my-convex-component";
```

Frontend code is typically published at a subpath:

```
import { FrontendReactComponent } from "my-convex-component/react";
```

Frontend code should be compiled as CommonJS code as well as ESM and make use of
subpackage stubs (see next section).

If you do include frontend components, prefer peer dependencies to avoid using
more than one version of e.g. React.

### Support for Node10 module resolution

The [Metro](https://reactnative.dev/docs/metro) bundler for React Native
requires setting
[`resolver.unstable_enablePackageExports`](https://metrobundler.dev/docs/package-exports/)
in order to import code that lives in `dist/esm/frontend.js` from a path like
`my-convex-component/frontend`.

Authors of Convex component that provide frontend components are encouraged to
support these legacy "Node10-style" module resolution algorithms by generating
stub directories with special pre- and post-pack scripts.



================================================
FILE: npm-packages/components/triggers/README.md
================================================
# Triggers

This is a component built for build-on-components-day.

## What can you trigger

Run code whenever a table changes.

Example usages:

- Attach a custom index to a table, like a geospatial index or a BTree with
  aggregates.
- Log whenever the table changes.
- Detect unauthorized access with Row Level Security and throw an error.

## How to use

Copy installation pattern from `convex/triggers.ts`.

Copy usage pattern from `convex/messages.ts`.

Each triggered function runs within the same mutation, immediately after the
document write. If you want async triggers, you can use
`ctx.scheduler.runAfter(0, ...);`

All of your functions that modify the table must be wrapped in
`mutationWithTriggers` instead of `mutation`, in order to trigger the triggers.
Triggers do not run when the table changes through a plain `mutation` or through
the Convex Dashboard.

Triggers are called with arguments matching `triggerArgsValidator`, so you know
whether it was an insert, patch, replace, or delete. You are also given the
document ID and the full document contents before and after the write.

The usage of components allows the `oldDoc` and `newDoc` to be computed
atomically, unlike the `DatabaseWriter` wrapper from the Row Level Security
helpers.



================================================
FILE: npm-packages/convex/README.md
================================================
# Convex

TypeScript backend SDK, client libraries, and CLI for Convex.

Convex is the backend application platform with everything you need to build
your product.

Get started at [docs.convex.dev](https://docs.convex.dev)!

Or see [Convex demos](https://github.com/get-convex/convex-demos).

Open discussions and issues in this repository about Convex
TypeScript/JavaScript clients, the Convex CLI, or the Convex platform in
general.

Also feel free to share feature requests, product feedback, or general questions
in the [Convex Discord Community](https://convex.dev/community).

# Structure

This package includes several entry points for building apps on Convex:

- [`convex/server`](https://docs.convex.dev/api/modules/server): SDK for
  defining a Convex backend functions, defining a database schema, etc.
- [`convex/react`](https://docs.convex.dev/api/modules/react): Hooks and a
  `ConvexReactClient` for integrating Convex into React applications.
- [`convex/browser`](https://docs.convex.dev/api/modules/browser): A
  `ConvexHttpClient` for using Convex in other browser environments.
- [`convex/values`](https://docs.convex.dev/api/modules/values): Utilities for
  working with values stored in Convex.
- [`convex/react-auth0`](https://docs.convex.dev/api/modules/react_auth0): A
  React component for authenticating users with Auth0.
- [`convex/react-clerk`](https://docs.convex.dev/api/modules/react_clerk): A
  React component for authenticating users with Clerk.
- [`convex/nextjs`](https://docs.convex.dev/api/modules/nextjs): Server-side
  helpers for SSR, usable by Next.js and other React frameworks.

This package also includes [`convex`](https://docs.convex.dev/using/cli), the
command-line interface for managing Convex projects.



================================================
FILE: npm-packages/convex/CHANGELOG.md
================================================
# Changelog

## 1.31.6

- Added a new [`authKit`](https://docs.convex.dev/production/project-configuration#configuring-workos-authkit-integration) field in `convex.json` that allows you to customize the automatic provisioning and configuration of WorkOS environments.
- The CLI now warns you when using a Node.js version older than Node.js 20.
- Improved error messages when requests fail in the MCP server.
- Improved the error message when creating a component with an invalid name.

## 1.31.5

- Exclude source code content from bundled sourcemaps by default. This reduces the
  size of the bundled pushed by `npx convex dev` and `npx convex deploy` to make
  them run faster.
- This version drops support for Node.js 18. Please update to Node.js 20 or newer.

## 1.31.4

- Fix [`window.addEventListener is not a function`](https://github.com/get-convex/convex-backend/issues/304) bug in React Native.

## 1.31.3

- `CONVEX_AGENT_MODE=anonymous` can now be used while logged in.

- The client will try to reconnect immediately after being offline instead of
  waiting for the scheduled backoff delay.

- Optimize bundling during code push, and add `includeSourcesContent` option in
  `convex.json` to configure whether to include source code content in bundled
  sourcemaps.

## 1.31.2

- Bug fix: the TypeScript types of the new `ctx.db` APIs introduced in 1.31.0
  incorrectly allowed passing IDs with types broader than the table name
  argument (e.g. `db.get("table1", id)` where `id` is
  `Id<"table1"> | Id<"table2">`). This issue is fixed in 1.31.2.

## 1.31.1

- You can now increase the speed of type checking when using `npx convex dev` by
  enabling the
  [TypeScript native preview](https://devblogs.microsoft.com/typescript/announcing-typescript-native-previews/)
  ([TypeScript 7](https://devblogs.microsoft.com/typescript/typescript-native-port/)).
  To do so, add `@typescript/native-preview` as a dev dependency and
  [set `typescriptCompiler: "tsGo"` in `convex.json`](https://docs.convex.dev/production/project-configuration#configuring-the-typescript-compiler).

## 1.31.0

- `db.get`, `db.patch`, `db.replace`, and `db.delete` now accept a table name as
  the first argument (e.g. `db.get("messages", messageId)` instead of
  `db.get(messageId)`). This new syntax is more ergonomic, safer, and will allow
  developers to customize IDs in the future. We recommend that all developers
  migrate to the new syntax, using the ESLint rule
  [`@convex-dev/explicit-table-ids`](https://docs.convex.dev/eslint#explicit-table-ids)
  or our standalone codemod tool
  (`npx @convex-dev/codemod@latest explicit-ids`).
  [**Learn more on news.convex.dev**](https://news.convex.dev/db-table-name/)

## 1.30.0

- The `--preview-create` parameter for `npx convex deploy` will now error if
  used with a deploy key that is not a preview deploy key. Previously, the flag
  would be ignored in this situation, and `npx convex deploy` would deploy to
  the production deployment. If you were depending on this behavior, make sure
  to remove the `--preview-create` flag when deploying to production.

## 1.29.3

- Revert ApiFromModules type changes introduced in 1.29.0 which sometimes caused
  type mismatches due to `FunctionReference` sometimes missing properties.

- Don't warn when `"$schema"` is present in convex.json.

- Replace ProxyAgent with EnvHttpProxyAgent in the CLI so the `NO_PROXY`
  environment variable is respected.

## 1.29.2

- When running `npx convex deploy`, the CLI will now ask for explicit
  confirmation before deleting large indexes. This change is helpful for
  avoiding situations where an index is accidentally deleted and backfilling it
  takes a long time.

## 1.29.1

- Support for special error and no-op values of `CONVEX_DEPLOY_KEY` environment
  variable used by the Convex Vercel integration.

## 1.29.0

- Code generation changes: modules and functions are sorted in more situations,
  some unused imports have been removed, and some docstrings have been updated.
  Expect to need to commit a larger-than-usual change to generated files after
  upgrading to this version of Convex.

- Add .pick(), .omit(), .partial(), and .extend() methods to v.objects()
  validators. This makes reusing validator with small changes simpler. See
  https://docs.convex.dev/functions/validation#reusing-and-extending-validators
  for more.

- Add a pagination result validation helper
  `paginationResultValidator(itemValidator)` describing and validating the
  return value of a paginated query.

- New `npx convex codegen --component-dir ../path/to/component` flag for
  component authors to generate code only for a component.

- New `convex.json` configuration property `codegen.fileType` (`"dts/js"` or
  `"ts"`, default `"dts/js"`) Default for applications is still "dts/js" but for
  components generated files always use "ts" file extensions.

- New `convex.json` configuration property `codegen.legacyComponentApi` (default
  true) which can be set to false to opt into importing the API of a component
  directly from its package or directory instead of inlining the result of
  analyzing a component in parent component that uses it.

- Improved TypeScript inference performance for `ApiFromModules`, the workhorse
  type that transforms modules of Convex functions into a tree of
  `FunctionReference` types for the `api` object. Thanks to David Blass, the
  maintainer of ArkType, for working with us on these improvements.

## 1.28.2

- Bundling fix: don't double-deploy components in the convex/ directory.

## 1.28.1

- Add json schema to package.json.

## 1.28.0

- Deploy code path unification: all deploys now use a codepath that supports
  components, whether or not any components are used in the project. Generating
  the files in `convex/_generated/` now requires a deployment to be present and
  for all environment variables used in convex/auth.config.ts to be set.

  Scripts that call `npx convex codegen` are the most likely to be affected by
  this change, and `npx convex codgen` no longer works for any projects in
  preview deployments because preview deployments may not exist until the
  deploy.

  Committing generated code is recommended and this change makes this
  recommendation more important.

- WebSocket sync protocol support for TransitionChunk messages: just splitting a
  Transition (containing new query results) into multiple WebSocket messages in
  order prevent the server from appearing non-responsive.

## 1.27.5

- Export an `AuthConfig` type to describe the object exported from
  `convex/auth.config.ts`.

## 1.27.4

- Add a `getAuth()` method to the client which returns the current token and
  claims. This method is intended for instrumentation purposes like adding this
  information to a reported Sentry error or event.

- Change to CLI `--admin-key` and `--url` arg parsing logic to avoid coercing
  empty strings to booleans.

- Vendor jwt-decode along with a few other dependnecies; this brings the number
  of runtime dependencies for Convex from 3 to 2: esbuild (binary) and prettier.

- Fix ConvexProviderWithClerk to catch `getToken()` errors. This could cause
  changes in behavior of refreshing Clerk tokens, we'll be watching this one.

## 1.27.3

- Convex CLI now respects `HTTPS_PROXY` / `HTTP_PROXY` environment variables.
  This is generally useful but was motivated by making Convex run in remote
  asynchronous agent environemnts like Codex.
- Cutoffs for logging large and slow Transition messages have been lowered.

## 1.27.2

- `npx convex run` sends function log output to stderr instead of stdout.

- Increase the timeout when waiting for a local backend to start up from 10 to
  30 seconds.

- Capability to provision WorkOS environments when `WORKOS_CLIENT_ID`
  environment variable is missing.

## 1.27.1

- Changes to logged messages in the console, where previously only WebSocket
  reconnection messages were logged. These can still be silenced with the
  `logger: false` client option.
- Improved support for the TypeScript tsconfig.json compiler option
  "exactOptionalPropertTypes" with the convex package.
- Additional WebSocket connection debugging information about Transition
  messages.
- Clearer error messages when running codegen in preview deployments.
- Token limits for especially verbose logs MCP tool.
- Add (preexisting) `codegen` options to `convex.json` schema.

## 1.27.0

- Add support for configuring the Node.js version used by Node actions using the
  `node.nodeVersion` field of the `convex.json` file
  ([docs](https://docs.convex.dev/production/project-configuration#configuring-the-nodejs-version)).
- `npx convex data` now supports exporting data as JSON or JSONL with the
  `--format` option.
- `npx convex env set` now supports setting environment variables via piping
  (STDIN) (for example
  `cat keys/my-private-key.txt | npx convex env set JWT_PRIVATE_KEY`).

## 1.26.2

- Fix for pushing schemas to older (self-hosted) deployment builds.

## 1.26.0

- Add support for staged indexes. Instead of blocking on push, a staged index
  backfills while you push more changes to a deployment, then can be used once
  it is no longer marked as staged.

  ```
  export default defineSchema({
    messages: defineTable({
      author: v.string(),
      body: v.string(),
    })
      .index("by_author", {
        fields: ["author"],
         // watch for progress in dashboard. Once it's at 100%, remove the staged flag
        staged: true,
      })
  });
  ```

  Read more in the docs (link coming soon).

- Experimental `ConvexReactClient.prewarmQuery({query, args})` method for
  subscribing to a query for 5 seconds. Prewarming indicates likely future
  interest in a subscription and is currently implemented by subscribing to the
  query for 5 seconds.

  The return value of this method may change and the arguments may change in the
  future so this API should be considered unstable but adapting to these changes
  shouldn't be difficult.

- Expose the schemaValidation property of schema, intended for runtime tests or
  assertions that it is indeed enabled.

- Export TokenFetcher type, intended for external auth integrations.

- More informative messaging on code push. Link to index backfill progress in
  the dashboard.

- Fix a bug where an auth token passed initially to the ConvexHttpClient was
  ignored.

- Experimental `expectAuth` option for Convex clients for indicating that
  setAuth() will be called soon, so to wait for that token. Once setAuth() has
  been called the existing token-waiting behavior takes over.

  This is useful for applications that create a client and run a mutation,
  query, or action _before_ setAuth() has been called, e.g. via a provider in
  React.

- Change the default permissions for the local MCP server: access to production
  deployments is now disabled by default, requiring
  `--dangerously-enable-production-deployments` to enable.

- Add a "logs" tool to the local MCP server.

## 1.25.4

- Experimental `convex dev --once --debug-node-apis` debug flag for tracing
  through imports to find Node.js APIs imported from non-"use node" convex
  endpoint files.

- Experimental `CONVEX_AGENT_MODE=anonymous npx convex dev` for a
  non-interactive anonymous development flow when not logged in.

- Simplify the `Logger` interface of Convex clients making it easier to replace.

- Reactive `ConnectionState` via `useConvexConnectionState` hook. How often this
  value updates may change in the future if more information is added to
  `ConnectionState`.

- Escape JavaScript keywords in codegen, fixing issues with files in the convex
  folder named things like convex/delete.ts.

- Warn when the explicit value `undefined` is passed to Next.js server-side
  helpers, indicating the issue may have been an unset environment variable.
  This may become an error in the future.

- Error closer to the call site when invalid validators are contructed.

## 1.25.2

- Increase a network timeout that was causing Node.js v20+ issues on slow
  connections, good old Happy Eyeballs
  https://github.com/nodejs/node/issues/54359.

## 1.25.1

- Print more error info in `npx convex network-test`.

- Crash when it looks like an environment variable is missing:
  `CONVEX_DEPLOY_KEY=project:me:new-project|eyABCD0= npx convex` parses as
  `CONVEX_DEPLOY_KEY=project:me:new-project | eyABCD0='' npx convex` but when
  was meant was
  `CONVEX_DEPLOY_KEY='project:me:new-project|eyABCD0=' npx convex`.

  Crash when an environment variable like `ey...0=` is present to surface errors
  like this quicker.

## 1.25.0

To upgrade to this release you'll need to upgrade any Convex components you use.

- Set `process.env.NODE_ENV = "production"` during Convex function bundling.
  This will result in different code being bundled from some packages, generally
  faster code.

- Smaller bundles via esbuild minification.

- ConvexHttpClient mutations are now queued by default, making the
  ConvexHttpClient match the behavior of ConvexClient and ConvexReactClient.
  This makes switching between these safer.

  If you need unqueued mutations (you need to run multiple mutations
  concurrently), pass the unqueued: true option or create a separate
  ConvexHttpClient for each queue of mutations you need.

- Allow passing auth to ConvexHttpClient as an option in the constructor. This
  is appropriate for short-lived ConvexHttpClients and it more convenient for
  instantiating a client and using it in a single expression.

- Restore check that Convex functions are not imported in the browser.

  Convex functions run in a Convex deployment; including their source in a
  frontend bundle is never necessary and can unintentionally reveal
  implementation details (and even hardcoded secrets).

  This check current causes a `console.warn()` warning, but in future versions
  this will become an error. If you see the warning "Convex functions should not
  be imported in the browser" you should address this by investigating where
  this is being logged from; that's code you don't want in your frontend bundle.
  If you really want your Convex functions in the browser it's possible to
  disable this warning but this is not recommended.

- TypeScript error when async callbacks are passed to
  `mutation.withOptimisticUpdate()`: an optimistic update function is expected
  to run synchronously.

- Experimental onServerDisconnectError() callback option for Convex clients.

  This is a stopgap client callback to report unusual server disconnect errors.
  The content of these messages, which messages trigger the callback, and the
  existence of the callback are all subject to change as we develop better
  interfaces for disconnect metrics.

## 1.24.8

- Restore short retry timer for WebSocket reconnects initiated by an error on
  the client. This behavior was inadvertently changed in 1.24.7.

## 1.24.7

- Increase WebSocket client timeouts in general and especially for abnormal
  server errors. See
  [this incident postmortem](https://news.convex.dev/how-convex-took-down-t3-chat-june-1-2025-postmortem/)
  for more context.

## 1.24.6

- Fix another bug with new Custom JWT auth support in projects that use Convex
  backend components.

## 1.24.5

- `ConvexClient.mutation()` now accepts a third `options` argument that can
  contain an optimistic update.

## 1.24.3

- Add `.url` property to ConvexReactClient.

- Earlier errors when invalid objects are passed to `defineTable()`.

## 1.24.2

- Fix bug with new Custom JWT auth support in projects that use Convex backend
  components.

- Support larger data imports from the command line by choosing larger chunk
  size when necessary.

- Calling setAuth on a disabled ConvexClient is now an no-op.

- Add `npx convex dash` alias for dashboard command.

- Limit the number of nested query operators to 256.

## 1.24.1

- Accept `true` and `false` as values for logger in all clients, making
  disabling logs from convex functions run on a development deployment simpler:
  it's no longer necessary write your own no-op logger.

## 1.24.0

- Drop support for React 17 and remove use of `unstable_batchedUpdates` as React
  18 introduced
  [Automatic batching](https://react.dev/blog/2022/03/29/react-v18#new-feature-automatic-batching)

  If you use React 17 and choose to override the change in supported peer
  dependencies (please don't), you may notice query updates are no longer
  batched: it's possible for one Convex query update to occur on a different
  React render than another causing single frames of discrepancies in UI or
  worse, errors if you have code that relies on the client-side consistency like
  client-side joins.

  You may also notice nothing. Without batched updates some queries may be a few
  milliseconds ahead of other queries, which is still much less than the
  differences in other data fetching solutions, e.g. React Query or SWR, in
  non-batched mode.

- Remove dependency on `react-dom`, making it possible to use on "React Native
  only" projects without overriding any dependency resolution.

- New optimistic update helpers for paginated queries: three helpers
  `insertAtTop`, `insertAtBottomIfLoaded`, and `insertAtPosition`.

- The `npx convex login --login-flow paste` flag can be used to explicitly opt
  into the manual token paste login method.

- Fix MCP servers for self-hosted deployments: previously MCP CLI commands were
  attempting to contact a cloud deployment (which didn't exist) in self-hosted
  setups.

- New `compareValues` function exported from `convex/values` which matches
  Convex values semantics as implemented in backends. This function should match
  the Rust implementation in backend (and it property-tested in pursuit of
  this!) but in the event of discrepancies the Rust implementation should be
  considered authoritative.

## 1.23.0

- `npx convex dev` now supports the option of running Convex locally without an
  account

## 1.22.0

- Options for turning off MCP tools and blocking prod deployments (see
  `npx convex mcp`)
- Add `--run-sh` option to `npx convex dev`, similar to `--run` but for shell
  commands
- Add `inflightMutations` and `inflightActions` to
  `convexClient.connectionState()`

## 1.21.0

- `npx convex dev` tails logs by default. See the `--tail-logs` option for more.

- Improvement to the `.unique()` error message to print `_id`s
  [PR](https://github.com/get-convex/convex-backend/pull/59)

- Fixes to avoid race conditions in auth
  [PR](https://github.com/get-convex/convex-js/pull/29)

## 1.20.0

- Calling registered functions directly like helper functions no longer
  typechecks. See release notes for 1.18.0 for more.

- Upgrade esbuild for a sourcemap bug fix.

- Fix FieldTypeFromFieldPath to handle union of nested values and primitives.

## 1.19.5

- `npx convex mcp start` runs an MCP server. AI agents can introspect deployment
  schema (both declared and inferred) and function APIs, read data from tables,
  call functions,and write oneoff queries in JS.

## 1.19.3

- Upgrade esbuild from 0.23 to 0.25 to address security warnings about
  https://github.com/evanw/esbuild/security/advisories/GHSA-67mh-4wv8-2f99

  Convex does not use the development server functionality of esbuild which
  contains the vulnerability.

## 1.19.2

- Improved support for working with self-hosted deployments: every command that
  makes sense (e.g. not `npx convex login`) works with self-hosted deployments.

  The environment variables `CONVEX_SELF_HOSTED_URL` and
  `CONVEX_SELF_HOSTED_ADMIN_KEY` are now used to identity self-hosted
  deployments.
  https://github.com/get-convex/convex-backend/tree/main/self-hosted#self-hosting-convex
  for more.

- export the `ValidatorJSON` record types.

## 1.19.0

- Support for Local Deployments, now in beta. See
  https://docs.convex.dev/cli/local-deployments for more.

  Local deployments run your Convex dev deployment for your project on your
  local machine, which should make syncing your code faster. It also makes
  resources used during development like function calls and database bandwidth
  free, since it's your own compute resources you're using!

## 1.18.0

- Warn on direct Convex function call. This adds a console.warn whenever a
  Convex Function (mutation, query, action, internalMutation, etc.) is called
  directly

  ```ts
  export const foo = mutation(...);

  export const bar = mutation({
    args: v.any(),
    returns: v.any(),
    handler: (ctx, args) => {
      const result = await foo();
    })
  }
  ```

  because this pattern causes problems and there are straightforward
  workarounds. The problems here:
  1. Arguments and return values aren't validated despite the presence of
     validators at the function definition site.
  2. Functions called this way unexpectedly lack isolation and atomicity. Convex
     functions may be writting assuming they will run as independent
     transactions, but running these function directly breaks that assumption.
  3. Running Convex functions defined by customFunctions like triggers can cause
     deadlocks and other bad behavior.

  There are two options for how to modify your code to address the warning:
  1. Refactor it out as a helper function, then call that helper function
     directly.
  2. Use `ctx.runMutation`, `ctx.runQuery`, or `ctx.runAction()` instead of
     calling the function directly. This has more overhead (it's slower) but you
     gain isolation and atomicity because it runs as a subtransaction.

  See
  https://docs.convex.dev/understanding/best-practices/#use-helper-functions-to-write-shared-code
  for more.

  Filter to warnings in the convex dashboard logs to see if you're using this
  pattern.

  For now running functions this way only logs a warning, but this pattern is
  now deprecated and may be deleted in a future version.

- Support for Next.js 15 and
  [Clerk core 2](https://clerk.com/docs/upgrade-guides/core-2/overview):
  `@clerk/nextjs@5` and `@clerk/nextjs@6` are now known to work to Convex. Docs,
  quickstarts and templates have not yet been updated. If you're upgrading
  `@clerk/nextjs` from v4 or v5 be sure to follow the Clerk upgrade guides as
  there are many breaking changes.

- Improvements to `npx convex run`:
  - Better argument parsing with JSON5 so `{ name: "sshader" }` parses
  - support for `--identity` similar to dashboard "acting as user" feature, like
    `npx convex run --identity '{ name: "sshader" }'`
  - `npx convex run api.foo.bar` is equivalent to `npx convex run foo:bar`
  - `npx convex run convex/foo.ts:bar` is equivalent to `npx convex run foo:bar`
  - `npx convex run convex/foo.ts` is equivalent to `npx convex run foo:default`

- Allow non-JavaScript/TypeScript files in the `convex/` directory. Only .js
  etc. files will be bundled and may define Convex functions points but adding a
  temporary file like `convex/foo.tmp` will no longer break` the build.

- Fix type for FieldTypeFromFieldPath with optional objects.

- Fix types when a handler returns a promise when using return value validators
  with object syntax.

## 1.17.4

- Revert use of the identity of useAuth from Clerk to determine whether
  refreshing auth is necessary. This was causing an auth loop in Expo.

## 1.17.3

- Fetch a new JWT from Clerk when using Clerk components to change the active
  orgId or orgRole in React on the client. Any auth provider can implement this
  by returning a new `getToken` function from the `useAuth` hook passed into
  `ConvexProviderWithAuth`.

## 1.17.2

- Revert local Prettier settings change described in 1.17.1 which removed angle
  brackets in some cases where local prettier config used plugins.

- `npx convex import --replace-all` flag which behaves like the Restore
  functionality in the dashboard.

## 1.17.1

- Use local Prettier settings to format code in `convex/_generated` if found.
- Extend supported react and react-dom peerDependencies to include v19
  prereleases. This is temporary, only stable React 19 releases will be
  supported in the long term.
- Hook up Sentry reporting for local deployments, opted-into by
  `npx convex dev --local`. This telemetry will be made configurable before this
  feature is released more broadly. This is being called out here for
  transparency regarding telemetry, but this `--local` feature is not yet ready
  for general consumption. Please don't use it unless you're excited to help
  test unfinished features and willing to have errors submitted to Convex.
- Don't try to bundle .txt or .md files in the convex/ directory.
- Don't include credentials in HTTP client requests.

## 1.17.0

- Disallow extra arguments to CLI commands.
- `--component` flags for `convex import` and `convex data`.
- `--run-component` flag for `convex dev --run`
- Remove prettier-ignore-start directives from generated code.
- Fix file watcher bug where a syntax error could cause a file to stop being
  watched.
- Downgrade jwt-decode dependency back to ^3.1.2.
- Change refresh token renewal timing

## 1.16.6

- Detect TanStack Start projects and use environment variable name
  `VITE_CONVEX_URL`.

## 1.16.5

- restore `--run` flag of `convex import`

## 1.16.4

- Don't typecheck dependent components by default, add `--typecheckComponents`
  flag to typecheck.

## 1.16.3

- Fix some library typecheck errors introduced in 1.16.1. Workaround for
  previous versions is to add `"skipLibCheck": true` to the tsconfig.json in the
  convex directory.

## 1.16.2

- Change some language around components beta.

## 1.16.1

- Release components, a feature in beta. These codepaths should not be active
  unless a convex directory contains a file named `convex.config.ts`. Components
  aren't documented yet and may change significantly before general release.

## 1.16.0

- Added support for a new validator, `v.record`. This is a typed key-value
  object in TypeScript. More information can be found in the
  [docs](https://docs.convex.dev/functions/validation#record-objects).
- Upgrade esbuild from 0.17 to 0.23. It's possible to use an npm override to use
  a different version of esbuild if you need to stay on an older version,
  although changes to the esbuild API could break this in the future.

  See
  [esbuild changelog](https://github.com/evanw/esbuild/blob/main/CHANGELOG.md)
  for the full list of changes. One standout: tsconfig.json is no longer used by
  esbuild for `jsx` setting. Convex now sets it manually to
  ["automatic"](https://esbuild.github.io/api/#jsx).

## 1.15.0

- Added new command, `npx convex function-spec`, that exposes the function
  metadata (name, type, validators, visibility) of functions defined in your
  Convex deployment
- Generated code no longer includes the "Generated by convex@version" comment
- Fix issue with `convexClient.query()` so it always returns a Promise

## 1.14.0

- Updates to ConvexReactClient to work better with authentication and server
  rendering
- `npx convex init` and `npx convex reinit` have been deprecated in favor of
  `npx convex dev --configure`
- Drop support for Node.js v16, and with it drop the dependency on node-fetch.
  This removes the 'punycode' deprecation warning printed when running the CLI
  in more recent versions of Node.js.
- Support for custom claims in JWTs

## 1.13.2

- Fix `npx convex import` regression in 1.13.1

## 1.13.1

- Relax client URL validation to prepare for Convex backends accessible on
  arbitrary domain. This makes `skipConvexDeploymentUrlCheck` client option also
  no longer required for accessing deployments not hosted on the Convex BaaS.

- Fix bug where the first mutation request send over the WebSocket failing would
  not roll back the corresponding optimistic update (completedMutationId could
  be 0 which is falsey!)

- Fix bug where `codegen --init` would fail if no Convex directory existed yet.

- Action and query function wrappers now also allow validators for args
  (previously only objects were accepted) and objects for returns (previously
  only validators were accepted).

- Change `httpRouter` behavior for overlapping paths: exact matches first, then
  the longest prefix patch that matches.

## 1.13.0

- Convex queries, mutations, and actions now accept `returns:` property to
  specify a return value validator.

  Return value validators throw a runtime error (so will roll back the
  transaction in a mutation) when the value returned from a query or mutation
  does not match this validator. This is _stricter than TypeScript_ in that
  extra properties will not be allowed.

- Validator fields are now exposed: the return value of `v.object({ ... })` now
  has a `.fields` property with the validators for each property on it.

  ```
  const message = v.object({ user: v.string(), body: v.string() });
  const imageMessage = v.object({ ...message.fields, })
  ```

  These validators are also exposed on the schema at
  `schema.tables.messages.validator`

  The `Validator` export is no longer a class. It is now a discriminated union
  type of all validators where the `.kind` as the discriminator. The `Validator`
  type still has three type parameters with only the first (the TypeScript type
  enforced by the validator) required.

  The second type parameter IsOptional is no longer a boolean, is it "optional"
  or "required" now.

  These are breaking changes if you're using the two optional type parameters of
  `Validator` or doing `instanceof` checks with `Validator`! We apologize for
  the inconvenience. The same users this affects should be the ones that most
  benefit from the ability to work with validator types more directly.

- Argument validators now accept validators (object validators and union
  validators) in addition to objects with validators as properties. Return value
  validators similarly accept either validators or objects with validators as
  properties, but unlike `args:` any validator is allowed.

  Custom function wrappers (AKA middleware) should continue to work, but to
  present the same API has the builtin Convex function wrappers `query`,
  `internalQuery`, `mutation` etc. you'll need to update such code to accept
  either a validator or an object of validators. You'll likely want to update
  these anyway to support return value validators. The new `asValidator` helper
  maybe useful here.

- The default tsconfig.json created in projects when first creating the
  `convex/` directory now uses `"moduleResolution": "Bundler"`. This is just a
  better default, you
  [probably never want the previous default `"node"`/`"node10"`](https://www.typescriptlang.org/tsconfig/#moduleResolution).

## 1.12.1

- Fix bug where `npx convex deploy` and `npx convex dev` would incorrectly skip
  pushing if the only change was removing files

## 1.12.0

- `npx convex env set` works with `ENV_VAR_NAME=value` syntax

## 1.11.3

- Fix bug when filling out an empty env file
- Exclude files beginning with # from convex directory entry points
- Warn when pushing with an https.ts file
- throw if argument to Query.take() is not an integer

## 1.11.2

- Fix timestamps in npm convex logs

## 1.11.1

- Allow Clerk 5 (currently in beta) in convex peerDependencies
- Fix typechecking bug on Windows caused by the Node.js patch for CVE-2024-27980
  that makes running tsc.CMD directly no longer work
- Exclude jsonl from convex directory entry points
- Add autocomplete for project selection in new project flow
- output debugBundlePath as full bundle instead of as a single file

---

Find release notes for versions before 1.11.3 on the
[Convex Blog](https://news.convex.dev/tag/releases/).



================================================
FILE: npm-packages/convex/CONTRIBUTING.md
================================================
# Contributing

Thanks for your interest in contributing to convex-js.

For anything not covered here, feel free to ask in the
[Convex Discord Community](https://convex.dev/community).

### I have a question

Great, please use GitHub discussions for this, or ask in Discord.

## I have a feature suggestion

Great, please open a GitHub issue on this repository for this or share in
Discord.

### I want to make a pull request

convex-js is developed primarily by employees of Convex Inc. We're excited to
provide transparency to our customers and contribute to the community by
releasing this code. We can accept some pull requests from non-employee
contributors, but please check in on Discord or in GitHub issues before getting
into anything more than small fixes to see if it's consistent with our short
term plan. We think carefully about how our APIs contribute to a cohesive
product, so chatting up front goes a long way.

Client tests can be run with

```
npm test
```

but be aware that there are integration tests, end-to-end tests, proptests, and
more which test this code but are not located in this repository.

# Directory structure notes

Code generally lives in the src/ directory.

The nearly-empty directories for each entry point at the top level implement the
'package-json-redirects' strategy described at
https://github.com/andrewbranch/example-subpath-exports-ts-compat in an effort
to make the convex npm package as compatible as possible while making the
published package mirror the filesystem of this repository.

# Build notes

management-api.json is a programmatically updated file that generates
src/cli/generatedApi.ts, but generating this file is a manual process. Run
`npm run generateManagementApiSpec` to update it.



================================================
FILE: npm-packages/convex/api-extractor-configs/README.md
================================================
We're starting to use api-extractor for api reports. The saved versions are
committed to reports/ directory, making it possible to track evolution of the
public API.

Since api-extractor .d.ts rollups don't support declaration map, using these as
published types break jump-to-definition in VS Code. Until
[declaration map rollups](https://github.com/microsoft/rushstack/issues/1886)
are implemented we compile public types with `tsc --stripInternal`, which
requires marking exports as internal at the index.ts barrel file level if they
need to be used in multiple files.



================================================
FILE: npm-packages/convex/api-extractor-configs/reports/server.api.md
================================================
## API Report File for "convex"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type ActionBuilder<DataModel extends GenericDataModel, Visibility extends FunctionVisibility> = {
    <Output, ArgsValidator extends PropertyValidators>(func: ValidatedFunction<GenericActionCtx<DataModel>, ArgsValidator, Output>): RegisteredAction<Visibility, ObjectType<ArgsValidator>, Output>;
    <Output, Args extends ArgsArray = OneArgArray>(func: UnvalidatedFunction<GenericActionCtx<DataModel>, Args, Output>): RegisteredAction<Visibility, ArgsArrayToObject<Args>, Output>;
};

// @public @deprecated
export interface ActionCtx<DataModel extends GenericDataModel = GenericDataModel> extends GenericActionCtx<DataModel> {
}

// @public
export const actionGeneric: ActionBuilder<any, "public">;

// Warning: (ae-forgotten-export) The symbol "AnyModuleDirOrFunc" needs to be exported by the entry point index.d.ts
//
// @public
export type AnyApi = Record<string, Record<string, AnyModuleDirOrFunc>>;

// @public
export const anyApi: AnyApi;

// @public
export type AnyDataModel = {
    [tableName: string]: {
        document: any;
        fieldPaths: GenericFieldPaths;
        indexes: {};
        searchIndexes: {};
        vectorIndexes: {};
    };
};

// Warning: (ae-forgotten-export) The symbol "ApiFromModulesAllowEmptyNodes" needs to be exported by the entry point index.d.ts
//
// @public
export type ApiFromModules<AllModules extends Record<string, object>> = FilterApi<ApiFromModulesAllowEmptyNodes<AllModules>, FunctionReference<any, any, any, any>>;

// Warning: (ae-forgotten-export) The symbol "AnyFunctionReference" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "EmptyObject" needs to be exported by the entry point index.d.ts
//
// @public
export type ArgsAndOptions<FuncRef extends AnyFunctionReference, Options> = FuncRef["_args"] extends EmptyObject ? [args?: EmptyObject, options?: Options] : [args: FuncRef["_args"], options?: Options];

// Warning: (ae-forgotten-export) The symbol "NoArgsArray" needs to be exported by the entry point index.d.ts
//
// @public
export type ArgsArray = OneArgArray | NoArgsArray;

// @public
export interface Auth {
    getUserIdentity(): Promise<UserIdentity | null>;
}

// @public
export interface CronJob {
    // Warning: (ae-forgotten-export) The symbol "JSONValue" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    args: JSONValue;
    // (undocumented)
    name: string;
    // Warning: (ae-forgotten-export) The symbol "Schedule" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    schedule: Schedule;
}

// @public
export const cronJobs: () => Crons;

// @public
export class Crons {
    constructor();
    // Warning: (ae-forgotten-export) The symbol "CronString" needs to be exported by the entry point index.d.ts
    cron<FuncRef extends SchedulableFunctionReference>(cronIdentifier: string, cron: CronString, functionReference: FuncRef, ...args: OptionalRestArgs<FuncRef>): void;
    // (undocumented)
    crons: Record<string, CronJob>;
    // Warning: (ae-forgotten-export) The symbol "Daily" needs to be exported by the entry point index.d.ts
    daily<FuncRef extends SchedulableFunctionReference>(cronIdentifier: string, schedule: Daily, functionReference: FuncRef, ...args: OptionalRestArgs<FuncRef>): void;
    // Warning: (ae-forgotten-export) The symbol "Hourly" needs to be exported by the entry point index.d.ts
    hourly<FuncRef extends SchedulableFunctionReference>(cronIdentifier: string, schedule: Hourly, functionReference: FuncRef, ...args: OptionalRestArgs<FuncRef>): void;
    // Warning: (ae-forgotten-export) The symbol "Interval" needs to be exported by the entry point index.d.ts
    interval<FuncRef extends SchedulableFunctionReference>(cronIdentifier: string, schedule: Interval, functionReference: FuncRef, ...args: OptionalRestArgs<FuncRef>): void;
    // (undocumented)
    isCrons: true;
    // Warning: (ae-forgotten-export) The symbol "Monthly" needs to be exported by the entry point index.d.ts
    monthly<FuncRef extends SchedulableFunctionReference>(cronIdentifier: string, schedule: Monthly, functionReference: FuncRef, ...args: OptionalRestArgs<FuncRef>): void;
    // Warning: (ae-forgotten-export) The symbol "Weekly" needs to be exported by the entry point index.d.ts
    weekly<FuncRef extends SchedulableFunctionReference>(cronIdentifier: string, schedule: Weekly, functionReference: FuncRef, ...args: OptionalRestArgs<FuncRef>): void;
}

// @public
export type Cursor = string;

// @public @deprecated (undocumented)
export interface DatabaseReader<DataModel extends GenericDataModel> {
    // Warning: (ae-forgotten-export) The symbol "Id" needs to be exported by the entry point index.d.ts
    get<TableName extends TableNamesInDataModel<DataModel>>(id: Id<TableName>): Promise<DocumentByName<DataModel, TableName> | null>;
    normalizeId<TableName extends TableNamesInDataModel<DataModel>>(tableName: TableName, id: string): Id<TableName> | null;
    query<TableName extends TableNamesInDataModel<DataModel>>(tableName: TableName): QueryInitializer<NamedTableInfo<DataModel, TableName>>;
}

// @public @deprecated (undocumented)
export interface DatabaseWriter<DataModel extends GenericDataModel> extends GenericDatabaseReader<DataModel> {
    delete(id: Id<TableNamesInDataModel<DataModel>>): Promise<void>;
    insert<TableName extends TableNamesInDataModel<DataModel>>(table: TableName, value: WithoutSystemFields<DocumentByName<DataModel, TableName>>): Promise<Id<TableName>>;
    patch<TableName extends TableNamesInDataModel<DataModel>>(id: Id<TableName>, value: Partial<DocumentByName<DataModel, TableName>>): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "WithOptionalSystemFields" needs to be exported by the entry point index.d.ts
    replace<TableName extends TableNamesInDataModel<DataModel>>(id: Id<TableName>, value: WithOptionalSystemFields<DocumentByName<DataModel, TableName>>): Promise<void>;
}

// Warning: (ae-forgotten-export) The symbol "MaybeMakeLooseDataModel" needs to be exported by the entry point index.d.ts
//
// @public
export type DataModelFromSchemaDefinition<SchemaDef extends SchemaDefinition<any, boolean>> = MaybeMakeLooseDataModel<{
    [TableName in keyof SchemaDef["tables"] & string]: SchemaDef["tables"][TableName] extends TableDefinition<infer Document, infer FieldPaths, infer Indexes, infer SearchIndexes, infer VectorIndexes> ? {
        document: Expand<IdField<TableName> & Document>;
        fieldPaths: keyof IdField<TableName> | FieldPaths;
        indexes: Expand<Indexes & SystemIndexes>;
        searchIndexes: SearchIndexes;
        vectorIndexes: VectorIndexes;
    } : never;
}, SchemaDef["strictTableNameTypes"]>;

// @public
export type DefaultFunctionArgs = Record<string, unknown>;

// @public
export function defineSchema<Schema extends GenericSchema, StrictTableNameTypes extends boolean = true>(schema: Schema, options?: DefineSchemaOptions<StrictTableNameTypes>): SchemaDefinition<Schema, StrictTableNameTypes>;

// @public
export interface DefineSchemaOptions<StrictTableNameTypes extends boolean> {
    schemaValidation?: boolean;
    strictTableNameTypes?: StrictTableNameTypes;
}

// Warning: (ae-forgotten-export) The symbol "Validator" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExtractDocument" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExtractFieldPaths" needs to be exported by the entry point index.d.ts
//
// @public
export function defineTable<DocumentSchema extends Validator<Record<string, any>, false, any>>(documentSchema: DocumentSchema): TableDefinition<ExtractDocument<DocumentSchema>, ExtractFieldPaths<DocumentSchema>>;

// Warning: (ae-forgotten-export) The symbol "ObjectValidator" needs to be exported by the entry point index.d.ts
//
// @public
export function defineTable<DocumentSchema extends Record<string, Validator<any, any, any>>>(documentSchema: DocumentSchema): TableDefinition<ExtractDocument<ObjectValidator<DocumentSchema>>, ExtractFieldPaths<ObjectValidator<DocumentSchema>>>;

// @public
export type DocumentByInfo<TableInfo extends GenericTableInfo> = TableInfo["document"];

// @public
export type DocumentByName<DataModel extends GenericDataModel, TableName extends TableNamesInDataModel<DataModel>> = DataModel[TableName]["document"];

// Warning: (ae-forgotten-export) The symbol "Value" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Expression<T extends Value | undefined> {
}

// @public
export type ExpressionOrValue<T extends Value | undefined> = Expression<T> | T;

// @public
export type FieldPaths<TableInfo extends GenericTableInfo> = TableInfo["fieldPaths"];

// @public
export type FieldTypeFromFieldPath<Document extends GenericDocument, FieldPath extends string> = FieldPath extends `${infer First}.${infer Second}` ? First extends keyof Document ? Document[First] extends GenericDocument ? FieldTypeFromFieldPath<Document[First], Second> : undefined : undefined : FieldPath extends keyof Document ? Document[FieldPath] : undefined;

// @public
export type FileMetadata = {
    storageId: StorageId;
    sha256: string;
    size: number;
    contentType: string | null;
};

// @public
export type FilterApi<API, Predicate> = Expand<{
    [mod in keyof API as API[mod] extends Predicate ? mod : API[mod] extends FunctionReference<any, any, any, any> ? never : FilterApi<API[mod], Predicate> extends Record<string, never> ? never : mod]: API[mod] extends Predicate ? API[mod] : FilterApi<API[mod], Predicate>;
}>;

// @public
export function filterApi<API, Predicate>(api: API): FilterApi<API, Predicate>;

// @public
export interface FilterBuilder<TableInfo extends GenericTableInfo> {
    // Warning: (ae-forgotten-export) The symbol "NumericValue" needs to be exported by the entry point index.d.ts
    add<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
    and(...exprs: Array<ExpressionOrValue<boolean>>): Expression<boolean>;
    div<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
    eq<T extends Value | undefined>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    field<FieldPath extends FieldPaths<TableInfo>>(fieldPath: FieldPath): Expression<FieldTypeFromFieldPath<DocumentByInfo<TableInfo>, FieldPath>>;
    gt<T extends Value>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    gte<T extends Value>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    lt<T extends Value>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    lte<T extends Value>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    mod<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
    mul<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
    neg<T extends NumericValue>(x: ExpressionOrValue<T>): Expression<T>;
    neq<T extends Value | undefined>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<boolean>;
    not(x: ExpressionOrValue<boolean>): Expression<boolean>;
    or(...exprs: Array<ExpressionOrValue<boolean>>): Expression<boolean>;
    sub<T extends NumericValue>(l: ExpressionOrValue<T>, r: ExpressionOrValue<T>): Expression<T>;
}

// @public
export type FunctionArgs<FuncRef extends AnyFunctionReference> = FuncRef["_args"];

// @public
export type FunctionReference<Type extends FunctionType, Visibility extends FunctionVisibility = "public", Args extends DefaultFunctionArgs = any, ReturnType = any> = {
    _type: Type;
    _visibility: Visibility;
    _args: Args;
    _returnType: ReturnType;
};

// @public
export type FunctionReturnType<FuncRef extends AnyFunctionReference> = FuncRef["_returnType"];

// @public
export type FunctionType = "query" | "mutation" | "action";

// @public
export type FunctionVisibility = "public" | "internal";

// @public
export interface GenericActionCtx<DataModel extends GenericDataModel> {
    auth: Auth;
    runAction<Action extends FunctionReference<"action", "public" | "internal">>(action: Action, ...args: OptionalRestArgs<Action>): Promise<FunctionReturnType<Action>>;
    runMutation<Mutation extends FunctionReference<"mutation", "public" | "internal">>(mutation: Mutation, ...args: OptionalRestArgs<Mutation>): Promise<FunctionReturnType<Mutation>>;
    runQuery<Query extends FunctionReference<"query", "public" | "internal">>(query: Query, ...args: OptionalRestArgs<Query>): Promise<FunctionReturnType<Query>>;
    scheduler: Scheduler;
    storage: StorageActionWriter;
}

// @public
export interface GenericDatabaseReader<DataModel extends GenericDataModel> extends DatabaseReader<DataModel> {
}

// @public
export interface GenericDatabaseWriter<DataModel extends GenericDataModel> extends DatabaseWriter<DataModel> {
}

// @public
export type GenericDataModel = Record<string, GenericTableInfo>;

// @public
export type GenericDocument = Record<string, Value>;

// @public
export type GenericFieldPaths = string;

// @public
export type GenericIndexFields = string[];

// @public
export interface GenericMutationCtx<DataModel extends GenericDataModel> {
    auth: Auth;
    db: GenericDatabaseWriter<DataModel>;
    scheduler: Scheduler;
    storage: StorageWriter;
}

// @public
export interface GenericQueryCtx<DataModel extends GenericDataModel> {
    auth: Auth;
    db: GenericDatabaseReader<DataModel>;
    storage: StorageReader;
}

// @public
export type GenericSchema = Record<string, TableDefinition>;

// @public
export type GenericSearchIndexConfig = {
    searchField: string;
    filterFields: string;
};

// @public
export type GenericTableIndexes = Record<string, GenericIndexFields>;

// @public
export type GenericTableInfo = {
    document: GenericDocument;
    fieldPaths: GenericFieldPaths;
    indexes: GenericTableIndexes;
    searchIndexes: GenericTableSearchIndexes;
    vectorIndexes: GenericTableVectorIndexes;
};

// @public
export type GenericTableSearchIndexes = Record<string, GenericSearchIndexConfig>;

// @public
export function getFunctionName(functionReference: AnyFunctionReference): string;

// @public
export type HttpActionBuilder = (func: (ctx: GenericActionCtx<any>, request: Request) => Promise<Response>) => PublicHttpAction;

// @public
export const httpActionGeneric: (func: (ctx: ActionCtx<GenericDataModel>, request: Request) => Promise<Response>) => PublicHttpAction;

// @public
export class HttpRouter {
    // (undocumented)
    exactRoutes: Map<string, Map<RoutableMethod, PublicHttpAction>>;
    getRoutes: () => (readonly [string, "GET" | "POST" | "PUT" | "DELETE" | "OPTIONS" | "PATCH", (...args: any[]) => any])[];
    // (undocumented)
    isRouter: boolean;
    lookup: (path: string, method: RoutableMethod | "HEAD") => Readonly<[PublicHttpAction, RoutableMethod, string]> | null;
    // (undocumented)
    prefixRoutes: Map<RoutableMethod, Map<string, PublicHttpAction>>;
    // Warning: (ae-forgotten-export) The symbol "RouteSpec" needs to be exported by the entry point index.d.ts
    route: (spec: RouteSpec) => void;
    runRequest: (argsStr: string) => Promise<string>;
}

// @public
export const httpRouter: () => HttpRouter;

// @public
export type Indexes<TableInfo extends GenericTableInfo> = TableInfo["indexes"];

// @public
export type IndexNames<TableInfo extends GenericTableInfo> = keyof Indexes<TableInfo>;

// @public
export abstract class IndexRange {
}

// Warning: (ae-forgotten-export) The symbol "LowerBoundIndexRangeBuilder" needs to be exported by the entry point index.d.ts
//
// @public
export interface IndexRangeBuilder<Document extends GenericDocument, IndexFields extends GenericIndexFields, FieldNum extends number = 0> extends LowerBoundIndexRangeBuilder<Document, IndexFields[FieldNum]> {
    // Warning: (ae-forgotten-export) The symbol "NextIndexRangeBuilder" needs to be exported by the entry point index.d.ts
    eq(fieldName: IndexFields[FieldNum], value: FieldTypeFromFieldPath<Document, IndexFields[FieldNum]>): NextIndexRangeBuilder<Document, IndexFields, FieldNum>;
}

// @public
export const internalActionGeneric: ActionBuilder<any, "internal">;

// @public
export const internalMutationGeneric: MutationBuilder<any, "internal">;

// @public
export const internalQueryGeneric: QueryBuilder<any, "internal">;

// @public
export function makeFunctionReference<type extends FunctionType, args extends DefaultFunctionArgs = any, ret = any>(name: string): FunctionReference<type, "public", args, ret>;

// @public
export type MutationBuilder<DataModel extends GenericDataModel, Visibility extends FunctionVisibility> = {
    <Output, ArgsValidator extends PropertyValidators>(func: ValidatedFunction<GenericMutationCtx<DataModel>, ArgsValidator, Output>): RegisteredMutation<Visibility, ObjectType<ArgsValidator>, Output>;
    <Output, Args extends ArgsArray = OneArgArray>(func: UnvalidatedFunction<GenericMutationCtx<DataModel>, Args, Output>): RegisteredMutation<Visibility, ArgsArrayToObject<Args>, Output>;
};

// @public @deprecated
export interface MutationCtx<DataModel extends GenericDataModel> extends GenericMutationCtx<DataModel> {
}

// @public
export const mutationGeneric: MutationBuilder<any, "public">;

// @public
export type NamedIndex<TableInfo extends GenericTableInfo, IndexName extends IndexNames<TableInfo>> = Indexes<TableInfo>[IndexName];

// @public
export type NamedSearchIndex<TableInfo extends GenericTableInfo, IndexName extends SearchIndexNames<TableInfo>> = SearchIndexes<TableInfo>[IndexName];

// @public
export type NamedTableInfo<DataModel extends GenericDataModel, TableName extends keyof DataModel> = DataModel[TableName];

// @public
export type OptionalRestArgs<FuncRef extends AnyFunctionReference> = FuncRef["_args"] extends EmptyObject ? [args?: EmptyObject] : [args: FuncRef["_args"]];

// @public
export interface OrderedQuery<TableInfo extends GenericTableInfo> extends AsyncIterable<DocumentByInfo<TableInfo>> {
    collect(): Promise<Array<DocumentByInfo<TableInfo>>>;
    filter(predicate: (q: FilterBuilder<TableInfo>) => ExpressionOrValue<boolean>): this;
    first(): Promise<DocumentByInfo<TableInfo> | null>;
    paginate(paginationOpts: PaginationOptions): Promise<PaginationResult<DocumentByInfo<TableInfo>>>;
    take(n: number): Promise<Array<DocumentByInfo<TableInfo>>>;
    unique(): Promise<DocumentByInfo<TableInfo> | null>;
}

// @public
export interface PaginationOptions {
    cursor: Cursor | null;
    numItems: number;
}

// @public
export const paginationOptsValidator: ObjectValidator<    {
numItems: Validator<number, false, never>;
cursor: Validator<string | null, false, never>;
id: Validator<number | undefined, true, never>;
}>;

// @public
export interface PaginationResult<T> {
    continueCursor: Cursor;
    isDone: boolean;
    page: T[];
}

// @public
export type PartialApi<API> = {
    [mod in keyof API]?: API[mod] extends FunctionReference<any, any, any, any> ? API[mod] : PartialApi<API[mod]>;
};

// @public
export type PublicHttpAction = {
    (ctx: GenericActionCtx<any>, request: Request): Response;
    isHttp: true;
    isRegistered?: true;
};

// @public
export interface Query<TableInfo extends GenericTableInfo> extends OrderedQuery<TableInfo> {
    order(order: "asc" | "desc"): OrderedQuery<TableInfo>;
}

// @public
export type QueryBuilder<DataModel extends GenericDataModel, Visibility extends FunctionVisibility> = {
    <Output, ArgsValidator extends PropertyValidators>(func: ValidatedFunction<GenericQueryCtx<DataModel>, ArgsValidator, Output>): RegisteredQuery<Visibility, ObjectType<ArgsValidator>, Output>;
    <Output, Args extends ArgsArray = OneArgArray>(func: UnvalidatedFunction<GenericQueryCtx<DataModel>, Args, Output>): RegisteredQuery<Visibility, ArgsArrayToObject<Args>, Output>;
};

// @public @deprecated
export interface QueryCtx<DataModel extends GenericDataModel> extends GenericQueryCtx<DataModel> {
}

// @public
export const queryGeneric: QueryBuilder<any, "public">;

// @public
export interface QueryInitializer<TableInfo extends GenericTableInfo> extends Query<TableInfo> {
    fullTableScan(): Query<TableInfo>;
    withIndex<IndexName extends IndexNames<TableInfo>>(indexName: IndexName, indexRange?: (q: IndexRangeBuilder<DocumentByInfo<TableInfo>, NamedIndex<TableInfo, IndexName>>) => IndexRange): Query<TableInfo>;
    withSearchIndex<IndexName extends SearchIndexNames<TableInfo>>(indexName: IndexName, searchFilter: (q: SearchFilterBuilder<DocumentByInfo<TableInfo>, NamedSearchIndex<TableInfo, IndexName>>) => SearchFilter): OrderedQuery<TableInfo>;
}

// Warning: (ae-forgotten-export) The symbol "VisibilityProperties" needs to be exported by the entry point index.d.ts
//
// @public
export type RegisteredAction<Visibility extends FunctionVisibility, Args extends DefaultFunctionArgs, Output> = {
    (ctx: GenericActionCtx<any>, args: Args): Output;
    isConvexFunction: true;
    isAction: true;
    isRegistered?: true;
} & VisibilityProperties<Visibility>;

// @public
export type RegisteredMutation<Visibility extends FunctionVisibility, Args extends DefaultFunctionArgs, Output> = {
    (ctx: GenericMutationCtx<any>, args: Args): Output;
    isConvexFunction: true;
    isMutation: true;
    isRegistered?: true;
} & VisibilityProperties<Visibility>;

// @public
export type RegisteredQuery<Visibility extends FunctionVisibility, Args extends DefaultFunctionArgs, Output> = {
    (ctx: GenericQueryCtx<any>, args: Args): Output;
    isConvexFunction: true;
    isQuery: true;
    isRegistered?: true;
} & VisibilityProperties<Visibility>;

// @public
export const ROUTABLE_HTTP_METHODS: readonly ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"];

// @public
export type RoutableMethod = (typeof ROUTABLE_HTTP_METHODS)[number];

// @public
export type SchedulableFunctionReference = FunctionReference<"mutation" | "action", "public" | "internal">;

// @public
export interface Scheduler {
    runAfter<FuncRef extends SchedulableFunctionReference>(delayMs: number, functionReference: FuncRef, ...args: OptionalRestArgs<FuncRef>): Promise<void>;
    runAt<FuncRef extends SchedulableFunctionReference>(timestamp: number | Date, functionReference: FuncRef, ...args: OptionalRestArgs<FuncRef>): Promise<void>;
}

// @public
export class SchemaDefinition<Schema extends GenericSchema, StrictTableTypes extends boolean> {
    // (undocumented)
    strictTableNameTypes: StrictTableTypes;
    // (undocumented)
    tables: Schema;
}

// @public
export abstract class SearchFilter {
}

// @public
export interface SearchFilterBuilder<Document extends GenericDocument, SearchIndexConfig extends GenericSearchIndexConfig> {
    search(fieldName: SearchIndexConfig["searchField"], query: string): SearchFilterFinalizer<Document, SearchIndexConfig>;
}

// @public
export interface SearchFilterFinalizer<Document extends GenericDocument, SearchIndexConfig extends GenericSearchIndexConfig> extends SearchFilter {
    eq<FieldName extends SearchIndexConfig["filterFields"]>(fieldName: FieldName, value: FieldTypeFromFieldPath<Document, FieldName>): SearchFilterFinalizer<Document, SearchIndexConfig>;
}

// @public
export interface SearchIndexConfig<SearchField extends string, FilterFields extends string> {
    filterFields?: FilterFields[];
    searchField: SearchField;
}

// @public
export type SearchIndexes<TableInfo extends GenericTableInfo> = TableInfo["searchIndexes"];

// @public
export type SearchIndexNames<TableInfo extends GenericTableInfo> = keyof SearchIndexes<TableInfo>;

// @public
export interface StorageActionWriter extends StorageWriter {
    get(storageId: StorageId): Promise<Blob | null>;
    store(blob: Blob, options?: {
        sha256?: string;
    }): Promise<StorageId>;
}

// @public
export type StorageId = string;

// @public
export interface StorageReader {
    getMetadata(storageId: StorageId): Promise<FileMetadata | null>;
    getUrl(storageId: StorageId): Promise<string | null>;
}

// @public
export interface StorageWriter extends StorageReader {
    delete(storageId: StorageId): Promise<void>;
    generateUploadUrl(): Promise<string>;
}

// @public
export class TableDefinition<Document extends GenericDocument = GenericDocument, FieldPaths extends string = string, Indexes extends GenericTableIndexes = {}, SearchIndexes extends GenericTableSearchIndexes = {}, VectorIndexes extends GenericTableVectorIndexes = {}> {
    // Warning: (ae-forgotten-export) The symbol "IndexTiebreakerField" needs to be exported by the entry point index.d.ts
    index<IndexName extends string, FirstFieldPath extends FieldPaths, RestFieldPaths extends FieldPaths[]>(name: IndexName, fields: [FirstFieldPath, ...RestFieldPaths]): TableDefinition<Document, FieldPaths, Expand<Indexes & Record<IndexName, [
    FirstFieldPath,
    ...RestFieldPaths,
    IndexTiebreakerField
    ]>>, SearchIndexes, VectorIndexes>;
    searchIndex<IndexName extends string, SearchField extends FieldPaths, FilterFields extends FieldPaths = never>(name: IndexName, indexConfig: Expand<SearchIndexConfig<SearchField, FilterFields>>): TableDefinition<Document, FieldPaths, Indexes, Expand<SearchIndexes & Record<IndexName, {
        searchField: SearchField;
        filterFields: FilterFields;
    }>>, VectorIndexes>;
}

// @public
export type TableNamesInDataModel<DataModel extends GenericDataModel> = keyof DataModel & string;

// @public
export type UnvalidatedFunction<Ctx, Args extends ArgsArray, Output> = ((ctx: Ctx, ...args: Args) => Output) | {
    handler: (ctx: Ctx, ...args: Args) => Output;
};

// @public
export interface UserIdentity {
    // (undocumented)
    readonly address?: string;
    // (undocumented)
    readonly birthday?: string;
    // (undocumented)
    readonly email?: string;
    // (undocumented)
    readonly emailVerified?: boolean;
    // (undocumented)
    readonly familyName?: string;
    // (undocumented)
    readonly gender?: string;
    // (undocumented)
    readonly givenName?: string;
    readonly issuer: string;
    // (undocumented)
    readonly language?: string;
    // (undocumented)
    readonly name?: string;
    // (undocumented)
    readonly nickname?: string;
    // (undocumented)
    readonly phoneNumber?: string;
    // (undocumented)
    readonly phoneNumberVerified?: boolean;
    // (undocumented)
    readonly pictureUrl?: string;
    // (undocumented)
    readonly preferredUsername?: string;
    // (undocumented)
    readonly profileUrl?: string;
    readonly subject: string;
    // (undocumented)
    readonly timezone?: string;
    readonly tokenIdentifier: string;
    // (undocumented)
    readonly updatedAt?: string;
}

// @public
export interface ValidatedFunction<Ctx, ArgsValidator extends PropertyValidators, Output> {
    args: ArgsValidator;
    handler: (ctx: Ctx, args: ObjectType<ArgsValidator>) => Output;
}

// Warning: (ae-forgotten-export) The symbol "BetterOmit" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "SystemFields" needs to be exported by the entry point index.d.ts
//
// @public
export type WithoutSystemFields<Document extends GenericDocument> = Expand<BetterOmit<Document, keyof SystemFields | "_id">>;

// Warnings were encountered during analysis:
//
// src/server/data_model.ts:106:3 - (ae-forgotten-export) The symbol "GenericTableVectorIndexes" needs to be exported by the entry point index.d.ts
// src/server/registration.ts:527:3 - (ae-forgotten-export) The symbol "PropertyValidators" needs to be exported by the entry point index.d.ts
// src/server/registration.ts:527:3 - (ae-forgotten-export) The symbol "ObjectType" needs to be exported by the entry point index.d.ts
// src/server/registration.ts:531:3 - (ae-forgotten-export) The symbol "OneArgArray" needs to be exported by the entry point index.d.ts
// src/server/registration.ts:531:3 - (ae-forgotten-export) The symbol "ArgsArrayToObject" needs to be exported by the entry point index.d.ts
// src/server/schema.ts:521:11 - (ae-forgotten-export) The symbol "Expand" needs to be exported by the entry point index.d.ts
// src/server/schema.ts:521:11 - (ae-forgotten-export) The symbol "IdField" needs to be exported by the entry point index.d.ts
// src/server/schema.ts:523:11 - (ae-forgotten-export) The symbol "SystemIndexes" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```



================================================
FILE: npm-packages/convex/src/common/README.md
================================================
Code in this common/ folder is not publicly exposed, there is no 'convex/common'
export. Code here is used from other entry points.



================================================
FILE: npm-packages/convex/src/server/README.md
================================================
# Server

This is the entry point for all of the code for use within query and mutation
functions.

This directory uses an "interface-impl" pattern where:

- The main directory has all interfaces to define the types of the various
  abstractions. These are parameterized of the developers `DataModel` type and
  carefully written to only allow valid usage.
- The `impl/` subdirectory has implementations of all of these interfaces. These
  implementations are sloppier about their types and **not parameterized over
  `DataModel`**. This simplifies their implementation and only gives up a bit of
  type safety. The `DataModel` type is built to help developers write correct
  code, not to check that our internal structures are correct.



================================================
FILE: npm-packages/convex-ai-chat/README.md
================================================
# Developing AI Chat

1.  In one terminal, run `npm run dev`, to develop the backend against your dev
    deployment

    You can use team:convex project:ai-bot, this will set up environment
    variables for you

    If you don't use this project, make sure you set up `OPENAI_API_KEY` on the
    dashboard

2.  In another terminal, run `npm run watch`, this will continuously build the
    React entrypoint

3.  In another terminal, run `npm run watch-css-docs`, this will continuously
    build the Tailwind-powered css entrypoint

After you have all of these running, copy the CONVEX_URL value from the
`.env.local` file in this directory to `npm-packages/docs/.env.local` (see the
docs README.md), and run `just run-docs`.

Now whenever you make frontend changes in this project docs will reload and
reflect them.



================================================
FILE: npm-packages/convex-ai-chat/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/convex-chat-speculative/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/dashboard/README.md
================================================
# Convex Dashboard

This is the dashboard for Convex Cloud. If you intend to contribute to the
self-hosted dashboard, see the
[dashboard-self-hosted README](../dashboard-self-hosted/README.md). You may also
connect the self-hosted dashboard to a Convex Cloud deployment.

The following instructions are intended for Convex employees developing the
Cloud hosted dashboard.

## Running against a local `big-brain`.

### First time setup

First run `just rush install` to install dependencies.

You need environment variables set up to run the dashboard locally. First, run
`npx vercel link` to link your local instance to the Vercel project. You’ll need
to log in a Vercel account that is part of the Convex organization.

```
$ npx vercel link
Vercel CLI 30.2.3
> > No existing credentials found. Please log in:
? Log in to Vercel github
> Success! GitHub authentication complete for nicolas@convex.dev
? Set up “~/Documents/convex-alt/npm-packages/dashboard”? [Y/n] y
? Which scope should contain your project? Convex
? Found project “convex-dev/dashboard”. Link to it? [Y/n] y
✅  Linked to convex-dev/dashboard (created .vercel)
```

Then, you can run this command to pull an env configuration from Vercel:

```
npm run pullEnv
```

### Start the dashboard local server

Run `just run-dash`. It will prompt you to start big brain, in which case run
`just run-dash` again in another terminal.

Log in to the dashboard with, which will create an account on our staging WorkOS
instance.

### Reset big brain

You might need to clear the big brain database from time to time (or if you want
to reset to empty state, no login):

```bash
just bb-clean-db
```

### Create a project

Let's create a new project.

```bash
cd ../demos/tutorial
just convex-bb dev
```

Now you should be able to see your project on the dashboard.

### Developing NPM

If you make changes to any NPM packages used by the dashboard run
`just rush build -t convex` and restart the local server.

## Testing strategies

We have a few tools for testing in the dashboard. It is recommended to write
tests for new code and regressions you fix, but not required. However, be sure
to always test your changes via the Vercel deployment previews attached to your
GitHub pull requests.

### Unit tests

`npm run test` -- runs jest tests. these tests will also be run in CI

### Integration tests

## Bundle size

You can analyze the bundle size of the dashboard by running
`ANALYZE=true npm run build`.

## Storybook

We use [Storybook](https://storybook.js.org/) as a component library for
documentation the behavior and visual aspects of the dashboard design system.
Primitive components that do not depend on any Convex-related data or concepts
belong in the `src/elements` directory.

You can start Storybook using:

```bash
cd ~/src/convex/npm-packages/dashboard
npm run storybook
```

## Running the local dashboard against production

For this, we will proxy big brain via a cors proxy. Set these values in
`.env.local`. Some must be copied from
[Production vercel env vars](https://vercel.com/convex-dev/dashboard/settings/environment-variables)

```
NEXT_PUBLIC_BIG_BRAIN_URL=http://localhost:8080/https://api.convex.dev
WORKOS_LOGIN_URL=https://login.convex.dev
WORKOS_LOGOUT_URL=http://127.0.0.1/login
WORKOS_CLIENT_ID=client_01K0YV0SNPRYJ5AV4AS0VG7T1J
DISABLE_BIG_BRAIN_SSR=1

WORKOS_COOKIE_PASSWORD={copy from production env vars}
WORKOS_API_SECRET={copy from production env vars}
```

Run the CORS Anywhere proxy locally:

`npm run corsAnywhere`

Now when you `npm run dev:pure`, the dashboard will talk to production big brain
and backends.

Make sure you log out before you want to switch back, otherwise open
`http://localhost:6789/api/auth/logout` to log out if you get into a broken
state.



================================================
FILE: npm-packages/dashboard-common/README.md
================================================
# dashboard-common

This package is shared code used by the [`dashboard`](../dashboard/README.md)
(Convex Cloud) and [`dashboard-self-hosted`](../dashboard-self-hosted/README.md)
(self-hosted Convex).

## Development

You cannot run this code directly, but you may run the `dashboard` and
`dashboard-self-hosted` packages locally to test changes.



================================================
FILE: npm-packages/dashboard-common/src/pages/README.md
================================================
This directory is necessary for jest tests to run and be happy because nextjs
requires a page directory.



================================================
FILE: npm-packages/dashboard-self-hosted/README.md
================================================
# dashboard-self-hosted

This is the dashboard for the self-hosted version of Convex. You may run this
code locally to test changes.

## Configuration

To use the scripts set up in this repo you'll need to install
[`Just`](https://github.com/casey/just)

- Just is used to execute scripts set up in the `Justfile`.
- To install it see
  [Packages](https://github.com/casey/just?tab=readme-ov-file#packages), for
  example `cargo install just` or `brew install just`

Next you'll need the URL to your Convex deployment. This URL can point to a
deployment hosted locally, remotely, or on Convex Cloud (URL found on the
deployment settings page: https://dashboard.convex.dev/deployment/settings)

One time setup:

```
# Install dependencies
just rush install

# Build the project's dependencies
just rush build -T dashboard-self-hosted
```

Run the dashboard:

```
just run-dashboard "YOUR_DEPLOYMENT_URL"
```



================================================
FILE: npm-packages/demos/README.md
================================================
Demos are synced to the convex-demos repo during NPM release.



================================================
FILE: npm-packages/demos/args-validation/README.md
================================================
# Argument Validation Example App

This example demonstrates how to add argument validation to functions in a
Convex app.

The argument validator is in `convex/messages.js`. It ensures that the
parameters to `api.messages.send` are the correct types.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/args-validation/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/clerk/README.md
================================================
# Users and Authentication Example App

This example demonstrates how to add users and authentication to a basic chat
app. It uses [Clerk](https://clerk.dev/) for authentication.

Users are initially presented with a "Log In" button. After user's log in, their
information is persisted to a `users` table. When users send messages, each
message is associated with the user that sent it. Lastly, users can log out with
a "Log Out" button.

## Running the App

```sh
npm run dev
```

### Using your own Clerk instance

Follow the instructions in https://docs.convex.dev/auth/clerk#get-started to
obtain:

- A _publishable key_, use it in `main.tsx`
- A JWT template Issuer URL, use it in `auth.config.ts`.



================================================
FILE: npm-packages/demos/clerk/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/convex-test/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/cron-jobs/README.md
================================================
# Crons Example App

This app provides a basic example of how to use Convex cron jobs. It clears all
messages every minute. The example builds on the Convex
[tutorial](https://github.com/get-convex/convex/tree/main/npm-packages/demos/tutorial).

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/cron-jobs/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/custom-errors/README.md
================================================
# Custom Errors Example App

This example demonstrates how to use Convex errors from functions and clients.
clients.

This app is an extension of the Convex chat tutorial, where we throw custom
application-level errors if:

1. we try sending a message over 50 characters in length
2. we have more than 20 messages to list

To learn more about application errors see the
[Application Errors](https://docs.convex.dev/functions/error-handling/application-errors)
documentation.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/custom-errors/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/dall-e-storage-action/README.md
================================================
# Dall-E Storage & Action Example App

This example app demonstrates how to use
[Convex storage](https://docs.convex.dev/using/file-storage) and
[actions](https://docs.convex.dev/using/actions) together to save an image in
Convex that you download in an action. By default, Dall-E only generates images
that last an hour, so to maintain access to the image, we
[store the image in Convex](./convex/sendDallE.js) and store the `storageId`
[with the message](./convex/sendMessage.js). To show the image, we turn the
`storageId` into a url to the Convex-hosted image
[on demand](./convex/listMessages.js).

It allows the user to type a chat message, like `/dall-e cute cat`, and have it
send a dall-e generated image of a cute cat in the chat. wombat show up in the
chat stream. It builds on the Convex
[tutorial](https://github.com/get-convex/convex/tree/main/npm-packages/demos/tutorial).

## Running the App

Run:

```
npm install
npm run dev
```

Create a free account on openai.com and create your
[OpenAI API secret key](https://beta.openai.com/account/api-keys), and set it as
an [environment variable](https://docs.convex.dev/using/environment-variables)
with the name `OPENAI_API_KEY` via the
[Convex dashboard](https://dashboard.convex.dev/).

Then visit [localhost:3000](http://localhost:3000).



================================================
FILE: npm-packages/demos/dall-e-storage-action/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/file-storage/README.md
================================================
# File Storage Example App

This example demonstrates how to use Convex file storage to augment Convex Chat
with images.

This app is an extension of the Convex chat tutorial including a new button for
uploading images. Images will be stored in Convex file storage, with their
storage IDs saved in the messages table for access.

To learn more about storage see the
[File Storage](https://docs.convex.dev/using/file-storage) documentation.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/file-storage/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/file-storage-with-http/README.md
================================================
# File Storage with HTTP Actions

This example demonstrates how to use Convex file storage to augment Convex Chat
with images via [HTTP actions](https://docs.convex.dev/functions/http-actions).

This app is an extension of the Convex chat tutorial including a new button for
uploading images. Images will be stored in Convex file storage, with their
storage IDs saved in the messages table for access.

To learn more about storage see the
[File Storage](https://docs.convex.dev/file-storage) documentation.

## Running the App

### 1. Start dev

```
npm install
npm run dev
```

### 2. Add `VITE_CONVEX_SITE_URL` variable

Afterwards add `VITE_CONVEX_SITE_URL` to your `.env.local` file, by copying
`VITE_CONVEX_URL` and changing the top-level domain from `cloud` to `site`, like
this:

```
VITE_CONVEX_URL="https://happy-animal-123.convex.cloud"
VITE_CONVEX_SITE_URL="https://happy-animal-123.convex.site"
```

### 3. Set `CLIENT_ORIGIN` variable

Also add a `CLIENT_ORIGIN`
[Convex environment variable](https://docs.convex.dev/production/environment-variables)
on your [Convex dashboard](https://dashboard.convex.dev/) with the origin of
your website (e.g. `http://localhost:5173` if developing locally).



================================================
FILE: npm-packages/demos/file-storage-with-http/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/giphy-action/README.md
================================================
# GIPHY Action Example App

This example app demonstrates how to use Convex actions to call into third-party
services and how to use environment variables.

It allows the user to type a chat message, like `/giphy wombat`, query
[GIPHY](https://giphy.com/) for a wombat GIF, and have an animated GIF of a
wombat show up in the chat stream. It builds on the Convex
[tutorial](https://github.com/get-convex/convex/tree/main/npm-packages/demos/tutorial).

## Running the App

Run:

```
npm install
npm run dev
```

Create a GIPHY [developer account](https://developers.giphy.com), obtain a free
API app key on the
[developer dashboard](https://developers.giphy.com/dashboard/), and set it as an
[environment variable](https://docs.convex.dev/using/environment-variables) with
the name `GIPHY_KEY` via the [Convex dashboard](https://dashboard.convex.dev/).

Then visit [localhost:3000](http://localhost:3000).



================================================
FILE: npm-packages/demos/giphy-action/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/html/README.md
================================================
# Simple HTML

Convex deployments can be connected to from JavaScript written without a
bundler. See index.html for an example.

Without API objects, Convex functions are referenced as strings:

- `"filename:myQuery"`
- `"directory/filename:myMutation"`
- `"directory/action:default"`

### typed-example.html and script.js

When you have the convex functions in the same repository you can use these
types using api objects. Without using a bundler it's necessary to annotate code
JSDoc comments to get autocompletion. See typed-example.html for an example.



================================================
FILE: npm-packages/demos/html/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/http/README.md
================================================
# HTTP Action Example App

This example demonstrates how to use Convex
[HTTP actions](https://docs.convex.dev/functions/http-actions).

## Running the App

To run the web app:

```
npm install
npm run dev
```

To call the endpoints (e.g. using `curl`):

```
export DEPLOYMENT_NAME="tall-sheep-123"
curl "https://$DEPLOYMENT_NAME.convex.site/getMessagesByAuthor?authorNumber=123"
curl -d '{ "author": "User 123", "body": "Hello world" }' \
    -H 'content-type: application/json' "https://$DEPLOYMENT_NAME.convex.site/postMessage"
```



================================================
FILE: npm-packages/demos/http/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/nextjs-app-router/README.md
================================================
# Convex + Next.js SSR

This demo shows how to use the Convex Next.js integration to preload data for
Client Components during server rendering, and query and mutate data from Server
Actions or Route Handlers (API Routes).

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/nextjs-app-router/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/nextjs-pages-router/README.md
================================================
# Next.js Example App

This is a [Next.js](https://nextjs.org/) project bootstrapped with
[`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

```bash
npx create-next-app@latest --ts
```

After creating the project, convex was installed:

```bash
npm install convex
```

Convex functions were added to the `convex/` directory and a provider was added
to `_app.tsx`.

To learn more about using Convex with Next.js, see the
[Convex Next.js documentation](https://docs.convex.dev/client/nextjs)!

## Running the App

This demo uses Auth0 for authentication. To set it up follow the
[Convex Auth0](https://docs.convex.dev/auth/auth0) documentation. Instead of
hardcoding the `domain` and `clientId` in `_app.jsx` you can add them to the
`.env` file:

```
NEXT_PUBLIC_AUTH0_DOMAIN = "<your domain>.us.auth0.com"
NEXT_PUBLIC_AUTH0_CLIENT_ID = "<your client id>"
```

You can then run

```
npm install
npm run dev
```

Then navigate to http://localhost:3000 in your browser.



================================================
FILE: npm-packages/demos/nextjs-pages-router/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/node/README.md
================================================
# Using Convex with Node.js

Convex WebSocket and HTTP clients can be used from Node.js.

Node.js scripts can be used to automate administrative tasks and long-running
Node.js program or servers can monitor a query and take action whenever the
query results update.

## Using Convex with Node.js with codegen

If your JavaScript code uses import/export syntax, calling Convex functions
works just like in a browser.

```js
import { ConvexHttpClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";

const client = new ConvexHttpClient(CONVEX_URL_GOES_HERE);
client.query(api.messages.list).then(console.log);
```

_TypeScript_

If you use TypeScript to _compile_ your code (this is rare for web projects but
more common with Node.js), add `"allowJs": true` to tsconfig.json compiler
options so that TypeScript will compile the `api.js` file as well.

Just like bundling for the browser, bundling TypeScript code for Node.js with
webpack, esbuild, rollup, vite, and others usually allow you import from code
that uses import/export syntax with no extra setup.

_TypeScript with ESM without a compile step_

If you want to run your TypeScript script directly without a compile step,
installing [tsx](https://www.npmjs.com/package/tsx) and running your script with
tsx should work.

_CommonJS (require syntax)_

If you don't use `"type": "module"` in the package.json of your project you'll
need to use `require()` syntax and Node.js will not be able to import the
`convex/_generated/api.js` file directly.

In the same directory as your package.json, create or edit convex.json with

```json
{
  "generateCommonJSApi": true
}
```

When you run codegen (with `npx convex dev`) a new `api_cjs.cjs` file will be
created which can be imported from CommonJS code.

```js
const { ConvexHttpClient, ConvexClient } = require("convex/browser");
const { api } = require("./convex/_generated/api_cjs.cjs");
const httpClient = new ConvexHttpClient(CONVEX_URL_GOES_HERE);
```

_TypeScript with CommonJS without a compile step_

Follow the steps above for CommonJS and use
[`tsx`](https://www.npmjs.com/package/tsx) to run you code. Be sure your
tsconfig.json is configured for CommonJS output.

## Using Convex with Node.js without codegen

You can always use strings if you don't have the Convex functions and api file
handy. An api reference like `api.folder.file.exportName` becomes
`"folder/file:exportName"`.

## Running the App

First deploy the backend with `npx convex dev`.

Then try these scripts:

```
node script.js
node script.cjs
node tsx script-in-typescript.ts
```



================================================
FILE: npm-packages/demos/node/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/pagination/README.md
================================================
# Pagination Example App

This example demonstrates how to use
[Convex pagination](https://docs.convex.dev/using/pagination) to create a
paginated list of items.

This app is a paginated messages app. On the first load it will load the most
recent 5 messages and you can load more by clicking "Load More".

New messages will be added to the top page. To see the pagination in action, add
more then 5 messages and then refresh!

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/pagination/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/presence-facepile/README.md
================================================
# Presence: Facepile

This example app demonstrates how to use Convex for ephemeral data, in this case
to convey another user's presence with a user-selectable emoji in a "facepile".
It stores the "presence" data in a presence table, which it updates periodically
so other clients know it's active.

## `usePresence`

It can store arbitrary presence data using the
[`usePresence`](./src/hooks/usePresence.js) hook.

```js
const [myPresence, othersPresence, updateMyPresence] = usePresence(
  "chat-room",
  name,
  {
    name,
    emoji: initialEmoji,
  },
);
```

This hard-codes a single "room", but you could easily extend it to pass a chat
channel as the "room" to have presence per-channel.

It is using the user's name as the user identifier. To make this more secure,
you could use auth (see the "users-and-auth" demo) and not rely on passing the
user's identifier from the client.

### Updating Presence Data

In this case, it updates the user's emoji in a callback from a `<select>`:

```jsx
<select
    defaultValue={myPresence.emoji}
    onChange={e => updateMyPresence({ emoji: e.target.value })}
>
```

Note that this merges with the existing data, so `name` is unchanged.

### Using Presence Data

It uses the list of presence data for other users to show who is active on a
page. The user's data is excluded from this list.

```jsx
<FacePile othersPresence={othersPresence ?? []} />
```

Like the `useQuery` Convex hook, `othersPresence` will be `undefined` until it
receives the first response from Convex.

The `FacePile` will show old users as greyed out, and on hover will say when
they last updated.

The `usePresence` hook sends periodic "heartbeats" to bump "updated".

### `FacePile`

In order to keep the [`FacePile`](./src/Facepile.jsx) updated, it uses
`useState` for the time:

```js
const [now, setNow] = useState(Date.now());
useEffect(() => {
  const intervalId = setInterval(() => setNow(Date.now()), UPDATE_MS);
  return () => clearInterval(intervalId);
}, [setNow]);
```

It then uses `now` to determine which users are old:

```js
othersPresence.map((presence) => ({
  ...presence,
  old: presence.updated < now - OLD_MS,
}));
```

And sorts users & displays them as greyed out using that value.

### Under the hood

See [`usePresence`](./src/hooks/usePresence.js) for more details.

Presence data is merged, so you can update `{emoji}` in one place and `{name}`
elsewhere and the data will be sent up with the latest values of `emoji` and
`name`.

`usePresence` uses [`useSingleFlight`](./src/hooks/useSingleFlight.js) to
throttle its requests to the server, which means not all incremental updates
will be delivered, but the latest presence data will eventually be synced.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/presence-facepile/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/presence-typing-indicator/README.md
================================================
# Presence: Typing indicator

This example app demonstrates how to use Convex for ephemeral data, in this case
to convey another user's typing status. It stores the "presence" data in a
presence table, which it updates periodically so other clients know it's active.

## `usePresence`

It can store arbitrary presence data using the
[`usePresence`](./src/hooks/usePresence.js) hook.

```js
const [myPresence, othersPresence, updateMyPresence] = usePresence(
  "chat-room",
  name,
  { typing: false },
);
```

This hard-codes a single "room", but you could easily extend it to pass a chat
channel as the "room" to have presence per-channel.

Note: it ignores the first return argument, which is this user's presence data.
In this example, we don't need to know whether the user is typing.

### Updating Presence Data

In this case, it updates whether the user is typing with a `useEffect`:

```js
useEffect(() => {
  if (newMessageText.length === 0) {
    updateMyPresence({ typing: false });
    return;
  }
  updateMyPresence({ typing: true });
  const timer = setTimeout(() => updateMyPresence({ typing: false }), 1000);
  return () => clearTimeout(timer);
}, [updateMyPresence, newMessageText]);
```

It waits 1s after the last change to the message text to set `typing` to `false`
and sets it to `false` immediately when the text is empty (e.g. after sending a
text).

### Using Presence Data

It uses the list of presence data for other users to show who is typing. The
user's data is excluded from this list.

```jsx
(othersPresence ?? [])
  .filter(({ data, updated }) => data.typing && Date.now() - updated < OLD_MS)
  .map(({ user }) => (
    <li key={user}>
      <span>{user}</span>
      <span>
        <i>typing...</i>
      </span>
    </li>
  ));
```

Like the `useQuery` Convex hook, `othersPresence` will be `undefined` until it
receives the first response from Convex.

It filters to just users who are typing, and filters out users who haven't been
updated in a set amount of time, in case a user left the page before their timer
fired to set `typing` to `false`.

The `usePresence` hook sends periodic "heartbeats" to bump "updated".

### Under the hood

See [`usePresence`](./src/hooks/usePresence.js) for more details.

Presence data is merged, so you can update `{typing: true}` in one place and
`{other: data}` elsewhere and the data will be sent up with the latest values of
`typing` and `other`.

`usePresence` uses [`useSingleFlight`](./src/hooks/useSingleFlight.js) to
throttle its requests to the server, which means not all incremental updates
will be delivered, but the latest presence data will eventually be synced.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/presence-typing-indicator/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/prewarming/README.md
================================================
# TypeScript and Schemas Example App

This example demonstrates how to write a Convex app in
[TypeScript](https://docs.convex.dev/using/typescript).

The Convex functions are written in `.ts` files and the React components use
`.tsx`.

This app also defines a Convex
[schema](https://docs.convex.dev/database/schemas) in `convex/schema.ts` to
create TypeScript types specific to the app's data model.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/prewarming/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/python-quickstart/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/react-native/README.md
================================================
# React Native Example App

This example demonstrates how to use Convex with React Native.

This app is a messages app built using [Expo](https://expo.dev/) following the
[React Native Convex quickstart](https://docs.convex.dev/quickstart/react-native).

## Running the App

Install dependencies:

```
npm install
```

Set up a Convex dev deployment:

```
npx convex dev
```

Start the app:

```
npm start
```



================================================
FILE: npm-packages/demos/react-native/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/react-query/README.md
================================================
# TypeScript and Schemas Example App

This example demonstrates how to write a Convex app in
[TypeScript](https://docs.convex.dev/using/typescript).

The Convex functions are written in `.ts` files and the React components use
`.tsx`.

This app also defines a Convex
[schema](https://docs.convex.dev/database/schemas) in `convex/schema.ts` to
create TypeScript types specific to the app's data model.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/react-query/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/relational-data-modeling/README.md
================================================
# Relational Data Modeling Example App

This example demonstrates how to use Convex to create a relational data model.

It's a multi-channel message app. It has two tables: `channels` and `messages`.

Every message is associated with one channel. We create that association by
embedding a channel ID in every message.

Here is the resulting schema:

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  channels: defineTable({
    name: v.string(),
  }),
  messages: defineTable({
    author: v.string(),
    body: v.string(),
    channel: v.id("channels"),
  }),
});
```

You can see how this schema is used by inspecting the Convex functions in the
`convex/` directory.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/relational-data-modeling/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/scheduling/README.md
================================================
# Scheduling Example App

This app provides a basic example of how to use Convex scheduling. It allows the
user to type send a message, that get deleted in 5 seconds. The example builds
on the Convex
[tutorial](https://github.com/get-convex/convex/tree/main/npm-packages/demos/tutorial).

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/scheduling/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/search/README.md
================================================
# Search Example App

This example demonstrates how to use
[Convex full text search](https://docs.convex.dev/text-search) to add search to
an app.

In `schema.ts`, we define a search index on the `"messages"` table.
`searchMessages.js` uses this index to find all messages that match a search
query. This is all wired up to the front end in `App.jsx`.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/search/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/sessions/README.md
================================================
# Sessions Example App

This example demonstrates using a pattern to keep track of user sessions in a
database table to track per-tab or per-browser data, without being logged in.

It leverages [`convex-helpers`](https://www.npmjs.com/package/convex-helpers) in
[sessions.ts](./convex/lib/sessions.js) to wrap Convex
[functions](https://docs.convex.dev/using/writing-convex-functions) and
[useSession.ts](./src/useSession.ts) to wrap the `useQuery` and `useMutation`
hooks in React.

More detail can be found in the
[Stack post](https://stack.convex.dev/sessions-wrappers-as-middleware).

## Using sessions yourself:

1. In addition to a `ConvexProvider`, wrap your app with a `SessionProvider`:

   ```
   <ConvexProvider client={convex}>
     <SessionProvider>
       <App />
     </SessionProvider>
   </ConvexProvider>
   ```

2. Use `queryWithSession` to define your function:

   ```
   export const myQuery = queryWithSession({
     args: {},
     handler: async (ctx, args) => {
      console.log(ctx.session._id);
       ...
     },
   });
   ```

3. Use `useSessionQuery` in your React client:

   ```
   const messages = useSessionQuery(api.myModule.myQuery);
   ...
   ```

   Note: the same utilities are available for mutations & actions.

4. [Optional] Write any data that you want to be available in subsequent session
   requests to the `sessions` table :
   ```
   db.patch(session._id, { userId });
   ```

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/sessions/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/system-tables/README.md
================================================
# System Tables Example App

This example demonstrates how to use Convex system tables to programmatically
interact with file storage and scheduled functions.

This app is an extension of the Convex chat tutorial including a new button for
uploading images (stored with Convex file storage) and scheduling messages to
send in the future. Then, using the power of system tables, the app exposes an
admin-like interface over scheduled messages & stored files.

To learn more about these two system tables, see the
[File Storage](https://docs.convex.dev/using/file-storage) and
[Scheduled Functions](https://docs.convex.dev/scheduling/scheduled-functions)
documentation.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/system-tables/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/tour-chat/0-start/README.md
================================================
# Convex Tour Chat

This is a sample app used in the convex tutorial to show off the fundamentals of
the Convex platform.

[Go check out the tutorial](https://convex.dev/start)

Jump into any particular step of the tutorial with a branch:

1.  Simple chat app with message display order bug (branch = main, 0-start)
1.  Simple chat app with correct message display (branch = 1-smileys)
1.  Enhanced chat app a "likes" feature added (branch = 2-likes)
1.  Enhanced chat app with an AI integration (branch = 3-ai)

# To run

    $ npm i
    $ npm run dev



================================================
FILE: npm-packages/demos/tour-chat/0-start/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/tour-chat/1-smileys/README.md
================================================
# Convex Tour Chat

This is a sample app used in the convex tutorial to show off the fundamentals of
the Convex platform.

[Go check out the tutorial](https://convex.dev/start)

Jump into any particular step of the tutorial with a branch:

1.  Simple chat app with message display order bug (branch = main, 0-start)
1.  Simple chat app with correct message display (branch = 1-smileys)
1.  Enhanced chat app a "likes" feature added (branch = 2-likes)
1.  Enhanced chat app with an AI integration (branch = 3-ai)

# To run

    $ npm i
    $ npm run dev



================================================
FILE: npm-packages/demos/tour-chat/1-smileys/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/tour-chat/2-likes/README.md
================================================
# Convex Tour Chat

This is a sample app used in the convex tutorial to show off the fundamentals of
the Convex platform.

[Go check out the tutorial](https://convex.dev/start)

Jump into any particular step of the tutorial with a branch:

1.  Simple chat app with message display order bug (branch = main, 0-start)
1.  Simple chat app with correct message display (branch = 1-smileys)
1.  Enhanced chat app a "likes" feature added (branch = 2-likes)
1.  Enhanced chat app with an AI integration (branch = 3-ai)

# To run

    $ npm i
    $ npm run dev



================================================
FILE: npm-packages/demos/tour-chat/2-likes/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/tour-chat/3-ai/README.md
================================================
# Convex Tour Chat

This is a sample app used in the convex tutorial to show off the fundamentals of
the Convex platform.

[Go check out the tutorial](https://convex.dev/start)

Jump into any particular step of the tutorial with a branch:

1.  Simple chat app with message display order bug (branch = main, 0-start)
1.  Simple chat app with correct message display (branch = 1-smileys)
1.  Enhanced chat app a "likes" feature added (branch = 2-likes)
1.  Enhanced chat app with an AI integration (branch = 3-ai)

# To run

    $ npm i
    $ npm run dev



================================================
FILE: npm-packages/demos/tour-chat/3-ai/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/tutorial/README.md
================================================
# Convex tutorial

You're just a few minutes away from having a chat app powered by Convex.

Follow the tutorial at
[docs.convex.dev/tutorial](https://docs.convex.dev/tutorial) for instructions.



================================================
FILE: npm-packages/demos/tutorial/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/typescript/README.md
================================================
# TypeScript and Schemas Example App

This example demonstrates how to write a Convex app in
[TypeScript](https://docs.convex.dev/using/typescript).

The Convex functions are written in `.ts` files and the React components use
`.tsx`.

This app also defines a Convex
[schema](https://docs.convex.dev/database/schemas) in `convex/schema.ts` to
create TypeScript types specific to the app's data model.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/typescript/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/users-and-auth/README.md
================================================
# Users and Authentication Example App

This example demonstrates how to add users and authentication to a basic chat
app. It uses [Auth0](https://auth0.com/authentication) for authentication.

Users are initially presented with a "Log In" button. After user's log in, their
information is persisted to a `users` table. When users send messages, each
message is associated with the user that sent it. Lastly, users can log out with
a "Log Out" button.

## Running the App

Because this app uses authentication, it requires a bit of an additional setup.

Follow these instructions https://docs.convex.dev/auth/auth0 to set up Auth0
with Convex. You will have to update the client in `main.tsx` and the server in
`auth.config.ts`.



================================================
FILE: npm-packages/demos/users-and-auth/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/users-and-clerk/README.md
================================================
# Users and Authentication Example App

This example demonstrates how to add users and authentication to a basic chat
app. It uses [Clerk](https://clerk.dev/) for authentication.

Users are initially presented with a "Log In" button. After user's log in, their
information is persisted to a `users` table. When users send messages, each
message is associated with the user that sent it. Lastly, users can log out with
a "Log Out" button.

## Running the App

```sh
npm run dev
```

### Using your own Clerk instance

Follow the instructions in https://docs.convex.dev/auth/clerk#get-started to
obtain:

- A _publishable key_, use it in `main.tsx`
- A JWT template Issuer URL, use it in `auth.config.ts`.



================================================
FILE: npm-packages/demos/users-and-clerk/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/users-and-clerk-webhooks/README.md
================================================
# Users and Authentication Example App

This example demonstrates how to add users and authentication to a basic chat
app. It uses [Clerk](https://clerk.dev/) for authentication.

Users are initially presented with a "Log In" button. After user's sign up,
their information is persisted to a `users` table via a webhook. When users send
messages, each message is associated with the user that sent it. Lastly, users
can log out with a "Log Out" button.

## Running the App

Run

```sh
npm run dev
```

It will complain that an environment variable is missing. Follow the next steps
to set it.

### Set up Clerk credentials

Follow the instructions in https://docs.convex.dev/auth/clerk#get-started to
obtain:

- A _publishable key_, set it as `VITE_CLERK_PUBLISHABLE_KEY` in `.env.local`.
- A JWT template _Issuer URL_, set it as `CLERK_JWT_ISSUER_DOMAIN` on your
  Convex dashboard.

At this point you should see `npm run dev` succeed, but you still need to set up
one more variable.

### Setting up webhooks in Clerk

On your Clerk dashboard, go to _Webhooks_, click on _+ Add Endpoint_.

Set _Endpoint URL_ to
`https://<your deployment name>.convex.site/clerk-users-webhook`. You can see
your deployment name in `.env.local` in this directory. For example, the
endpoint URL could be:
`https://ardent-mammoth-732.convex.site/clerk-users-webhook`.

In _Message Filtering_, select **user** for all user events (scroll down or use
the search input).

Click on _Create_.

After the endpoint is saved, copy the _Signing Secret_ (on the right side of the
UI), it should start with `whsec_`. Set it as the value of the
`CLERK_WEBHOOK_SECRET` environment variable in your Convex dashboard.

From now on, when a user signs up you should see logs from the HTTP handler as
well as a new row in the users table in the Convex dashboard.

### Debugging webhooks

If your setup wasn't correct and you signed in already, Clerk will not sent
another user creation event to your webhook endpoint. To repeat the webhook flow
from initial sign up, go to the Clerk dashboard, click on _Users_, find your
user and delete it from the _..._ menu.



================================================
FILE: npm-packages/demos/users-and-clerk-webhooks/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/vector-search/README.md
================================================
# Vector Search Example App

This example demonstrates how to use
[Convex vector search](https://docs.convex.dev/vector-search).

It has a "Food search" and "Movie search". The "Food search" shows the simplest
way to set up a vector search, and matches the Convex
[documentation](https://docs.convex.dev/vector-search).

The "Movies search" shows some alternative pattens documented
[here](https://docs.convex.dev/vector-search#advanced-patterns).

## Running the App

### 1. Start dev

Run:

```
npm install
npm run dev
```

### 2. Add `OPENAI_KEY` variable

This app uses OpenAI to generate embeddings. Add `OPENAI_KEY`
[Convex environment variable](https://docs.convex.dev/production/environment-variables)
on your [Convex dashboard](https://dashboard.convex.dev/) with your OpenAI API
key.



================================================
FILE: npm-packages/demos/vector-search/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/demos/zod-validation-ts/README.md
================================================
# Zod and Schema Example App

This example demonstrates how to validate input and output arguments with the
[withZod](./convex/lib/withZod.ts) helper library, written in TypeScript.

See [this post](https://stack.convex.dev/wrappers-as-middleware-zod-validation)
for more details.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/demos/zod-validation-ts/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/docs/README.md
================================================
# Convex Docs

This website is built using [Docusaurus 2](https://docusaurus.io/), a modern
static website generator.

## Local Development

```sh
just rush install
npm run dev
```

This command starts a local dev server and opens up a browser window. Most
changes are reflected live without having to restart the server.

If you make changes to the `convex` NPM package and want to see them reflected
in API docs, run `just rush build -t convex` and restart the server.

The command runs `npm run dev`, which will not run all checks in our presubmits.
For example, broken links are not checked. To view all errors, try building and
testing:

```sh
npm run test
npm run build
```

## llms.txt

This is a file that was manually generated using Firecrawl:
https://www.firecrawl.dev/blog/How-to-Create-an-llms-txt-File-for-Any-Website

You need to get an API key from Firecrawl and follow the instructions on that
blog post above.

I then did a few manual edits:

- Removed all Google Analytics references (simple regex find and replace)
- Put the home page text at the top
- Cleaned up youtube embeds output they were pretty messy.

Otherwise it generated reasonably decent output. We should eventually make this
more automated with every publish.

See
[here](https://linear.app/convex/issue/DX-1412/create-an-llmstxt-file-for-the-website-and-docs-page).
For the full background.

## Spell-checking in VS Code

You can enable spell checking in VS Code by installing
[Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker).

## Build

```sh
npm run build
```

This command generates static content into the `build` directory and can be
served using any static contents hosting service.

## Deploying to production

See [here](/ops/services/docs/release.md).

## Preview Deployment

See [here](/ops/services/docs/release.md#preview-deployment).

## Updating the Component docs

The Component docs are in the /docs folder of the Components that we keep in
sync. For example, https://github.com/get-convex/component/tree/main/docs To
update them, run the following command in this directory:

```sh
node scripts/pull-component-docs.js
```

This will pull the latest docs from the `main` branch and update the docs
directory, doing some replacing of relative links back to the original repo for
code snippets.

This is a manual process and generally only needs to be done when the component
docs change and there is a new release of the component package.

# Dependency notes

Typedoc plugins don't seem to work in our monorepo with Rush: they only work
when installed from npm.

We needed to update a couple, so we forked them at
https://github.com/get-convex/typedoc-plugin-markdown

Iterating on typedoc plugins is rough, typedoc implements their own module
resolution such that our rush/pnpm solution doesn't work. So to iterate I

1. cloned our typedoc-plugin-markdown fork and set a globalOverride in
   rush/pnpm-config.json
2. make changes there and did a build with yarn run build
3. removed the dependency from dashboard's package.json
4. just rush update
5. re-added the dependency to dashboard's package.json
6. just rush update
7. repeat from 2.
8. remove the globalOverridel, increment the typedoc-plugin-markdown version
   number and publish, and update docs package.json deps



================================================
FILE: npm-packages/docs/docs/_betaAdmonition.mdx
================================================
<Admonition type="caution" title={`${props.feature} ${props.verb} in beta`}>
  {props.feature} {props.verb} currently a [beta
  feature](/production/state/#beta-features). If you have feedback or feature
  requests, [let us know on Discord](https://convex.dev/community)!
</Admonition>



================================================
FILE: npm-packages/docs/docs/_betaContactUsAdmonition.mdx
================================================
<Admonition type="caution" title={`${props.feature} ${props.verb} in beta`}>
  {props.feature} {props.verb} currently in an early access
  [beta](/production/state/#beta-features). For access, contact us [on
  Discord](https://convex.dev/community) or by email at
  [support@convex.dev](mailto:support@convex.dev)!
</Admonition>



================================================
FILE: npm-packages/docs/docs/_convexValues.mdx
================================================
Convex supports the following types of values:

<div className="convex-full-width">

| Convex Type | TS/JS Type                                                                                                                   | <div style={{width: "11em"}}>Example Usage</div> | Validator for [Argument Validation](/functions/validation) and [Schemas](/database/schemas) | `json` Format for [Export](/database/import-export) | Notes                                                                                                                                                                                                                                                                                                                                                  |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------- | --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Id          | [Id](/database/document-ids) ([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#string_type)) | `doc._id`                                        | `v.id(tableName)`                                                                           | string                                              | See [Document IDs](/database/document-ids).                                                                                                                                                                                                                                                                                                            |
| Null        | [null](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#null_type)                                    | `null`                                           | `v.null()`                                                                                  | null                                                | JavaScript's `undefined` is not a valid Convex value. Functions the return `undefined` or do not return will return `null` when called from a client. Use `null` instead.                                                                                                                                                                              |
| Int64       | [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#bigint_type)                                | `3n`                                             | `v.int64()`                                                                                 | string (base10)                                     | Int64s only support BigInts between -2^63 and 2^63-1. Convex supports `bigint`s in [most modern browsers](https://caniuse.com/bigint).                                                                                                                                                                                                                 |
| Float64     | [number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#number_type)                                | `3.1`                                            | `v.number()`                                                                                | number / string                                     | Convex supports all IEEE-754 double-precision floating point numbers (such as NaNs). Inf and NaN are JSON serialized as strings.                                                                                                                                                                                                                       |
| Boolean     | [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#boolean_type)                              | `true`                                           | `v.boolean()`                                                                               | bool                                                |
| String      | [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#string_type)                                | `"abc"`                                          | `v.string()`                                                                                | string                                              | Strings are stored as UTF-8 and must be valid Unicode sequences. Strings must be smaller than the 1MB total size limit when encoded as UTF-8.                                                                                                                                                                                                          |
| Bytes       | [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)                  | `new ArrayBuffer(8)`                             | `v.bytes()`                                                                                 | string (base64)                                     | Convex supports first class bytestrings, passed in as `ArrayBuffer`s. Bytestrings must be smaller than the 1MB total size limit for Convex types.                                                                                                                                                                                                      |
| Array       | [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)                              | `[1, 3.2, "abc"]`                                | `v.array(values)`                                                                           | array                                               | Arrays can have at most 8192 values.                                                                                                                                                                                                                                                                                                                   |
| Object      | [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#objects)                                    | `{a: "abc"}`                                     | `v.object({property: value})`                                                               | object                                              | Convex only supports "plain old JavaScript objects" (objects that do not have a custom prototype). Convex includes all [enumerable properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties). Objects can have at most 1024 entries. Field names must be nonempty and not start with "$" or "\_". |
| Record      | [Record](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)                                    | `{"a": "1", "b": "2"}`                           | `v.record(keys, values)`                                                                    | object                                              | Records are objects at runtime, but can have dynamic keys. Keys must be only ASCII characters, nonempty, and not start with "$" or "\_".                                                                                                                                                                                                               |

</div>



================================================
FILE: npm-packages/docs/docs/_proFeatureUpsell.mdx
================================================
<Admonition
  type="info"
  title={`${props.feature} ${props.verb} a Convex Pro plan.`}
>
  {props.feature} {props.verb} a Convex Pro plan. [Learn
  more](https://convex.dev/pricing) about our plans or
  [upgrade](https://dashboard.convex.dev/team/settings/billing).
</Admonition>



================================================
FILE: npm-packages/docs/docs/agents.mdx
================================================
---
title: "AI Agents"
sidebar_position: 100
description: "Building AI Agents with Convex"
---

## Building AI Agents with Convex

Convex provides powerful building blocks for building agentic AI applications,
leveraging Components and existing Convex features.

With Convex, you can separate your long-running agentic workflows from your UI,
without the user losing reactivity and interactivity. The message history with
an LLM is persisted by default, live updating on every client, and easily
composed with other Convex features using code rather than configuration.

## Agent Component

The Agent component is a core building block for building AI agents. It manages
threads and messages, around which your Agents can cooperate in static or
dynamic workflows.

<div className="center-image" style={{ maxWidth: "560px" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/tUKMPUlOCHY?si=ce-M8pt6EWDZ8tfd"
    title="Agent Component YouTube Video"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>
[Agent Component YouTube
Video](https://www.youtube.com/embed/tUKMPUlOCHY?si=ce-M8pt6EWDZ8tfd)

### Core Concepts

- Agents organize LLM prompting with associated models, prompts, and
  [Tools](/agents/tools). They can generate and stream both text and objects.
- Agents can be used in any Convex action, letting you write your agentic code
  alongside your other business logic with all the abstraction benefits of using
  code rather than static configuration.
- [Threads](/agents/threads) persist [messages](/agents/messages) and can be
  shared by multiple users and agents (including
  [human agents](/agents/human-agents)).
- [Conversation context](/agents/context) is automatically included in each LLM
  call, including built-in hybrid vector/text search for messages.

### Advanced Features

- [Workflows](/agents/workflows) allow building multi-step operations that can
  span agents, users, durably and reliably.
- [RAG](/agents/rag) techniques are also supported for prompt augmentation
  either up front or as tool calls using the
  [RAG Component](https://www.convex.dev/components/rag).
- [Files](/agents/files) can be used in the chat history with automatic saving
  to [file storage](/file-storage).

### Debugging and Tracking

- [Debugging](/agents/debugging) is supported, including the
  [agent playground](/agents/playground) where you can inspect all metadata and
  iterate on prompts and context settings.
- [Usage tracking](/agents/usage-tracking) enables usage billing for users and
  teams.
- [Rate limiting](/agents/rate-limiting) helps control the rate at which users
  can interact with agents and keep you from exceeding your LLM provider's
  limits.

<CardLink
  className="convex-hero-card"
  item={{
    href: "/agents/getting-started",
    label: "Build your first Agent",
  }}
/>

Learn more about the motivation by reading:
[AI Agents with Built-in Memory](https://stack.convex.dev/ai-agents).

Sample code:

```typescript
import { Agent } from "@convex-dev/agents";
import { openai } from "@ai-sdk/openai";
import { components } from "./_generated/api";
import { action } from "./_generated/server";

// Define an agent
const supportAgent = new Agent(components.agent, {
  name: "Support Agent",
  chat: openai.chat("gpt-4o-mini"),
  instructions: "You are a helpful assistant.",
  tools: { accountLookup, fileTicket, sendEmail },
});

// Use the agent from within a normal action:
export const createThread = action({
  args: { prompt: v.string() },
  handler: async (ctx, { prompt }) => {
    const { threadId, thread } = await supportAgent.createThread(ctx);
    const result = await thread.generateText({ prompt });
    return { threadId, text: result.text };
  },
});

// Pick up where you left off, with the same or a different agent:
export const continueThread = action({
  args: { prompt: v.string(), threadId: v.string() },
  handler: async (ctx, { prompt, threadId }) => {
    // This includes previous message history from the thread automatically.
    const { thread } = await anotherAgent.continueThread(ctx, { threadId });
    const result = await thread.generateText({ prompt });
    return result.text;
  },
});
```



================================================
FILE: npm-packages/docs/docs/ai.mdx
================================================
---
title: AI Code Generation
hide_table_of_contents: true
description: "How to use AI code generation effectively with Convex"
---

<CardLink
  className="convex-hero-card"
  item={{
    href: "https://chef.convex.dev",
    label: "Prompt to build an app with Convex Chef",
  }}
/>

Convex is designed around a small set of composable abstractions with strong
guarantees that result in code that is not only faster to write, but easier to
read and maintain, whether written by a team member or an LLM. Key features make
sure you get bug-free AI generated code:

1. **Queries are Just TypeScript** Your database queries are pure TypeScript
   functions with end-to-end type safety and IDE support. This means AI can
   generate database code using the large training set of TypeScript code
   without switching to SQL.
1. **Less Code for the Same Work** Since so much infrastructure and boiler plate
   is automatically managed by Convex there is less code to write, and thus less
   code to get wrong.
1. **Automatic Reactivity** The reactive system automatically tracks data
   dependencies and updates your UI. AI doesn't need to manually manage
   subscriptions, WebSocket connections, or complex state synchronization—Convex
   handles all of this automatically.
1. **Transactional Guarantees** Queries are read-only and mutations run in
   transactions. These constraints make it nearly impossible for AI to write
   code that could corrupt your data or leave your app in an inconsistent state.

Together, these features mean AI can focus on your business logic while Convex's
guarantees prevent common failure modes. For up-to-date information on which
models work best with Convex, check out our LLM
[leaderboard](https://convex.dev/llm-leaderboard).

## Convex AI rules

AI code generation is most effective when you provide it with a set of rules to
follow.

See these documents for install instructions:

- [Cursor](/ai/using-cursor.mdx#add-convex-cursorrules)
- [Windsurf](/ai/using-windsurf.mdx#add-convex-rules)
- [GitHub Copilot](/ai/using-github-copilot.mdx#add-convex-instructions)

For all other IDEs, add the following rules file to your project and refer to it
when prompting for changes:

- [convex_rules.txt](https://convex.link/convex_rules.txt)

We're constantly working on improving the quality of these rules for Convex by
using rigorous evals. You can help by
[contributing to our evals repo](https://github.com/get-convex/convex-evals).

## Using Convex with Background Agents

Remote cloud-based coding agents like Jules, Devin, Codex, and Cursor background
agents can use Convex deployments when the CLI is in
[Agent Mode](/docs/cli/background-agents.mdx). This limits the permissions
necessary for these remote dev environments while letting agents run codegen,
iterate on code, run tests, run one-off functions.

A good setup script for e.g. ChatGPT Codex might include

```
npm i
CONVEX_AGENT_MODE=anonymous npx convex dev --once
```

or

```
bun i
CONVEX_AGENT_MODE=anonymous bun x convex dev --once
```

This command requires "full" internet access to download the binary.

## Convex MCP Server

[Setup the Convex MCP server](/ai/convex-mcp-server.mdx) to give your AI coding
agent access to your Convex deployment to query and optimize your project.



================================================
FILE: npm-packages/docs/docs/auth.mdx
================================================
---
title: Authentication
sidebar_position: 30
description: Add authentication to your Convex app.
hide_table_of_contents: true
pagination_prev: file-storage
---

Convex deployment endpoints are exposed to the open internet and the claims
clients make about who they are must be authenticated to identify users and
restrict what data they can see and edit.

Convex is compatible with most authentication providers because it uses OpenID
Connect (based on OAuth) ID tokens in the form of JWTs to authenticate WebSocket
connections or RPCs. These JWTs can be provided by any service (including your
own Convex backend) that implement the appropriate OAuth endpoints to verify
them.

## Third-party authentication platforms

Leveraging a Convex integration with a third-party auth provider provides the
most comprehensive authentication solutions. Integrating another service
provides a ton of functionality like passkeys, two-factor auth, spam protection,
and more on top of the authentication basics.

- [Clerk](/auth/clerk.mdx) has great Next.js and React Native support
- [WorkOS AuthKit](/auth/authkit/index.mdx) is built for B2B apps and free for
  up to 1M users
- [Auth0](/auth/auth0.mdx) is more established with more bells and whistles
- [Custom Auth Integration](/auth/advanced/custom-auth.mdx) allow any OpenID
  Connect-compatible identity provider to be used for authentication

After you integrate one of these, learn more about accessing authentication
information in [Functions](/auth/functions-auth.mdx) and storing user
information in the [Database](/auth/database-auth.mdx).

## The Convex Auth Library

For client-side React and React Native mobile apps you can implement auth
directly in Convex with the [Convex Auth](/auth/convex-auth.mdx) library. This
[npm package](https://github.com/get-convex/convex-auth) runs on your Convex
deployment and helps you build a custom sign-up/sign-in flow via social identity
providers, one-time email or SMS access codes, or via passwords.

Convex Auth is in beta (it isn't complete and may change in
backward-incompatible ways) and doesn't provide as many features as third party
auth integrations. Since it doesn't require signing up for another service it's
the quickest way to get auth up and running.

<BetaAdmonition feature="Convex Auth" verb="is" />

Support for Next.js is under active development. If you'd like to help test this
experimental support please [give it a try](https://labs.convex.dev/auth)!

## Debugging

If you run into issues consult the [Debugging](/auth/debug.mdx) guide.

## Service Authentication

Servers you control or third party services can call Convex functions but may
not be able to obtain OpenID JWTs and often do not represent the actions of a
specific user.

Say you're running some inference on a [Modal](https://modal.com/) server
written in Python. When that server subscribes to a Convex query it doesn't do
so with credentials of a particular end-user, rather it's looking for relevant
tasks for any users that need that inference task, say summarizing and
translating a conversation, completed.

To provide access to Convex queries, mutations, and actions to an external
service you can write public functions accessible to the internet that check a
shared secret, for example from an environment variable, before doing anything
else.

## Authorization

Convex enables a traditional three tier application structure: a client/UI for
your app, a backend that handles user requests, and a database for queries. This
architecture lets you check every public request against any authorization rules
you can define in code.

This means Convex doesn't need an opinionated authorization framework like RLS,
which is required in client oriented databases like Firebase or Supabase. This
flexibility lets you build and use an
[authorization framework](https://en.wikipedia.org/wiki/Authorization) for your
needs.

That said, the most common way is to simply write code that checks if the user
is logged in and if they are allowed to do the requested action at the beginning
of each public function.

For example, the following function enforces that only the currently
authenticated user can remove their own user image:

```typescript
export const removeUserImage = mutation({
  args: {},
  handler: async (ctx) => {
    // highlight-next-line
    const userId = await getAuthUserId(ctx);
    // highlight-next-line
    if (!userId) {
      // highlight-next-line
      return;
      // highlight-next-line
    }
    ctx.db.patch("users", userId, { imageId: undefined, image: undefined });
  },
});
```

<StackPosts query="authentication" />



================================================
FILE: npm-packages/docs/docs/chef.mdx
================================================
---
title: Chef
description: "How to use Chef by Convex"
---

Chef is an AI app builder that builds complex full-stack apps. It leverages the
full power of the Convex platform to one-shot apps like Slack, Instagram, and
Notion.

This means Chef can: build real-time apps, upload files, do text search and take
advantage of Convex Components.

<CardLink
  className="convex-hero-card"
  item={{
    href: "https://chef.convex.dev",
    label: "Prompt to start an app with Convex Chef",
  }}
/>

<div className="center-image" style={{ maxWidth: "500px" }}>
  ![Chef Screenshot](/screenshots/chef_preview.png)
</div>

## Deploying to production

Chef does have a built in ability to deploy the dev version of your app for you
to immediately share with your friends to try.

For apps intended to be built and maintained over the long term, we recommend
downloading the code and importing it into your preferred IDE. When you download
the code from Chef, your project automatically comes with
[Cursor rules for Convex](/ai.mdx), helping you keep coding with confidence.

### Download the code

<div className="center-image" style={{ maxWidth: "700px" }}>
  ![Chef Screenshot](/screenshots/chef_download.png)
</div>

At the top right of the Chef UI there is a download code button. Download the
code and you’ll get a zip file.

Unzip the file and put the folder in your desired location. We recommend
renaming the folder to the name of your app for convenience. For the rest of the
setup, open up the terminal and `cd` into your app:

```bash
cd ~/<app folder>
```

### Install dependencies

Run the following command to install all dependencies for your project

```bash
npm i
```

### Run your app

Run the following command run your app, and setup Convex if you haven’t already.

```bash
npm run dev
```

Follow any instructions to login to Convex from your machine.

<Admonition type="caution">
  You have now taken over from Chef for development of this app. Chef doesn't
  have the ability to re-import a project or track any progress from outside it.
  Going back to this project on Chef will cause conflicts in your project.
</Admonition>

### Set up the frontend build script

Chef projects don’t come with a build script. So make sure to add the following
to your `package.json` file:

```tsx
  "scripts": {
		//... other scripts
    "build": "vite build"
  },
```

### Recommended: Setup Git

In the terminal run the following three commands setup git for your app. The
downloaded code comes with a `.gitignore` file.

```bash
git init
git add --all
git commit -m "Initial commit"
```

It's also recommended you setup a remote git repository with
[GitHub](https://github.com/) if you're going to use the production hosting
guides below.

### Set up production frontend hosting

Follow one of the Convex [hosting guides](/production/hosting/hosting.mdx) to
set up frontend hosting and continuous deployment of your frontend and backend
code.

### Initialize Convex Auth for Prod

Once you have a production deployment. You need to
[set up Convex Auth for production](https://labs.convex.dev/auth/production).

## Integrations

### OpenAI

If you ask Chef to use AI, by default it will try to use the built in OpenAI
proxy with a limited number of calls. This helps you prototype your AI app idea
quickly.

However, at some point the built in number of calls will run out and you'll need
to provide your own OpenAI API Key and remove the proxy URL.

So that means you'll have to find the code that looks like this:

```typescript
const openai = new OpenAI({
  baseURL: process.env.CONVEX_OPENAI_BASE_URL,
  apiKey: process.env.CONVEX_OPENAI_API_KEY,
});
```

And remove the baseURL parameter:

```typescript
const openai = new OpenAI({
  apiKey: process.env.CONVEX_OPENAI_API_KEY,
});
```

Chef may automatically prompt you to change the environment variable. But if it
doesn't, you can change it by going to the "Database" tab. Then click on
Settings > Environment Variables and change `CONVEX_OPENAI_API_KEY` to your
[personal OpenAI key](https://platform.openai.com).

We plan on making this transition better over time.

### Resend

Chef comes with a built in way to send emails to yourself via Resend. You can
only send emails to the account you used to log into Chef. To send emails to
anyone, you have to setup your app for production with a domain name. This is a
limitation of how email providers work to combat spam.

## FAQs

### What browsers does Chef support?

Chef is best used on desktop/laptop browsers. It may work on some tablet or
mobile browsers. Chef does not work in Safari on any platform.

### How does the pricing for Chef work?

Chef pricing is primarily based on AI token usage. The free plan gives you
enough tokens to build the first version of your app in a small number of
prompts. After that you can upgrade to the Starter plan that where you can pay
for tokens as you go.

### What’s the difference between Chef and Convex?

Chef is an AI app builder that builds full-stack apps. Convex is the backend and
database that powers Chef.

### Can I import my existing app to Chef?

Chef currently doesn’t have import and GitHub integration. But you can get most
of the value by setting up the [Convex AI Rules and MCP server](/ai.mdx) in your
Agentic IDE like Cursor.

### Are there any best practices for Chef?

Yes! Check out this
[tips post written by one of our engineers](https://stack.convex.dev/chef-cookbook-tips-working-with-ai-app-builders).

### What Convex Components can Chef use?

Chef can use the
[collaborative text editor](https://www.convex.dev/components/prosemirror-sync)
component and the [presence](https://www.convex.dev/components/presence)
component. We will support more components soon. Chef supports all other Convex
features like text search, file storage, etc.

## Limitations

Chef works off a singular template with Convex, Convex Auth and React powered by
Vite. Switching these technologies is not supported by Chef.



================================================
FILE: npm-packages/docs/docs/cli.md
================================================
---
title: "CLI"
sidebar_position: 110
slug: "cli"
description: "Command-line interface for managing Convex projects and functions"
---

The Convex command-line interface (CLI) is your interface for managing Convex
projects and Convex functions.

To install the CLI, run:

```sh
npm install convex
```

You can view the full list of commands with:

```sh
npx convex
```

## Configure

### Create a new project

The first time you run

```sh
npx convex dev
```

it will ask you to log in your device and create a new Convex project. It will
then create:

1. The `convex/` directory: This is the home for your query and mutation
   functions.
2. `.env.local` with `CONVEX_DEPLOYMENT` variable: This is the main
   configuration for your Convex project. It is the name of your development
   deployment.

### Recreate project configuration

Run

```sh
npx convex dev
```

in a project directory without a set `CONVEX_DEPLOYMENT` to configure a new or
existing project.

### Log out

```sh
npx convex logout
```

Remove the existing Convex credentials from your device, so subsequent commands
like `npx convex dev` can use a different Convex account.

## Develop

### Run the Convex dev server

```sh
npx convex dev
```

Watches the local filesystem. When you change a [function](/functions.mdx) or
the [schema](/database/schemas.mdx), the new versions are pushed to your dev
deployment and the [generated types](/generated-api/) in `convex/_generated` are
updated. By default, logs from your dev deployment are displayed in the
terminal.

It's also possible to
[run a Convex deployment locally](/cli/local-deployments-for-dev.mdx) for
development.

### Open the dashboard

```sh
npx convex dashboard
```

Open the [Convex dashboard](./dashboard).

### Open the docs

```sh
npx convex docs
```

Get back to these docs!

### Run Convex functions

```sh
npx convex run <functionName> [args]
```

Run a public or internal Convex query, mutation, or action on your development
deployment.

Arguments are specified as a JSON object.

```sh
npx convex run messages:send '{"body": "hello", "author": "me"}'
```

Add `--watch` to live update the results of a query. Add `--push` to push local
code to the deployment before running the function.

Use `--prod` to run functions in the production deployment for a project.

### Tail deployment logs

You can choose how to pipe logs from your dev deployment to your console:

```sh
# Show all logs continuously
npx convex dev --tail-logs always

# Pause logs during deploys to see sync issues (default)
npx convex dev

# Don't display logs while developing
npx convex dev --tail-logs disable

# Tail logs without deploying
npx convex logs
```

Use `--prod` with `npx convex logs` to tail the prod deployment logs instead.

### Import data from a file

```sh
npx convex import --table <tableName> <path>
npx convex import <path>.zip
```

See description and use-cases:
[data import](/database/import-export/import.mdx).

### Export data to a file

```sh
npx convex export --path <directoryPath>
npx convex export --path <filePath>.zip
npx convex export --include-file-storage --path <path>
```

See description and use-cases:
[data export](/database/import-export/export.mdx).

### Display data from tables

```sh
npx convex data  # lists tables
npx convex data <table>
```

Display a simple view of the
[dashboard data page](/dashboard/deployments/data.md) in the command line.

The command supports `--limit` and `--order` flags to change data displayed. For
more complex filters, use the dashboard data page or write a
[query](/database/reading-data/reading-data.mdx).

The `npx convex data <table>` command works with
[system tables](/database/advanced/system-tables.mdx), such as `_storage`, in
addition to your own tables.

### Read and write environment variables

```sh
npx convex env list
npx convex env get <name>
npx convex env set <name> <value>
npx convex env remove <name>
```

See and update the deployment environment variables which you can otherwise
manage on the dashboard
[environment variables settings page](/dashboard/deployments/settings.md#environment-variables).

## Deploy

### Deploy Convex functions to production

```sh
npx convex deploy
```

The target deployment to push to is determined like this:

1. If the `CONVEX_DEPLOY_KEY` environment variable is set (typical in CI), then
   it is the deployment associated with that key.
2. If the `CONVEX_DEPLOYMENT` environment variable is set (typical during local
   development), then the target deployment is the production deployment of the
   project that the deployment specified by `CONVEX_DEPLOYMENT` belongs to. This
   allows you to deploy to your prod deployment while developing against your
   dev deployment.

This command will:

1. Run a command if specified with `--cmd`. The command will have CONVEX_URL (or
   similar) environment variable available:
   ```sh
   npx convex deploy --cmd "npm run build"
   ```
   You can customize the URL environment variable name with
   `--cmd-url-env-var-name`:
   ```sh
   npx convex deploy --cmd 'npm run build' --cmd-url-env-var-name CUSTOM_CONVEX_URL
   ```
1. Typecheck your Convex functions.
1. Regenerate the [generated code](/generated-api/) in the `convex/_generated`
   directory.
1. Bundle your Convex functions and their dependencies.
1. Push your functions, [indexes](/database/reading-data/indexes/indexes.md),
   and [schema](/database/schemas.mdx) to production.

Once this command succeeds the new functions will be available immediately.

### Deploy Convex functions to a [preview deployment](/production/hosting/preview-deployments.mdx)

```sh
npx convex deploy
```

When run with the `CONVEX_DEPLOY_KEY` environment variable containing a
[Preview Deploy Key](docs/cli/deploy-key-types.mdx#deploying-to-preview-deployments),
this command will:

1. Create a new Convex deployment. `npx convex deploy` will infer the Git branch
   name for Vercel, Netlify, GitHub, and GitLab environments, or the
   `--preview-create` option can be used to customize the name associated with
   the newly created deployment.
   ```
   npx convex deploy --preview-create my-branch-name
   ```
1. Run a command if specified with `--cmd`. The command will have CONVEX_URL (or
   similar) environment variable available:

   ```sh
   npx convex deploy --cmd "npm run build"
   ```

   You can customize the URL environment variable name with
   `--cmd-url-env-var-name`:

   ```sh
   npx convex deploy --cmd 'npm run build' --cmd-url-env-var-name CUSTOM_CONVEX_URL
   ```

1. Typecheck your Convex functions.
1. Regenerate the [generated code](/generated-api/) in the `convex/_generated`
   directory.
1. Bundle your Convex functions and their dependencies.
1. Push your functions, [indexes](/database/reading-data/indexes/indexes.md),
   and [schema](/database/schemas.mdx) to the deployment.
1. Run a function specified by `--preview-run` (similar to the `--run` option
   for `npx convex dev`).

   ```sh
   npx convex deploy --preview-run myFunction
   ```

See the [Vercel](/production/hosting/vercel.mdx#preview-deployments) or
[Netlify](/production/hosting/netlify.mdx#deploy-previews) hosting guide for
setting up frontend and backend previews together.

### Update generated code

```sh
npx convex codegen
```

The [generated code](/generated-api/) in the `convex/_generated` directory
includes types required for a TypeScript typecheck. This code is generated
whenever necessary while running `npx convex dev` and this code should be
committed to the repo (your code won't typecheck without it!).

In the rare cases it's useful to regenerate code (e.g. in CI to ensure that the
correct code was checked it) you can use this command.

Generating code can require communicating with a convex deployment in order to
evaluate configuration files in the Convex JavaScript runtime. This doesn't
modify the code running on the deployment.



================================================
FILE: npm-packages/docs/docs/components.mdx
================================================
---
title: "Components"
description: "Self contained building blocks of your app"
pagination_prev: search
---

import { LargeCardList } from "@site/src/QuickstartsList.tsx";

<span className="convex-hero">
  Convex Components package up code and data in a sandbox that allows you to
  confidently and quickly add new features to your backend.
</span>

Convex Components are like mini self-contained Convex backends, and installing
them is always safe. They can't read your app's tables or call your app's
functions unless you pass them in explicitly.

You can read about the full vision in
[Convex: The Software-Defined Database](https://stack.convex.dev/the-software-defined-database#introducing-convex-components).

Components can be installed from NPM or from a local folder. Once installed,
they have their own database tables and isolated function execution environment.
Check out the full directory of components on the
[Convex website](https://convex.dev/components).

<LargeCardList
  items={[
    {
      title: "Understanding components",
      description:
        "Explore the concepts behind and build a mental model for how components work.",
      href: "/components/understanding",
    },
    {
      title: "Using components",
      description:
        "Learn about useful components and how to use them in your application.",
      href: "/components/using",
    },
    {
      title: "Authoring components",
      description: "Learn how to write and publish a component.",
      href: "/components/authoring",
    },
    {
      title: "Components Directory",
      description: "List of all components.",
      href: "https://convex.dev/components",
    },
  ]}
/>



================================================
FILE: npm-packages/docs/docs/dashboard.md
================================================
---
title: "Dashboard"
id: "dashboard"
description: "Learn how to use the Convex dashboard"
---

![Dashboard Projects View](/screenshots/projects.png)

[The dashboard](https://dashboard.convex.dev/) is the central hub for managing
your Convex projects. Here you can create and manage your Convex teams,
projects, and deployments.



================================================
FILE: npm-packages/docs/docs/database.mdx
================================================
---
title: "Database"
description: "Store JSON-like documents with a relational data model"
hide_table_of_contents: true
pagination_prev: functions
---

The Convex database provides a relational data model, stores JSON-like
documents, and can be used with or without a schema. It "just works," giving you
predictable query performance in an easy-to-use interface.

Query and mutation [functions](/functions.mdx) read and write data through a
lightweight JavaScript API. There is nothing to set up and no need to write any
SQL. Just use JavaScript to express your app's needs.

Start by learning about the basics of [tables](#tables), [documents](#documents)
and [schemas](#schemas) below, then move on to
[Reading Data](/database/reading-data/reading-data.mdx) and
[Writing Data](/database/writing-data.mdx).

As your app grows more complex you'll need more from your database:

- Relational data modeling with [Document IDs](/database/document-ids.mdx)
- Fast querying with [Indexes](/database/reading-data/indexes/indexes.md)
- Exposing large datasets with [Paginated Queries](/database/pagination.mdx)
- Type safety by [Defining a Schema](/database/schemas.mdx)
- Interoperability with data
  [Import & Export](docs/database/import-export/import-export.mdx)

## Tables

Your Convex deployment contains tables that hold your app's data. Initially,
your deployment contains no tables or documents.

Each table springs into existence as soon as you add the first document to it.

```javascript
// `friends` table doesn't exist.
await ctx.db.insert("friends", { name: "Jamie" });
// Now it does, and it has one document.
```

You do not have to specify a schema upfront or create tables explicitly.

## Documents

Tables contain documents. Documents are very similar to JavaScript objects. They
have fields and values, and you can nest arrays or objects within them.

These are all valid Convex documents:

```json
{}
{"name": "Jamie"}
{"name": {"first": "Ari", "second": "Cole"}, "age": 60}
```

They can also contain references to other documents in other tables. See
[Data Types](/database/types.md) to learn more about the types supported in
Convex and [Document IDs](/database/document-ids.mdx) to learn about how to use
those types to model your data.

## Schemas

Though optional, schemas ensure that your data looks exactly how you want. For a
simple chat app, the schema will look like this:

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

// @snippet start schema
export default defineSchema({
  messages: defineTable({
    author: v.id("users"),
    body: v.string(),
  }),
});
```

You can choose to be as flexible as you want by using types such as `v.any()` or
as specific as you want by precisely describing a `v.object()`.

See [the schema documentation](/database/schemas.mdx) to learn more about
schemas.

<CardLink
  className="convex-hero-card"
  item={{
    href: "/database/reading-data",
    docId: "database/reading-data/reading-data",
    label: "Next: Reading Data",
  }}
/>

<StackPosts query="database" />



================================================
FILE: npm-packages/docs/docs/deployment-api.mdx
================================================
---
title: Deployment API
hide_table_of_contents: true
description: "Deployment API"
---

The public interface of a Convex deployment is defined by the functions defined
in files in a convex folder.

The public HTTP endpoints of every Convex deployment consist of custom HTTP
endpoints defined by [HTTP Actions](docs/functions/http-actions.mdx) and a
static [public HTTP API](/docs/http-api/index.md).

Deployments also provide private endpoints only for the administrators of that
deployment:

- [Streaming export API](/docs/streaming-export-api.mdx)
- [Streaming import API](/docs/streaming-import-api.mdx)
- [Platform APIs](/docs/deployment-platform-api.mdx)



================================================
FILE: npm-packages/docs/docs/deployment-platform-api.mdx
================================================
---
title: Deployment Platform API
hide_table_of_contents: true
description: "Deployment API"
---

<Admonition type="info">
  The Convex Deployment API is openly available in Beta. Please contact
  platforms@convex.dev if your use case requires additional capabilities.
</Admonition>

Unlike HTTP endpoints which expose application-specific functionality to
clients, management API endpoints configure deployments (e.g. modifying
environment variables).

## Authorization

The Deployment Management API requires a Authorization header with a key that
grants admin access to that deployment.

[Deployment keys](https://docs.convex.dev/cli/deploy-key-types#development-deploy-keys)
created in the
[dashboard](https://docs.convex.dev/dashboard/deployments/deployment-settings#url-and-deploy-key)
or by API calls can be used for these APIs.

[Team Access Tokens](/platform-apis#managing-your-own-projects) and
[OAuth Application Tokens](/platform-apis/oauth-applications) can also be used
in depending on whether you are using the Management API on behalf of your own
team or on behalf of the team of a user of a Convex integration you've built.

Whatever type of key, add the string `"Convex "` to the front.

```ts
const token = "ey...0=";
const response = await fetch(
  "https://happy-otter-123.convex.cloud/api/v1/list_environment_variables",
  {
    headers: {
      Authorization: `Convex ${token}`,
    },
  },
);
console.log(await response.json());
```



================================================
FILE: npm-packages/docs/docs/error.mdx
================================================
---
description: "Understand specific errors thrown by Convex"
---

import { ComponentCardList } from "@site/src/components/ComponentCard";

# Errors and Warnings

This page explains specific errors thrown by Convex.

See [Error Handling](/functions/error-handling/error-handling.mdx) to learn
about handling errors in general.

<div id="occ-failure"></div>

## Write conflict: Optimistic concurrency control \{#1}

This system error is thrown when a mutation repeatedly fails due to conflicting
changes from parallel mutation executions.

### Example A

A mutation `updateCounter` always updates the same document:

```ts
export const updateCounter = mutation({
  args: {},
  handler: async (ctx) => {
    const doc = await ctx.db.get("counts", process.env.COUNTER_ID);
    await ctx.db.patch("counts", doc._id, { value: doc.value + 1 });
  },
});
```

If this mutation is called many times per second, many of its executions will
conflict with each other. Convex internally does several retries to mitigate
this concern, but if the mutation is called more rapidly than Convex can execute
it, some of the invocations will eventually throw this error:

<ErrorExample name="updateCounter">
  Documents read from or written to the table "counters" changed while this
  mutation was being run and on every subsequent retry. Another call to this
  mutation changed the document with ID "123456789101112".
</ErrorExample>

The error message will note the table name, which mutation caused the conflict
(in this example its another call to the same mutation), and one document ID
which was part of the conflicting change.

### Example B

Mutation `writeCount` depends on the entire `tasks` table:

```ts
export const writeCount = mutation({
  args: {
    target: v.id("counts"),
  },
  handler: async (ctx, args) => {
    const tasks = await ctx.db.query("tasks").collect();
    await ctx.db.patch("tasks", args.target, { value: tasks });
  },
});

export const addTask = mutation({
  args: {
    text: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("tasks", { text: args.text });
  },
});
```

If the mutation `writeCount` is called at the same time as many calls to
`addTask` are made, either of the mutations can fail with this error. This is
because any change to the `"tasks"` table will conflict with the `writeCount`
mutation:

<ErrorExample name="writeCount">
  Documents read from or written to the table "tasks" changed while this
  mutation was being run and on every subsequent retry. A call to "addTask"
  changed the document with ID "123456789101112".
</ErrorExample>

### Remediation

To fix this issue:

1. Make sure that your mutations only read the data they need. Consider reducing
   the amount of data read by using indexed queries with
   [selective index range expressions](https://docs.convex.dev/database/indexes/).
2. Make sure you are not calling a mutation an unexpected number of times,
   perhaps from an action inside a loop.
3. Design your data model such that it doesn't require making many writes to the
   same document.

### Resources

- Learn more about [optimistic concurrency control](/database/advanced/occ.md).
- See this [Stack post](https://stack.convex.dev/waitlist) for an example of
  designing an app to avoid mutation conflicts.

### Related Components

<ComponentCardList
  items={[
    {
      title: "Workpool",
      description:
        "Workpool give critical tasks priority by organizing async operations into separate, customizable queues.",
      href: "https://www.convex.dev/components/workpool",
    },
    {
      title: "Sharded Counter",
      description:
        "High-throughput counter enables denormalized counts without write conflicts by spreading writes over multiple documents.",
      href: "https://www.convex.dev/components/sharded-counter",
    },
    {
      title: "Action Cache",
      description:
        "Cache frequently run actions. By leveraging the `force` parameter to keep the cache populated, you can ensure that the cache is always up to date and avoid data races.",
      href: "https://www.convex.dev/components/action-cache",
    },
  ]}
/>

## Undefined validator \{#undefined-validator}

This error occurs when a validator passed to a Convex function definition or
schema is `undefined`. This most commonly happens due to circular imports (also
known as import cycles) in TypeScript.

### Example

You have two files that import from each other:

```ts title="convex/validators.ts"
import { v } from "convex/values";
import { someUtility } from "./functions";

export const myValidator = v.object({
  name: v.string(),
});

// Uses someUtility somewhere...
```

```ts title="convex/functions.ts"
import { mutation } from "./_generated/server";
// Both functions.ts and validators.ts import from each other.
import { myValidator } from "./validators";

export function someUtility() {
  // ...
}

export const myMutation = mutation({
  args: {
    data: myValidator, // <-- May be undefined due to import cycle
  },
  handler: async (ctx, args) => {
    // ...
  },
});
```

When `functions.ts` is loaded, it imports from `validators.ts`, which in turn
tries to import from `functions.ts`. Since `functions.ts` hasn't finished the
`import` statement yet, `myValidator` is still `undefined`, causing the
`mutation` builder to throw an error.

Note: the value may be defined at runtime if you try to log it. This is only a
quirk of TypeScript’s import time behavior.

### Cycles involving `schema.ts`

A common way to accidentally introduce this kind of cycle is through your
`schema.ts` file. Larger apps often define validators or whole tables in other
files and import them into `schema.ts`.

If these files import from `schema.ts` or depend on files that do, you have a
cycle.

```text
schema.ts → validators.ts → someFile.ts → schema.ts
```

To break the cycle, define validators in "pure" files that have minimal
dependencies, and import them into the places they are needed.

### Investigate circular imports

If you suspect a circular import but aren't sure where it is, tools like
[madge](https://github.com/pahen/madge) can help you visualize your import graph
and list cycles:

```bash
npx madge convex/ --extensions ts --exclude api.d.ts --circular
```

We exclude `api.d.ts` here because type-only imports are generally safe.



================================================
FILE: npm-packages/docs/docs/eslint.mdx
================================================
---
title: ESLint rules
sidebar_position: 30
description: ESLint rules for Convex
---

ESLint rules for Convex functions enforce best practices. Let us know if there's
a rule you would find helpful!

## Setup

For ESLint 9 (flat config, using `eslint.config.js`), install the rules with:

```bash
npm i @convex-dev/eslint-plugin --save-dev
```

and add this to your `eslint.config.js` file:

```ts
import { defineConfig } from "eslint/config";

import convexPlugin from "@convex-dev/eslint-plugin";

export default defineConfig([
  // Other configurations

  ...convexPlugin.configs.recommended,
]);
```

<Details summary={<>If you’re using the deprecated <code>.eslintrc.js</code> format</>}>

Install these two libraries:

```bash
npm i @typescript-eslint/eslint-plugin @convex-dev/eslint-plugin --save-dev
```

In `.eslintrc.js`, add:

```js
module.exports =
  extends: [
    // Other configurations
    "plugin:@typescript-eslint/recommended",
    "plugin:@convex-dev/recommended",
  ],
  ignorePatterns: ["node_modules/", "dist/", "build/"],
};
```

</Details>

<Details summary={<>If your Convex functions are in a directory other than <code>convex</code></>}>

By default, the Convex ESLint plugin will only apply rules in the `convex`
directory.

If you’re
[customizing the Convex directory location](/production/project-configuration#changing-the-convex-folder-name-or-location),
here’s how to adapt your ESLint configuration:

```ts
// eslint.config.js
import { defineConfig } from "eslint/config";

import convexPlugin from "@convex-dev/eslint-plugin";

const recommendedConfig = convexPlugin.configs.recommended[0];
const recommendedRules = recommendedConfig.rules;

export default defineConfig([
  // Other configurations go here...

  // Custom configuration with modified directory pattern
  {
    files: ["**/src/convex/**/*.ts"],
    plugins: {
      "@convex-dev": convexPlugin,
    },
    rules: recommendedRules,
  },
]);
```

</Details>

<Details summary={<>If you’re using the <code>next lint</code> command from Next.js</>}>

For `next lint` to run ESLint on your `convex` directory you need to add that
directory to the default set of directories. Add this section to your
`next.config.ts`:

```ts
const nextConfig: NextConfig = {
  /* other options here */

  eslint: {
    dirs: ["pages", "app", "components", "lib", "src", "convex"],
  },
};
```

</Details>

## Rules

| Rule                                                                                                                                    | Recommended | Auto-fixable |
| --------------------------------------------------------------------------------------------------------------------------------------- | :---------: | :----------: |
| [`@convex-dev/no-old-registered-function-syntax`](#no-old-registered-function-syntax)<br/>Prefer object syntax for registered functions |     ✅      |      🔧      |
| [`@convex-dev/require-argument-validators`](#require-argument-validators)<br/>Require argument validators for Convex functions          |     ✅      |      🔧      |
| [`@convex-dev/explicit-table-ids`](#explicit-table-ids)<br/>Require explicit table names in database operations                         |     ✅      |      🔧      |
| [`@convex-dev/import-wrong-runtime`](#import-wrong-runtime)<br/>Prevent Convex runtime files from importing from Node runtime files     |             |              |

### no-old-registered-function-syntax

Prefer object syntax for registered functions.

Convex queries, mutations, and actions can be defined with a single function or
with an object containing a handler property. Using the objects makes it
possible to add argument and return value validators, so is always preferable.

```ts
// ✅ Allowed by this rule:
export const list = query({
  handler: async (ctx) => {
    const data = await ctx.db.query("messages").collect();
    ...
  },
});

// ❌ Not allowed by this rule:
export const list = query(async (ctx) => {
  const data = await ctx.db.query("messages").collect();
  ...
});
```

### require-argument-validators

Require argument validators for Convex functions.

Convex queries, mutations, and actions can validate their arguments before
beginning to run the handler function. Besides being a concise way to validate,
the types of arguments, using argument validators enables generating more
descriptive function specs and therefore OpenAPI bindings.

```ts
// ✅ Allowed by this rule:
export const list = query({
  args: {},
  handler: async (ctx) => {
    ...
  },
});

// ✅ Allowed by this rule:
export const list = query({
  args: { channel: v.id('channel') },
  handler: async (ctx, { channel }) => {
    ...
  },
});

// ❌ Not allowed with option { ignoreUnusedArguments: false } (default)
// ✅ Allowed with option { ignoreUnusedArguments: true }
export const list = query({
  handler: async (ctx) => {
    ...
  },
});

// ❌ Not allowed by this rule:
export const list = query({
  handler: async (ctx, { channel }: { channel: Id<"channel"> }) => {
    ...
  },
});
```

This rule can be customized to tolerate functions that don’t define an argument
validator but don’t use their arguments. Here’s how you can set up the rule to
work this way:

```ts
// eslint.config.js

export default defineConfig([
  // Your other rules…

  {
    files: ["**/convex/**/*.ts"],
    rules: {
      "@convex-dev/require-args-validator": [
        "error",
        {
          ignoreUnusedArguments: true,
        },
      ],
    },
  },
]);
```

### explicit-table-ids

Require explicit table names in database operations.

Starting from version 1.31.0 of the `convex` npm package, we recommend including
the table name as the first argument to database operations (`db.get`,
`db.replace`, `db.patch`, `db.delete`).

This approach is more secure because it prevents vulnerabilities when an ID from
one table is incorrectly typed as belonging to another table. The implicit
syntax (where table names are inferred from the ID) will be deprecated in the
future to give developers more control over ID generation. For both these
reasons, we recommend developers to migrate to the new format.

This rule helps migrate code from the old implicit format to the new explicit
format. It uses TypeScript type information to automatically infer the table
name from the `Id<"tableName">` type and provides automatic fixes.

```ts
const messageId: Id<"messages"> = "123" as Id<"messages">;

// ✅ Allowed by this rule:
const message = await ctx.db.get("messages", messageId);
await ctx.db.patch("messages", messageId, { text: "updated" });
await ctx.db.replace("messages", messageId, {
  text: "replaced",
  author: "Alice",
});
await ctx.db.delete("messages", messageId);

// ❌ Not allowed by this rule:
const message = await ctx.db.get(messageId);
await ctx.db.patch(messageId, { text: "updated" });
await ctx.db.replace(messageId, { text: "replaced", author: "Alice" });
await ctx.db.delete(messageId);
```

<Admonition type="info" title="typescript-eslint required">

In order for this rule to work,
[typescript-eslint](https://typescript-eslint.io) must be set up in your ESLint
configuration. If typescript-eslint is installed and the rule doesn’t seem to
work, please make sure that
[type-aware linting](https://typescript-eslint.io/troubleshooting/typed-linting/)
is enabled.

</Admonition>

Note that if you’re not using ESLint, you can alternatively use the
`@convex-dev/codemod` CLI tool to automatically migrate to the new format:

```bash
npx @convex-dev/codemod@latest explicit-ids
```

[Learn more on news.convex.dev →](https://news.convex.dev/db-table-name/)

### import-wrong-runtime

Prevent Convex runtime files from importing from Node runtime files (files with
a `"use node"` directive).

This rule is experimental. Please let us know if you find it helpful!

```ts
// In a file that doesn’t use `"use node"`:

// ✅ Allowed by this rule:
import { someFunction } from "./someOtherFile"; // where someOtherFile doesn't use `"use node"`

// ❌ Not allowed by this rule:
import { someFunction } from "./someNodeFile"; // where someNodeFile uses `"use node"`
```



================================================
FILE: npm-packages/docs/docs/file-storage.mdx
================================================
---
title: "File Storage"
description: "Store and serve files of any type"
sidebar_position: 160
pagination_prev: database
---

File Storage makes it easy to implement file upload in your app, store files
from and send files to third-party APIs, and to serve dynamic files to your
users. All file types are supported.

- [Upload](/file-storage/upload-files.mdx) files to store them in Convex and
  reference them in your database documents
- [Store](/file-storage/store-files.mdx) files generated or fetched from
  third-party APIs
- [Serve](/file-storage/serve-files.mdx) files via URL
- [Delete](/file-storage/delete-files.mdx) files stored in Convex
- Access file [metadata](/file-storage/file-metadata.mdx)

You can manage your stored files on the
[dashboard](/dashboard/deployments/files.md).

**Examples:**
[File Storage with HTTP Actions](https://github.com/get-convex/convex-demos/tree/main/file-storage-with-http),
[File Storage with Queries and Mutations](https://github.com/get-convex/convex-demos/tree/main/file-storage)



================================================
FILE: npm-packages/docs/docs/functions.mdx
================================================
---
title: "Functions"
description: "Write functions to define your server behavior"
hide_table_of_contents: true
pagination_prev: tutorial/index
---

Functions run on the backend and are written in JavaScript (or TypeScript). They
are automatically available as APIs accessed through
[client libraries](/client/react.mdx). Everything you do in the Convex backend
starts from functions.

There are three types of functions:

- [Queries](/functions/query-functions.mdx) read data from your Convex database
  and are automatically cached and subscribable (realtime, reactive).
- [Mutations](/functions/mutation-functions.mdx) write data to the database and
  run as a transaction.
- [Actions](/functions/actions.mdx) can call OpenAI, Stripe, Twilio, or any
  other service or API you need to make your app work.

You can also build [HTTP actions](/functions/http-actions.mdx) when you want to
call your functions from a webhook or a custom client.

Here's an overview of the three different types of Convex functions and what
they can do:

|                            | Queries | Mutations | Actions |
| -------------------------- | ------- | --------- | ------- |
| Database access            | Yes     | Yes       | No      |
| Transactional              | Yes     | Yes       | No      |
| Cached                     | Yes     | No        | No      |
| Real-time Updates          | Yes     | No        | No      |
| External API Calls (fetch) | No      | No        | Yes     |



================================================
FILE: npm-packages/docs/docs/home.mdx
================================================
---
title: "Convex Docs"
slug: "home"
hide_table_of_contents: true
---

import TutorialGraphic from "@site/static/img/tutorial-graphic.svg";
import {
  QuickFrameworksList,
  QuickLanguagesList,
} from "@site/src/QuickstartsList.tsx";
import { LargeCardList } from "@site/src/QuickstartsList.tsx";
import { YouTubeList } from "@site/src/YouTubeLink.tsx";
import Link from "@docusaurus/Link";

Convex is the open source, reactive database where queries are TypeScript code
running right in the database. Just like React components react to state
changes, Convex queries react to database changes.

Convex provides a database, a place to write your server functions, and client
libraries. It makes it easy to build and scale dynamic live-updating apps.

<LargeCardList
  items={[
    {
      title: "Tutorial: Build a chat app",
      description:
        "Follow a step-by-step tutorial to build your first Convex app - a real-time chat application.",
      href: "/tutorial",
    },
    {
      title: "Understanding Convex",
      description:
        "Learn about the core concepts and architecture that make Convex unique and powerful.",
      href: "/understanding",
    },
  ]}
/>

## Get Started

<CardLink
  className="convex-hero-card"
  item={{
    href: "https://chef.convex.dev",
    label: "Prompt to start an app with Convex Chef",
  }}
/>

Your favorite frameworks:

<QuickFrameworksList />

Your favorite languages:

<QuickLanguagesList />

## Why Convex?

<YouTubeList
  items={[
    {
      src: "https://www.youtube.com/embed/Xjud1weG4z8?si=OMMfKzK_Dp8RgmgM",
      label: "Backends for Product Developers",
    },
    {
      src: "https://www.youtube.com/embed/UVvd7BF99-4?si=Z9_pLHMnpL9kaduE",
      label: "Intro to Convex",
    },
    {
      src: "https://www.youtube.com/embed/V6En7UO4Ui0?si=kcj1aftxV-tqe9Q-",
      label: "Supercharging your app with a reactive backend",
    },

    {
      src: "https://www.youtube.com/embed/O_HXVAMPEbc?si=qtA8nLyGjGUsXVkL",
      label: "Why I use Convex over Supabase as my BaaS",
    },

]} />

Read the team's Perspectives on [Stack](https://stack.convex.dev):

<DocCardList
  items={[
    {
      type: "link",
      href: "https://stack.convex.dev/convex-vs-relational-databases",
      label: "Convex vs Relational Databases",
    },
    {
      type: "link",
      href: "https://stack.convex.dev/convex-vs-firebase",
      label: "Convex vs Firebase",
    },
    {
      type: "link",
      href: "https://stack.convex.dev/how-convex-works",
      label: "How Convex Works",
    },
  ]}
/>

## Learn Convex

<YouTubeList
  items={[
    {
      src: "https://www.youtube.com/embed/vaQZYRSiimI?si=JLfdVVs3QkCLTZwc",
      label: "Convex with Next.js Quickstart",
    },
    {
      src: "https://www.youtube.com/embed/0OaDyjB9Ib8?si=V5_9FN3UieZmnOM5",
      label: "Notion Clone: Next.js 13, React, Convex, Tailwind",
    },
    {
      src: "https://www.youtube.com/embed/zfAb95tJvZQ?si=PaiBxNxCO0s2BuEZ",
      label: "Build a Saas Podcast Platform in Next.js",
    },
    {
      src: "https://www.youtube.com/embed/Vjtn9pWAZDI?si=of21uqly5laJQJAs",
      label: "Building a Subscription Based SaaS with Stripe",
    },

]} />

See more walkthroughs and patterns on [Stack](https://stack.convex.dev)

<DocCardList
  items={[
    {
      type: "link",
      href: "https://stack.convex.dev/tag/AI",
      label: "Build AI Apps",
    },
    {
      type: "link",
      href: "https://stack.convex.dev/tag/Patterns",
      label: "Convex Patterns",
    },
    {
      type: "link",
      href: "https://stack.convex.dev/tag/Walkthroughs",
      label: "Convex Walkthroughs",
    },
  ]}
/>



================================================
FILE: npm-packages/docs/docs/management-api.mdx
================================================
---
title: Management API
hide_table_of_contents: true
description: "Creating and managing Convex deployments by API"
---

<Admonition type="info">
  The Convex Management API is openly available in Beta. Please contact
  platforms@convex.dev if your use case requires additional capabilities.
</Admonition>

You can provision and manage Convex projects and deployments with the Management
API.

## Authorization

The Management API uses a Bearer token Authorization header.

```ts
const token = "ey...0=";
const response = await fetch(
  "https://api.convex.dev/v1/teams/41/list_projects",
  {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  },
);
console.log(await response.json());
```

[Team Access Tokens](/platform-apis#managing-your-own-projects) and
[OAuth Application Tokens](/platform-apis/oauth-applications) can be used in
Bearer tokens depending on whether you are using the Management API on behalf of
your own team or on behalf of the team of a user of a Convex integration you've
built.

## Required Parameters

Most Management APIs require a team ID or project ID.

When creating a Team Access Token the team ID will be available in the Convex
dashboard.

OAuth applications may request the team (or project, if using project-scoped
tokens) ID by calling the [Token Details](/management-api/get-token-details)
endpoint.

When using a team token, projects will be assigned IDs upon creation. The
[List Projects](/management-api/list-projects) endpoint may also be used to
retrieve the ID for a project.

## Responses

All API responses are in JSON format.

## Endpoints

An OpenAPI spec for the Management API is available at
[https://api.convex.dev/v1/openapi.json](https://api.convex.dev/v1/openapi.json).



================================================
FILE: npm-packages/docs/docs/platform-apis.mdx
================================================
---
title: Platform APIs
---

# Platform APIs

<Admonition type="info">
  Convex Platform APIs are in openly available in Beta. Please contact
  platforms@convex.dev if your use case requires additional capabilities.
</Admonition>

This guide is for products that want to orchestrate multiple Convex projects in
their accounts or manage projects in their users' accounts. These APIs are most
often used by AI app builders, such as [Bloom](https://bloom.diy/),
[A0](https://a0.dev/), or [Macaly](https://www.macaly.com/).

These guides assume a good understanding of Convex cloud hierarchy (teams,
projects, and deployments) as well as the
[development workflow](/understanding/workflow).

## Managing your own projects

This means that you are creating projects, deployments, and pushing code
programmatically in the context of the team you own.

To manage projects in your own team, you need to get a team-scoped token and ID
from your
[Team Settings](https://dashboard.convex.dev/team/settings/access-tokens).

<Admonition type="caution">
  These tokens are owned by the team member that's logged into the Convex
  dashboard when you retrieve them.

This means that this user owns any dev deployments created by using these
tokens. If this user leaves the team, that also deletes all of their dev
deployments from the team.

We recommend creating a separate service account that's added as a team member.
Retrieve the token after logging in as this service account.

</Admonition>

## Managing your users' projects

This means your users authorize your product to manage their own Convex team or
projects.

To do this, you need to create an OAuth 2.0 application so that the user can
grant your product the necessary permissions.

Follow the [OAuth Applications](/platform-apis/oauth-applications) guide to
create an OAuth application and request a relevant token.

## APIs to manage projects

Once you have obtained a token from one of the methods above, you can use it to
call the relevant APIs to manage Convex projects and deployments.

[Management API Reference](/management-api)

## Pushing code to a deployment

Working with your deployment should be scripted primarily with the existing
Convex CLI. The Convex CLI manages a lot of the heavy lifting: bundling code,
properly handling responses, etc.

The examples here assume you are working in a container with shell and file
system access from which you can drive the app building process. You likely
already have this if you're generating frontend code.

Set [`CONVEX_DEPLOY_KEY`](/docs/cli/deploy-key-types.mdx) is the value returned
by the [Create deploy key](/management-api/create-deploy-key) API.

### Pushing code to the dev Convex backend

```bash
CONVEX_DEPLOY_KEY="YOUR_DEPLOY_KEY" npx convex dev --once
```

### Pushing code to the prod Convex backend

```bash
CONVEX_DEPLOY_KEY="YOUR_DEPLOY_KEY" npx convex deploy
```

To view the full list of commands, refer to the [CLI documentation](/cli).



================================================
FILE: npm-packages/docs/docs/production.mdx
================================================
---
title: "Deploying Your App to Production"
hide_table_of_contents: true
pagination_prev: search
description: "Tips for building safe and reliable production apps"
---

Convex is built to serve live, production app traffic. Here we cover how to
deploy and maintain a production version of your app.

## Project management

When you sign up for Convex, a Convex team is created for you. You can
[create more teams from the dashboard](/dashboard/teams.md) and add other people
to them as members. You can upgrade your team to the
[Starter](https://www.convex.dev/pricing) plan to pay as you go or the
[Professional](https://www.convex.dev/pricing) for additional features, higher
built-in limits, 24h support, and discounted usage-based pricing.

Each team can have multiple projects. When you run `npx convex dev` for the
first time, a project is created for you automatically. You can also create a
project from the dashboard.

Every project has one shared production deployment and one development
deployment per team member. This allows each team member to make and test
changes independently before they are deployed to the production deployment.

Usually all deployments belonging to a single project run the same code base (or
a version of it), but Convex doesn't enforce this. You can also run the same
code base on multiple different prod deployments belonging to different
projects, see [staging](#staging-environment) below.

## Deploying to production

Your Convex deployments run your backend logic and in most cases you will also
develop a client that uses the backend. If your client is a web app, follow the
[Hosting and Deployment](/production/hosting/hosting.mdx) guide, to learn how to
deploy your client and your Convex backend together.

You can also deploy your backend on its own. Check out the
[Project Configuration](/production/project-configuration.mdx) page to learn
more.

## Staging environment

With Convex [preview deployments](/production/hosting/preview-deployments.mdx)
your team can test out changes before deploying them to production. If you need
a more permanent staging environment, you can use a separate Convex project, and
deploy to it by setting the `CONVEX_DEPLOY_KEY` environment variable when
running [`npx convex deploy`](/cli.md#deploy-convex-functions-to-production).

## Typical team development workflow

Teams developing on Convex usually follow this workflow:

1. If this is the team's first project, one team member creates a team on the
   dashboard.
2. One team member creates a project by running `npx convex dev`, perhaps
   starting with a [quickstart](/quickstarts.mdx) or a
   [template](https://www.convex.dev/templates).
3. The team member creates a Git repository from the initial code and shares it
   with their team (via GitHub, GitLab etc.).
4. Other team members pull the codebase, and get their own dev deployments by
   running `npx convex dev`.
5. All team members can make backend changes and test them out with their
   individual dev deployments. When a change is ready the team member opens a
   pull-request (or commits to a shared branch).
   - [Backup / Restore](/database/backup-restore) can be used to populate a dev
     deployment with data from a prod deployment.
   - [Data import](/database/import-export/import.mdx) can be used to populate a
     dev deployment with synthetic seed data.
   - Members of a team with the [Pro plan](https://www.convex.dev/pricing) can
     get separate
     [preview deployments](/production/hosting/preview-deployments.mdx) to test
     each other's pull-requests.
6. Deployment to production can happen
   [automatically](/production/hosting/hosting.mdx) when changes get merged to
   the designated branch (say `main`).
   - Alternatively one of the team members can deploy to production manually by
     running `npx convex deploy`.

### Making safe changes

Especially if your app is live you want to make sure that changes you make to
your Convex codebase do not break it.

Some unsafe changes are handled and caught by Convex, but others you need handle
yourself.

1. **Schema must always match existing data.** Convex enforces this constraint.
   You cannot push a schema to a deployment with existing data that doesn't
   match it, unless you turn off schema enforcement. In general it safe to:
   1. Add new tables to the schema.
   2. Add an `optional` field to an existing table's schema, set the field on
      all documents in the table, and then make the field required.
   3. Mark an existing field as `optional`, remove the field from all documents,
      and then remove the field.
   4. Mark an existing field as a `union` of the existing type and a new type,
      modify the field on all documents to match the new type, and then change
      the type to the new type.
2. **Functions should be backwards compatible.** Even if your only client is a
   website, and you deploy it together with your backend, your users might still
   be running the old version of your website when your backend changes.
   Therefore you should make your functions backwards compatible until you are
   OK to break old clients. In general it is safe to:
   1. Add new functions.
   2. Add an `optional` named argument to an existing function.
   3. Mark an existing named argument as `optional`.
   4. Mark an existing named argument as a `union` of the existing type and a
      new type.
   5. Change the behavior of the function in such a way that given the arguments
      from an old client its behavior will still be acceptable to the old
      client.
3. **Scheduled functions should be backwards compatible.** When you schedule a
   function to run in the future, you provide the argument values it will
   receive. Whenever a function runs, it always runs its currently deployed
   version. If you change the function between the time it was scheduled and the
   time it runs, you must ensure the new version will behave acceptably given
   the old arguments.

<StackPosts query="deploy" />



================================================
FILE: npm-packages/docs/docs/quickstarts.mdx
================================================
---
title: Quickstarts
hide_table_of_contents: true
description:
  "Get started quickly with your favorite frontend framework or language"
---

import {
  QuickLanguagesList,
  QuickFrameworksList,
} from "@site/src/QuickstartsList.tsx";

Quickly get up and running with your favorite frontend tooling:

<QuickFrameworksList />

Quickly get up and running with your favorite languages:

<QuickLanguagesList />



================================================
FILE: npm-packages/docs/docs/realtime.mdx
================================================
---
title: "Realtime"
sidebar_position: 100
description: "Building realtime apps with Convex"
---

Turns out Convex is automatically realtime! You don’t have to do anything
special if you are already using [query functions](./functions/query-functions),
[database](./database), and [client libraries](./client/react/) in your app.
Convex tracks the dependencies to your query functions, including database
changes, and triggers the subscription in the client libraries.

<div align="center">
  ![Convex is automatically reactive and realtime](/img/realtime.gif)
</div>

Aside from building a highly interactive app with ease, there are other benefits
to the realtime architecture of Convex:

## Automatic caching

Convex automatically caches the result of your query functions so that future
calls just read from the cache. The cache is updated if the data ever changes.
You don't get charged for database bandwidth for cached reads.

This requires no work or bookkeeping from you.

## Consistent data across your app

Every client subscription gets updated simultaneously to the same snapshot of
the database. Your app always displays the most consistent view of your data.

This avoids bugs like increasing the number of items in the shopping cart and
not showing that an item is sold out.

## Learn more

Learn how to work with realtime and reactive queries in Convex on
[Stack](https://stack.convex.dev/tag/Reactivity).

<StackPosts query="reactivity" />



================================================
FILE: npm-packages/docs/docs/scheduling.mdx
================================================
---
title: "Scheduling"
hide_table_of_contents: true
pagination_prev: auth
description:
  "Schedule functions to run once or repeatedly with scheduled functions and
  cron jobs"
---

import { ComponentCardList } from "@site/src/components/ComponentCard";

Convex lets you easily schedule a function to run once or repeatedly in the
future. This allows you to build durable workflows like sending a welcome email
a day after someone joins or regularly reconciling your accounts with Stripe.
Convex provides two different features for scheduling:

- [Scheduled Functions](/scheduling/scheduled-functions.mdx) can be scheduled
  durably by any other function to run at a later point in time. You can
  schedule functions minutes, days, and even months in the future.
- [Cron Jobs](/scheduling/cron-jobs.mdx) schedule functions to run on a
  recurring basis, such as daily.

## Durable function components

Built-in scheduled functions and crons work well for simpler apps and workflows.
If you're operating at high scale or need more specific guarantees, use the
following higher-level [components](/components.mdx) for durable functions.

<ComponentCardList
  items={[
    {
      title: "Workpool",
      description:
        "Workpool give critical tasks priority by organizing async operations into separate, customizable queues.",
      href: "https://www.convex.dev/components/workpool",
    },
    {
      title: "Workflow",
      description:
        "Simplify programming long running code flows. Workflows execute durably with configurable retries and delays.",
      href: "https://www.convex.dev/components/workflow",
    },
    {
      title: "Crons",
      description:
        "Use cronspec to run functions on a repeated schedule at runtime.",
      href: "https://www.convex.dev/components/crons",
    },
  ]}
/>

<StackPosts query="scheduler" />



================================================
FILE: npm-packages/docs/docs/search.mdx
================================================
---
title: "AI & Search"
sidebar_position: 105
description: "Run search queries over your Convex documents"
slug: "search"
pagination_prev: "scheduling"
---

Whether building RAG enabled chatbots or quick search in your applications,
Convex provides easy apis to create powerful AI and search enabled products.

[Vector Search](/search/vector-search.mdx) enables searching for documents based
on their semantic meaning. It uses vector embeddings to calculate similarity and
retrieve documents that are similar to a given query. Vector search is a key
part of common AI techniques like RAG.

[Full Text Search](/search/text-search.mdx) enables keyword and phrase search
within your documents. It supports prefix matching to enable typeahead search.
Convex full text search is also reactive and always up to date like all Convex
queries, making it easy to build reliable quick search boxes.

[Convex Actions](functions/actions) easily enable you to call AI apis, save data
to your database, and drive your user interface. See examples of how you can use
this to [build sophisticated AI applications](https://stack.convex.dev/tag/AI).

<StackPosts query="AI" />



================================================
FILE: npm-packages/docs/docs/self-hosting.mdx
================================================
---
title: "Self Hosting"
sidebar_position: 100
description: "Self Hosting Convex Projects"
---

If you're excited about self-hosting, you can run the Convex backend on your own
servers. Self-hosted Convex runs the
[open-source backend](https://github.com/get-convex/convex-backend), and
contains the same fully up-to-date code the cloud service uses.

To get started with self hosting, follow the self-hosting guide:

<CardLink
  className="convex-hero-card"
  item={{
    href: "https://github.com/get-convex/convex-backend/blob/main/self-hosted/README.md",
    label: "Self-hosting guide",
  }}
/>

Join the `#self-hosted` channel in the
[Discord community](https://convex.dev/community) for self-hosting support.

Self hosting is not for everyone. If you're looking for a more hands-off
solution, we recommend using the
[Convex-hosted product](https://convex.dev/pricing).

## Open Source Convex Backend

The majority of the backend is written in Rust, with a healthy dose of
TypeScript supporting the server-side function environment.

You can learn more about open-sourcing at Convex in our
[announcement](https://news.convex.dev/convex-goes-open-source/) and the
[software engineering daily podcast](https://softwareengineeringdaily.com/2024/03/20/going-open-source-at-convex-with-james-cowling/).
It is released under the [FSL Apache 2.0 License](https://fsl.software/).

## Other Convex Open Source Projects

The Convex backend, client libraries, dashboard, and CLI are all open-source.
You can explore everything on the
[Convex GitHub page](https://github.com/get-convex).

### Convex Clients

All Convex Clients are open-source.

- [Convex JavaScript/TypeScript clients & CLI](https://github.com/get-convex/convex-js)
- [Convex Python Client](https://github.com/get-convex/convex-py)
- [Convex Rust Client](https://github.com/get-convex/convex-rs)

### Much Much More

Convex also open-sources many other helpful projects including
[helpers](https://github.com/get-convex/convex-helpers),
[templates](https://github.com/orgs/get-convex/repositories?type=all&q=template),
[demos](https://github.com/get-convex/convex-demos), a
[testing harness](https://github.com/get-convex/convex-test) and much more. See
the complete list of all our public repositories
[at GitHub](https://github.com/orgs/get-convex/repositories?type=all).

<StackPosts query="open-source" />



================================================
FILE: npm-packages/docs/docs/streaming-export-api.mdx
================================================
---
title: "Streaming Export"
sidebar_label: "Streaming Export"
description: "Streaming data out of Convex"
---

Convex supports streaming export. Convex provides connector implementations for
[Fivetran and Airbyte](/production/integrations/streaming-import-export.md).
Those connectors use the following APIs.

Sign up for a [Professional plan](https://www.convex.dev/pricing) for streaming
export support. You can also read the
[documentation on streaming export](/production/integrations/streaming-import-export.md).

<BetaAdmonition feature="Streaming Export HTTP APIs" verb="are" />

Streaming export requests require deployment admin authorization via the HTTP
header `Authorization`. The value is `Convex <access_key>` where the access key
comes from "Deploy key" on the Convex dashboard and gives full read and write
access to your Convex data.

### GET `/api/json_schemas`

The JSON Schemas endpoint lists tables, and for each table describes how
documents will be encoded, given as [JSON Schema](https://json-schema.org/).
This endpoint returns `$description` tags throughout the schema to describe
unintuitive encodings and give extra information like the table referenced by
`Id` fields.

**Query parameters**

| Name        | Type    | Required | Description                                                                                                     |
| ----------- | ------- | -------- | --------------------------------------------------------------------------------------------------------------- |
| deltaSchema | boolean | n        | If set, include metadata fields returned by document_deltas and list_snapshot (`_ts`, `_deleted`, and `_table`) |
| format      | string  | n        | Output format for values. Valid values: [`json`]                                                                |

### GET `/api/list_snapshot`

The `list_snapshot` endpoint walks a consistent snapshot of documents. It may
take one or more calls to `list_snapshot` to walk a full snapshot.

**Query parameters**

| Name      | Type   | Required | Description                                                                                                                                  |
| --------- | ------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| snapshot  | int    | n        | Database timestamp at which to continue the snapshot. The timestamp must not be older than 30 days. If omitted, select the latest timestamp. |
| cursor    | string | n        | An opaque cursor representing the progress in paginating through the snapshot. If omitted, start from the first page of the snapshot.        |
| tableName | string | n        | If provided, filters the snapshot to a table. If omitted, provide snapshot across all tables.                                                |
| format    | string | n        | Output format for values. Valid values: [`json`]                                                                                             |

**Result JSON**

| Field Name | Type              | Description                                                                                             |
| ---------- | ----------------- | ------------------------------------------------------------------------------------------------------- |
| values     | List[ConvexValue] | List of convex values in the requested format. Each value includes extra fields `_ts` and `_table`.     |
| hasMore    | boolean           | True if there are more pages to the snapshot.                                                           |
| snapshot   | int               | A value that represents the database timestamp at which the snapshot was taken.                         |
| cursor     | string            | An opaque cursor representing the end of the progress on the given page. Pass this to subsequent calls. |

Expected API usage (pseudocode):

```python
def list_full_snapshot()
    snapshot_values = []
    snapshot = None
    cursor = None
    while True:
        result = api.list_snapshot(cursor, snapshot)
        snapshot_values.extend(result.values)
        (cursor, snapshot) = (result.cursor, result.snapshot)
        if !result.hasMore:
            break
    return (snapshot_values, result.snapshot)
```

### GET `/api/document_deltas`

The `document_deltas` endpoint walks the change log of documents to find new,
updated, and deleted documents in the order of their mutations. This order is
given by a `_ts` field on the returned documents. Deletions are represented as
JSON objects with fields `_id`, `_ts`, and `_deleted: true`.

**Query parameters**

| Name      | Type   | Required | Description                                                                                                                              |
| --------- | ------ | -------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| cursor    | int    | y        | Database timestamp after which to continue streaming document deltas. Initial value is the `snapshot` field returned from list_snapshot. |
| tableName | string | n        | If provided, filters the document deltas to a table. If omitted, provide deltas across all tables.                                       |
| format    | string | n        | Output format for values. Valid values: [`json`]                                                                                         |

**Result JSON**

| Field Name | Type              | Description                                                                                                                                    |
| ---------- | ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| values     | List[ConvexValue] | List of convex values in the requested format. Each value includes extra fields for `_ts`, and `_table`. Deletions include a field `_deleted`. |
| hasMore    | boolean           | True if there are more pages to the snapshot.                                                                                                  |
| cursor     | int               | A value that represents the database timestamp at the end of the page. Pass to subsequent calls to document_deltas.                            |

Expected API usage (pseudocode):

```python
def delta_sync(delta_cursor):
    delta_values = []
    while True:
        result = api.document_deltas(cursor)
        delta_values.extend(result.values)
        cursor = result.cursor
        if !hasMore:
            break
    return (delta_values, delta_cursor)

(snapshot_values, delta_cursor) = list_full_snapshot()
(delta_values, delta_cursor) = delta_sync(delta_cursor)
# Save delta_cursor for the next sync
```



================================================
FILE: npm-packages/docs/docs/streaming-import-api.mdx
================================================
---
title: "Streaming Import"
sidebar_label: "Streaming Import"
description: "Streaming data into Convex"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Convex supports streaming import. Convex provides a connector implementation for
[Airbyte](/production/integrations/streaming-import-export.md). Those connectors
use the following APIs.

Streaming import support is automatically enabled for all Convex projects.

Streaming import requests require deployment admin authorization via the HTTP
header `Authorization`. The value is `Convex <access_key>` where the access key
comes from "Deploy key" on the Convex dashboard and gives full read and write
access to your Convex data.

### Headers

Streaming import endpoints accept a `Convex-Client: streaming-import-<version>`
header, where the version follows [Semver](https://semver.org/) guidelines. If
this header is not specified, Convex will default to the latest version. We
recommend using the header to ensure the consumer of this API does not break as
the API changes.

### GET `/api/streaming_import/primary_key_indexes_ready`

The `primary_key_indexes_ready` endpoint takes a list of table names and returns
true if the primary key indexes (created by `add_primary_key_indexes`) on all
those tables are ready. If the tables are newly created, the indexes should be
ready immediately; however if there are existing documents in the tables, it may
take some time to backfill the primary key indexes. The response looks like:

```json
{
  "indexesReady": true
}
```

### PUT `/api/streaming_import/add_primary_key_indexes`

The `add_primary_key_indexes` endpoint takes a JSON body containing the primary
keys for tables and creates indexes on the primary keys to be backfilled. Note
that they are not immediately ready to query - the `primary_key_indexes_ready`
endpoint needs to be polled until it returns True before calling
`import_airbyte_records` with records that require primary key indexes. Also
note that Convex queries will not have access to these added indexes. These are
solely for use in `import_airbyte_records`. The body takes the form of a map of
index names to list of field paths to index. Each field path is represented by a
list of fields that can represent nested field paths.

```json
{
  "indexes": {
    "<table_name>": [["<field1>"], ["<field2>", "<nested_field>"]]
  }
}
```

Expected API Usage:

1. Add indexes for primary keys by making a request to
   `add_primary_key_indexes`.
2. Poll `primary_key_indexes_ready` until the response is true.
3. Query using the added indexes.

### PUT `api/streaming_import/clear_tables`

The `clear_tables` endpoint deletes all documents from the specified tables.
Note that this may require multiple transactions. If there is an intermediate
error only some documents may be deleted. The JSON body to use this API request
contains a list of table names:

```json
{
  "tableNames": ["<table_1>", "<table_2>"]
}
```

### POST `api/streaming_import/replace_tables`

This endpoint is no longer supported. Use `api/streaming_import/clear_tables`
instead.

The `replace_tables` endpoint renames tables with temporary names to their final
names, deleting any existing tables with the final names.

The JSON body to use this API request contains a list of table names:

```json
{
  "tableNames": { "<table_1_temp>": "<table_1>", "<table_2_temp>": "<table_2>" }
}
```

### POST `api/streaming_import/import_airbyte_records`

The `import_airbyte_records` endpoint enables streaming ingress into a Convex
deployment and is designed to be called from an Airbyte destination connector.

It takes a map of streams and a list of messages in the JSON body. Each stream
has a name and JSON schema that will correspond to a Convex table. Streams where
records should be deduplicated include a primary key as well, which is
represented as a list of lists of strings that are field paths. Records for
streams without a primary key are appended to tables; records for streams with a
primary key replace an existing record where the primary key value matches or
are appended if there is no match. If you are using primary keys, you must call
the `add_primary_key_indexes` endpoint first and wait for them to backfill by
polling `primary_key_indexes_ready`.

Each message contains a stream name and a JSON document that will be inserted
(or replaced, in the case of deduplicated sync) into the table with the
corresponding stream name. Table names are same as the stream names. Airbyte
records become Convex documents.

```json
{
   "tables": {
      "<stream_name>": {
         "primaryKey": [["<field1>"], ["<field2>", "<nested_field>"]],
         "jsonSchema": // see https://json-schema.org/ for examples
      }
   },
   "messages": [{
      "tableName": "<table_name>",
      "data": {} // JSON object conforming to the `json_schema` for that stream
   }]
}
```

Similar to `clear_tables`, it is possible to execute a partial import using
`import_airbyte_records` if there is a failure after a transaction has
committed.

Expected API Usage:

1. [Optional] Add any indexes if using primary keys and
   [deduplicated sync](https://docs.airbyte.com/understanding-airbyte/connections/incremental-deduped-history/)
   (see `add_primary_key_indexes` above).
2. [Optional] Delete all documents in specified tables using `clear_tables` if
   using
   [overwrite sync](https://docs.airbyte.com/understanding-airbyte/connections/full-refresh-overwrite).
3. Make a request to `import_airbyte_records` with new records to sync and
   stream information.



================================================
FILE: npm-packages/docs/docs/testing.mdx
================================================
---
title: "Testing"
sidebar_position: 105
description: "Testing your backend"
slug: "testing"
pagination_prev: "search"
---

Convex makes it easy to test your app via automated tests running in JS or
against a real backend, and manually in dev, preview and staging environments.

## Automated tests

### `convex-test` library

[Use the `convex-test` library](/testing/convex-test.mdx) to test your functions
in JS via the excellent Vitest testing framework.

### Testing against a real backend

Convex open source builds allow you to test all of your backend logic running on
a real [local Convex backend](/testing/convex-backend.mdx).

### Set up testing in CI

It's a good idea to test your app continuously in a controlled environment. No
matter which way automated method you use, it's easy to run them with
[GitHub Actions](/testing/ci.mdx).

{/* todo: automated testing against preview deployments */}
{/* todo: testing React+Convex - all the different ways */}

## Manual tests

### Running a function in dev

Manually run a function in dev to quickly see if things are working:

- [Run functions from the command line](/cli.md#run-convex-functions)
- [Run functions from the dashboard](/dashboard/deployments/functions.md#running-functions)

### Preview deployments

[Use preview deployments](/production/hosting/preview-deployments.mdx) to get
early feedback from your team for your in-progress features.

### Staging environment

You can set up a separate project as a staging environment to test against. See
[Deploying Your App to Production](/production.mdx#staging-environment).



================================================
FILE: npm-packages/docs/docs/agents/agent-usage.mdx
================================================
---
title: "Agent Definition and Usage"
sidebar_label: "Agent Usage"
sidebar_position: 140
description: "Configuring and using the Agent class"
---

Agents encapsulate models, prompting, tools, and other configuration. They can
be defined as globals, or at runtime.

They use threads to contain a series of messages used along the way, whether
those messages are from a user, another Agent / LLM, or elsewhere. A thread can
have multiple Agents responding, or be used by a single Agent.

Agentic workflows are built up by combining contextual prompting (threads,
messages, tool responses, RAG, etc.) and dynamic routing via LLM tool calls,
structured LLM outputs, or a myriad of other techniques via custom code.

## Basic Agent definition

```ts
import { components } from "./_generated/api";
import { Agent } from "@convex-dev/agent";
import { openai } from "@ai-sdk/openai";

const agent = new Agent(components.agent, {
  name: "Basic Agent",
  languageModel: openai.chat("gpt-4o-mini"),
});
```

See [below](#customizing-the-agent) for more configuration options.

Everything except the name can be overridden at the call site when calling the
LLM, and many features available on the agent can be used without an Agent, if
this way of organizing the work is not needed for your use case.

## Dynamic Agent definition

You can define an Agent at runtime, which is useful if you want to create an
Agent for a specific context. This allows the LLM to call tools without
requiring the LLM to always pass through full context to each tool call. It also
allows dynamically choosing a model or other options for the Agent.

```ts
import { Agent } from "@convex-dev/agent";
import { type LanguageModel } from "ai";
import type { ActionCtx } from "./_generated/server";
import type { Id } from "./_generated/dataModel";
import { components } from "./_generated/api";

function createAuthorAgent(
  ctx: ActionCtx,
  bookId: Id<"books">,
  model: LanguageModel,
) {
  return new Agent(components.agent, {
    name: "Author",
    languageModel: model,
    tools: {
      // See https://docs.convex.dev/agents/tools
      getChapter: getChapterTool(ctx, bookId),
      researchCharacter: researchCharacterTool(ctx, bookId),
      writeChapter: writeChapterTool(ctx, bookId),
    },
    maxSteps: 10, // Alternative to stopWhen: stepCountIs(10)
  });
}
```

## Generating text with an Agent

To generate a message, you provide a prompt (as a string or a list of messages)
to be used as context to generate one or more messages via an LLM, using calls
like `agent.streamText` or `agent.generateObject`.

The arguments to `generateText` and others are the same as the AI SDK, except
you don't have to provide a model. By default it will use the agent's language
model. There are also extra arguments that are specific to the Agent component,
such as the `promptMessageId` which we'll see below.

[**See the full list of AI SDK arguments here**](https://ai-sdk.dev/docs/reference/ai-sdk-core/generate-text)

The message history will be provided by default as context from the given
[thread](./threads.mdx). See [LLM Context](./context.mdx) for details on how to
configuring the context provided.

Note: `authorizeThreadAccess` referenced below is a function you would write to
authenticate and authorize the user to access the thread. You can see an example
implementation in
[threads.ts](https://github.com/get-convex/agent/blob/main/example/convex/threads.ts).

See
[chat/basic.ts](https://github.com/get-convex/agent/blob/main/example/convex/chat/basic.ts)
or
[chat/streaming.ts](https://github.com/get-convex/agent/blob/main/example/convex/chat/streaming.ts)
for live code examples.

### Streaming text

Streaming text follows the same pattern as the approach below, but with a few
differences, depending on the type of streaming you're doing. See
[streaming](./streaming.mdx) for more details.

### Basic approach (synchronous)

```ts
export const generateReplyToPrompt = action({
  args: { prompt: v.string(), threadId: v.string() },
  handler: async (ctx, { prompt, threadId }) => {
    // await authorizeThreadAccess(ctx, threadId);
    const result = await agent.generateText(ctx, { threadId }, { prompt });
    return result.text;
  },
});
```

Note: best practice is to not rely on returning data from the action. Instead,
query for the thread messages via the `useThreadMessages` hook and receive the
new message automatically. See below.

### Saving the prompt then generating response(s) asynchronously

While the above approach is simple, generating responses asynchronously provide
a few benefits:

- You can set up optimistic UI updates on mutations that are transactional, so
  the message will be shown optimistically on the client until the message is
  saved and present in your message query.
- You can save the message in the same mutation (transaction) as other writes to
  the database. This message can then be used and re-used in an action with
  retries, without duplicating the prompt message in the history. If the
  `promptMessageId` is used for multiple generations, any previous responses
  will automatically be included as context, so the LLM can continue where it
  left off. See [workflows](./workflows.mdx) for more details.
- Thanks to the idempotent guarantees of mutations, the client can safely retry
  mutations for days until they run exactly once. Actions can transiently fail.

Any clients listing the messages will automatically get the new messages as they
are created asynchronously.

To generate responses asynchronously, you need to first save the message, then
pass the `messageId` as `promptMessageId` to generate / stream text.

```ts
import { components, internal } from "./_generated/api";
import { saveMessage } from "@convex-dev/agent";
import { internalAction, mutation } from "./_generated/server";
import { v } from "convex/values";

// Step 1: Save a user message, and kick off an async response.
export const sendMessage = mutation({
  args: { threadId: v.id("threads"), prompt: v.string() },
  handler: async (ctx, { threadId, prompt }) => {
    const { messageId } = await saveMessage(ctx, components.agent, {
      threadId,
      prompt,
    });
    await ctx.scheduler.runAfter(0, internal.example.generateResponseAsync, {
      threadId,
      promptMessageId: messageId,
    });
  },
});

// Step 2: Generate a response to a user message.
export const generateResponseAsync = internalAction({
  args: { threadId: v.string(), promptMessageId: v.string() },
  handler: async (ctx, { threadId, promptMessageId }) => {
    await agent.generateText(ctx, { threadId }, { promptMessageId });
  },
});
```

Note that the action doesn't need to return anything. All messages are saved by
default, so any client subscribed to the thread messages will receive the new
message as it is generated asynchronously.

### Generating an object

Similar to the AI SDK, you can generate or stream an object. The same arguments
apply, except you don't have to provide a model. It will use the agent's default
language model.

```ts
import { z } from "zod/v3";

const result = await thread.generateObject({
  prompt: "Generate a plan based on the conversation so far",
  schema: z.object({...}),
});
```

Unfortunately, object generation doesn't support using tools. One, however, is
to structure your object as arguments to a tool call that returns the object.
You can use a custom `stopWhen` to stop the generation when the tool call
produces the result and use `toolChoice: "required"` to prevent the LLM from
returning a text response.

## Customizing the agent

The agent by default only needs a `chat` model to be configured. However, for
vector search, you'll need a `textEmbeddingModel` model. A `name` is helpful to
attribute each message to a specific agent. Other options are defaults that can
be over-ridden at each LLM call-site.

```ts
import { tool, stepCountIs } from "ai";
import { openai } from "@ai-sdk/openai";
import { z } from "zod/v3";
import { Agent, createTool, type Config } from "@convex-dev/agent";
import { components } from "./_generated/api";

const sharedDefaults = {
  // The language model to use for the agent.
  languageModel: openai.chat("gpt-4o-mini"),
  // Embedding model to power vector search of message history (RAG).
  textEmbeddingModel: openai.embedding("text-embedding-3-small"),
  // Used for fetching context messages. See https://docs.convex.dev/agents/context
  contextOptions,
  // Used for storing messages. See https://docs.convex.dev/agents/messages
  storageOptions,
  // Used for tracking token usage. See https://docs.convex.dev/agents/usage-tracking
  usageHandler: async (ctx, args) => {
    const { usage, model, provider, agentName, threadId, userId } = args;
    // ... log, save usage to your database, etc.
  },
  // Used for filtering, modifying, or enriching the context messages. See https://docs.convex.dev/agents/context
  contextHandler: async (ctx, args) => {
    return [...customMessages, args.allMessages];
  },
  // Useful if you want to log or record every request and response.
  rawResponseHandler: async (ctx, args) => {
    const { request, response, agentName, threadId, userId } = args;
    // ... log, save request/response to your database, etc.
  },
  // Used for limiting the number of retries when a tool call fails. Default: 3.
  callSettings: { maxRetries: 3, temperature: 1.0 },
} satisfies Config;


const supportAgent = new Agent(components.agent, {
  // The default system prompt if not over-ridden.
  instructions: "You are a helpful assistant.",
  tools: {
    // Convex tool. See https://docs.convex.dev/agents/tools
    myConvexTool: createTool({
      description: "My Convex tool",
      args: z.object({...}),
      // Note: annotate the return type of the handler to avoid type cycles.
      handler: async (ctx, args): Promise<string> => {
        return "Hello, world!";
      },
    }),
    // Standard AI SDK tool
    myTool: tool({ description, parameters, execute: () => {}}),
  },
  // Used for limiting the number of steps when tool calls are involved.
  // NOTE: if you want tool calls to happen automatically with a single call,
  // you need to set this to something greater than 1 (the default).
  stopWhen: stepCountIs(5),
  ...sharedDefaults,
});
```



================================================
FILE: npm-packages/docs/docs/agents/context.mdx
================================================
---
title: LLM Context
sidebar_label: "LLM Context"
sidebar_position: 600
description: "Customizing the context provided to the Agent's LLM"
---

By default, the Agent will provide context based on the message history of the
thread. This context is used to generate the next message.

The context can include recent messages, as well as messages found via text and
/or vector search.

If a `promptMessageId` is provided, the context will include that message, as
well as any other messages on that same `order`. More details on order are in
[messages.mdx](./messages.mdx#message-ordering), but in practice this means that
if you pass the ID of the user-submitted message as the `promptMessageId` and
there had already been some assistant and/or tool responses, those will be
included in the context, allowing the LLM to continue the conversation.

You can also use [RAG](./rag.mdx) to add extra context to your prompt.

## Customizing the context

You can customize the context provided to the agent when generating messages
with custom `contextOptions`. These can be set as defaults on the `Agent`, or
provided at the call-site for `generateText` or others.

```ts
const result = await agent.generateText(
  ctx,
  { threadId },
  { prompt },
  {
    // Values shown are the defaults.
    contextOptions: {
      // Whether to exclude tool messages in the context.
      excludeToolMessages: true,
      // How many recent messages to include. These are added after the search
      // messages, and do not count against the search limit.
      recentMessages: 100,
      // Options for searching messages via text and/or vector search.
      searchOptions: {
        limit: 10, // The maximum number of messages to fetch.
        textSearch: false, // Whether to use text search to find messages.
        vectorSearch: false, // Whether to use vector search to find messages.
        // Note, this is after the limit is applied.
        // E.g. this will quadruple the number of messages fetched.
        // (two before, and one after each message found in the search)
        messageRange: { before: 2, after: 1 },
      },
      // Whether to search across other threads for relevant messages.
      // By default, only the current thread is searched.
      searchOtherThreads: false,
    },
  },
);
```

## Full context control

To have full control over which messages are passed to the LLM, you can either:

1. Provide a `contextHandler` to filter, modify, or enrich the context messages.
2. Provide all messages manually via the `messages` argument and specify
   `contextOptions` to use no recent or search messages. See below for how to
   fetch context messages manually.

### Providing a contextHandler

The Agent will combine messages from search, recent, input messages, and all
messages on the same `order` as the `promptMessageId` if that is provided.

You can customize how they are combined, as well as add or remove messages by
providing a `contextHandler` which returns the `ModelMessage[]` which will be
passed to the LLM.

You can specify a `contextHandler` in the Agent constructor, or at the call-site
for a single generation, which overrides any Agent default.

```ts
const myAgent = new Agent(components.agent, {
  ///...
  contextHandler: async (ctx, args) => {
    // This is the default behavior.
    return [
      ...args.search,
      ...args.recent,
      ...args.inputMessages,
      ...args.inputPrompt,
      ...args.existingResponses,
    ];
    // Equivalent to:
    return args.allMessages;
  },
);
```

With this callback, you can:

1. Filter out messages you don't want to include.
1. Add memories or other context.
1. Add sample messages to guide the LLM on how it should respond.
1. Inject extra context based on the user or thread.
1. Copy in messages from other threads.
1. Summarize messages.

For example:

```ts
// Note: when you specify it at the call-site, you can also leverage variables
// available in the scope, e.g. if the user is in a specific step in a workflow.
const result = await agent.generateText(
  ctx,
  { threadId },
  { prompt },
  {
    contextHandler: async (ctx, args) => {
      // Filter out messages that are not relevant.
      const relevantSearch = args.search.filter((m) => messageIsRelevant(m));
      // Fetch user memories to include in every prompt.
      const userMemories = await getUserMemories(ctx, args.userId);
      // Fetch sample messages to instruct the LLM on how to respond.
      const sampleMessages = [
        { role: "user", content: "Generate a function that adds two numbers" },
        { role: "assistant", content: "function add(a, b) { return a + b; }" },
      ];
      // Fetch user context to include in every prompt.
      const userContext = await getUserContext(ctx, args.userId, args.threadId);
      // Fetch messages from a related / parent thread.
      const related = await getRelatedThreadMessages(ctx, args.threadId);
      return [
        // Summarize or truncate context messages if they are too long.
        ...(await summarizeOrTruncateIfTooLong(related)),
        ...relevantSearch,
        ...userMemories,
        ...sampleMessages,
        ...userContext,
        ...args.recent,
        ...args.inputMessages,
        ...args.inputPrompt,
        ...args.existingResponses,
      ];
    },
  },
);
```

### Fetch context manually

If you want to get context messages for a given prompt, without calling the LLM,
you can use `fetchContextWithPrompt`. This is used internally to get the context
messages passed to the AI SDK `generateText`, `streamText`, etc.

As with normal generation, you can provide a `prompt` or `messages`, and/or a
`promptMessageId` to fetch the context messages using a given pre-saved message
as the prompt.

This will return recent and search messages combined with the input messages.

```ts
import { fetchContextWithPrompt } from "@convex-dev/agent";

const { messages } = await fetchContextWithPrompt(ctx, components.agent, {
  prompt,
  messages,
  promptMessageId,
  userId,
  threadId,
  contextOptions,
});
```

## Search for messages

This is what the agent does automatically, but it can be useful to do manually,
e.g. to find custom context to include.

For text and vector search, you can provide a `targetMessageId` and/or
`searchText`. It will embed the text for vector search. If `searchText` is not
provided, it will use the target message's text.

If `targetMessageId` is provided, it will only fetch search messages previous to
that message, and recent messages up to and including that message's "order".
This enables re-generating a response for an earlier message.

```ts
import type { MessageDoc } from "@convex-dev/agent";

const messages: MessageDoc[] = await agent.fetchContextMessages(ctx, {
  threadId,
  searchText: prompt, // Optional unless you want text/vector search.
  targetMessageId: promptMessageId, // Optionally target the search.
  userId, // Optional, unless `searchOtherThreads` is true.
  contextOptions, // Optional, defaults are used if not provided.
});
```

Note: you can also search for messages without an agent. The main difference is
that in order to do vector search, you need to create the embeddings yourself,
and it will not run your usage handler.

```ts
import { fetchRecentAndSearchMessages } from "@convex-dev/agent";

const { recentMessages, searchMessages } = await fetchRecentAndSearchMessages(
  ctx,
  components.agent,
  {
    threadId,
    searchText: prompt, // Optional unless you want text/vector search.
    targetMessageId: promptMessageId, // Optionally target the search.
    contextOptions, // Optional, defaults are used if not provided.
    getEmbedding: async (text) => {
      const embedding = await textEmbeddingModel.embed(text);
      return { embedding, textEmbeddingModel };
    },
  },
);
```

## Searching other threads

If you set `searchOtherThreads` to `true`, the agent will search across all
threads belonging to the provided `userId`. This can be useful to have multiple
conversations that the Agent can reference.

The search will use a hybrid of text and vector search.

## Passing in messages as context

You can pass in messages as context to the Agent's LLM, for instance to
implement [Retrieval-Augmented Generation](./rag.mdx). The final messages sent
to the LLM will be:

1. The system prompt, if one is provided or the agent has `instructions`
2. The messages found via contextOptions
3. The `messages` argument passed into `generateText` or other function calls.
4. If a `prompt` argument was provided, a final
   `{ role: "user", content: prompt }` message.

This allows you to pass in messages that are not part of the thread history and
will not be saved automatically, but that the LLM will receive as context.

## Manage embeddings manually

The `textEmbeddingModel` argument to the Agent constructor allows you to specify
a text embedding model to use for vector search.

If you set this, the agent will automatically generate embeddings for messages
and use them for vector search.

When you change models or decide to start or stop using embeddings for vector
search, you can manage the embeddings manually.

Generate embeddings for a set of messages. Optionally pass `config` with a usage
handler, which can be a globally shared `Config`.

```ts
import { embedMessages } from "@convex-dev/agent";

const embeddings = await embedMessages(
  ctx,
  { userId, threadId, textEmbeddingModel, ...config },
  [{ role: "user", content: "What is love?" }],
);
```

Generate and save embeddings for existing messages.

```ts
const embeddings = await supportAgent.generateAndSaveEmbeddings(ctx, {
  messageIds,
});
```

Get and update embeddings, e.g. for a migration to a new model.

```ts
const messages = await ctx.runQuery(components.agent.vector.index.paginate, {
  vectorDimension: 1536,
  targetModel: "gpt-4o-mini",
  cursor: null,
  limit: 10,
});
```

Updating the embedding by ID.

```ts
const messages = await ctx.runQuery(components.agent.vector.index.updateBatch, {
  vectors: [{ model: "gpt-4o-mini", vector: embedding, id: msg.embeddingId }],
});
```

Note: If the dimension changes, you need to delete the old and insert the new.

Delete embeddings

```ts
await ctx.runMutation(components.agent.vector.index.deleteBatch, {
  ids: [embeddingId1, embeddingId2],
});
```

Insert embeddings

```ts
const ids = await ctx.runMutation(components.agent.vector.index.insertBatch, {
  vectorDimension: 1536,
  vectors: [
    {
      model: "gpt-4o-mini",
      table: "messages",
      userId: "123",
      threadId: "123",
      vector: embedding,
      // Optional, if you want to update the message with the embeddingId
      messageId: messageId,
    },
  ],
});
```



================================================
FILE: npm-packages/docs/docs/agents/debugging.mdx
================================================
---
title: Debugging
sidebar_label: "Debugging"
sidebar_position: 1100
description: "Debugging the Agent component"
---

## Debugging in the Playground

Generally the [Playground](./playground.mdx) gives a lot of information about
what's happening, but when that is insufficient, you have other options.

## Logging the raw request and response from LLM calls

You can provide a `rawRequestResponseHandler` to the agent to log the raw
request and response from the LLM.

You could use this to log the request and response to a table, or use console
logs with
[Log Streaming](https://docs.convex.dev/production/integrations/log-streams/) to
allow debugging and searching through Axiom or another logging service.

```ts
const supportAgent = new Agent(components.agent, {
  ...
  rawRequestResponseHandler: async (ctx, { request, response }) => {
    console.log("request", request);
    console.log("response", response);
  },
});
```

## Logging the context messages via the contextHandler

You can log the context messages via the contextHandler, if you're curious what
exactly the LLM is receiving.

```ts
const supportAgent = new Agent(components.agent, {
  ...
  contextHandler: async (ctx, { allMessages }) => {
    console.log("context", allMessages);
    return allMessages;
  },
});
```

## Inspecting the database in the dashboard

You can go to the Data tab in the dashboard and select the agent component above
the table list to see the Agent data. The organization of the tables matches the
[schema](https://github.com/get-convex/agent/blob/main/src/component/schema.ts).
The most useful tables are:

- `threads` has one row per thread
- `messages` has a separate row for each ModelMessage - e.g. a user message,
  assistant tool call, tool result, assistant message, etc. The most important
  fields are `agentName` for which agent it's associated with, `status`, `order`
  and `stepOrder` which are used to order the messages, and `message` which is
  roughly what is passed to the LLM.
- `streamingMessages` has an entry for each streamed message, until it's cleaned
  up. You can take the ID to look at the associated `streamDeltas` table.
- `files` captures the files tracked by the Agent from content that was sent in
  a message that got stored in File Storage.

## Troubleshooting

### Type errors on `components.agent`

If you get type errors about `components.agent`, ensure you've run
`npx convex dev` to generate code for the component. The types expected by the
library are in the npm library, and the types for `components.agent` currently
come from generated code in your project (via `npx convex dev`).

### Circular dependencies

Having the return value of workflows depend on other Convex functions can lead
to circular dependencies due to the `internal.foo.bar` way of specifying
functions. The way to fix this is to explicitly type the return value of the
workflow. When in doubt, add return types to more `handler` functions, like
this:

```ts
export const supportAgentWorkflow = workflow.define({
  args: { prompt: v.string(), userId: v.string(), threadId: v.string() },
  // highlight-next-line
  handler: async (step, { prompt, userId, threadId }): Promise<string> => {
    // ...
  },
});

// And regular functions too:
export const myFunction = action({
  args: { prompt: v.string() },
  // highlight-next-line
  handler: async (ctx, { prompt }): Promise<string> => {
    // ...
  },
});
```



================================================
FILE: npm-packages/docs/docs/agents/files.mdx
================================================
---
title: Files and Images in Agent messages
sidebar_label: "Files"
sidebar_position: 1000
description: "Working with images and files in the Agent component"
---

You can add images and files for the LLM to reference in the messages.

NOTE: Sending URLs to LLMs is much easier with the cloud backend, since it has
publicly available storage URLs. To develop locally you can use `ngrok` or
similar to proxy the traffic.

Example code:

- [files/autoSave.ts](https://github.com/get-convex/agent/blob/main/example/convex/files/autoSave.ts)
  has a simple example of how to use the automatic file saving.
- [files/addFile.ts](https://github.com/get-convex/agent/blob/main/example/convex/files/addFile.ts)
  has an example of how to save the file, submit a question, and generate a
  response in separate steps.
- [files/generateImage.ts](https://github.com/get-convex/agent/blob/main/example/convex/files/generateImage.ts)
  has an example of how to generate an image and save it in an assistant
  message.
- [FilesImages.tsx](https://github.com/get-convex/agent/blob/main/example/ui/files/FilesImages.tsx)
  has client-side code.

## Running the example

```sh
git clone https://github.com/get-convex/agent.git
cd agent
npm run setup
npm run dev
```

## Sending an image by uploading first and generating asynchronously

The standard approach is to:

1. Upload the file to the database (`uploadFile` action). Note: this can be in a
   regular action or in an httpAction, depending on what's more convenient.
2. Send a message to the thread (`submitFileQuestion` action)
3. Send the file to the LLM to generate / stream text asynchronously
   (`generateResponse` action)
4. Query for the messages from the thread (`listThreadMessages` query)

Rationale:

It's better to submit a message in a mutation vs. an action because you can use
an optimistic update on the client side to show the sent message immediately and
have it disappear exactly when the message comes down in the query.

However, you can't save to file storage from a mutation, so the file needs to
already exist (hence the fileId).

You can then asynchronously generate the response (with retries / etc) without
the client waiting.

### 1: Saving the file

```ts
import { storeFile } from "@convex-dev/agent";
import { components } from "./_generated/api";

const { file } = await storeFile(
  ctx,
  components.agent,
  new Blob([bytes], { type: mimeType }),
  {
    filename,
    sha256,
  },
);
const { fileId, url, storageId } = file;
```

### 2: Sending the message

```ts
// in your mutation
const { filePart, imagePart } = await getFile(ctx, components.agent, fileId);
const { messageId } = await fileAgent.saveMessage(ctx, {
  threadId,
  message: {
    role: "user",
    content: [
      imagePart ?? filePart, // if it's an image, prefer that kind.
      { type: "text", text: "What is this image?" },
    ],
  },
  metadata: { fileIds: [fileId] }, // IMPORTANT: this tracks the file usage.
});
```

### 3: Generating the response & querying the responses

This is done in the same way as text inputs.

```ts
// in an action
await thread.generateText({ promptMessageId: messageId });
```

```ts
// in a query
const messages = await agent.listMessages(ctx, { threadId, paginationOpts });
```

## Inline saving approach

You can also pass in an image / file direction when generating text, if you're
in an action. Any image or file passed in the `message` argument will
automatically be saved in file storage if it's larger than 64k, and a fileId
will be saved to the message.

Example:

```ts
await thread.generateText({
  message: {
    role: "user",
    content: [
      { type: "image", image: imageBytes, mimeType: "image/png" },
      { type: "text", text: "What is this image?" },
    ],
  },
});
```

## Under the hood

Saving to the files has 3 components:

1. Saving to file storage (in your app, not in the component's storage). This
   means you can access it directly with the `storageId` and generate URLs.
2. Saving a reference (the storageId) to the file in the component. This will
   automatically keep track of how many messages are referencing the file, so
   you can vacuum files that are no longer used (see
   [files/vacuum.ts](https://github.com/get-convex/agent/blob/main/example/convex/files/vacuum.ts)).
3. Inserting a URL in place of the data in the message sent to the LLM, along
   with the mimeType and other metadata provided. It will be inferred if not
   provided in
   [`guessMimeType`](https://github.com/get-convex/agent/blob/main/src/mapping.ts#L556).

### Can I just store the file myself and pass in a URL?

Yes! You can always pass a URL in the place of an image or file to the LLM.

```ts
const storageId = await ctx.storage.store(blob);
const url = await ctx.storage.getUrl(storageId);

await thread.generateText({
  message: {
    role: "user",
    content: [
      { type: "image", data: url, mimeType: blob.type },
      { type: "text", text: "What is this image?" },
    ],
  },
});
```

## Generating images

There's an example in
[files/generateImage.ts](https://github.com/get-convex/agent/blob/main/example/convex/files/generateImage.ts)
that takes a prompt, generates an image with OpenAI's dall-e 2, then saves the
image to a thread.

You can try it out with:

```sh
npx convex run files:generateImage:replyWithImage '{prompt: "make a picture of a cat" }'
```



================================================
FILE: npm-packages/docs/docs/agents/getting-started.mdx
================================================
---
title: "Getting Started with Agent"
sidebar_label: "Getting Started"
sidebar_position: 100
description: "Setting up the agent component"
---

To install the agent component, you'll need an existing Convex project. New to
Convex? Go through the [tutorial](https://docs.convex.dev/tutorial/).

Run `npm create convex` or follow any of the
[quickstarts](https://docs.convex.dev/home) to set one up.

## Installation

Install the component package:

```ts
npm install @convex-dev/agent
```

Create a `convex.config.ts` file in your app's `convex/` folder and install the
component by calling `use`:

```ts
// convex/convex.config.ts
import { defineApp } from "convex/server";
import agent from "@convex-dev/agent/convex.config";

const app = defineApp();
app.use(agent);

export default app;
```

Then run `npx convex dev` to generate code for the component. This needs to
successfully run once before you start defining Agents.

## Defining your first Agent

```ts
import { components } from "./_generated/api";
import { Agent } from "@convex-dev/agent";
import { openai } from "@ai-sdk/openai";

const agent = new Agent(components.agent, {
  name: "My Agent",
  languageModel: openai.chat("gpt-4o-mini"),
  instructions: "You are a weather forecaster.",
  tools: { getWeather, getGeocoding },
  maxSteps: 3,
});
```

## Basic usage

```ts
import { action } from "./_generated/server";
import { v } from "convex/values";

export const helloWorld = action({
  args: { city: v.string() },
  handler: async (ctx, { city }) => {
    const threadId = await createThread(ctx, components.agent);
    const prompt = `What is the weather in ${city}?`;
    const result = await agent.generateText(ctx, { threadId }, { prompt });
    return result.text;
  },
});
```

If you get type errors about `components.agent`, ensure you've run
`npx convex dev` to generate code for the component.

That's it! Check out [Agent Usage](./agent-usage.mdx) to see more details and
options.



================================================
FILE: npm-packages/docs/docs/agents/human-agents.mdx
================================================
---
title: Human Agents
sidebar_label: "Human Agents"
sidebar_position: 900
description: "Saving messages from a human as an agent"
---

The Agent component generally takes a prompt from a human or agent, and uses an
LLM to generate a response.

However, there are cases where you want to generate the reply from a human
acting as an agent, such as for customer support.

For full code, check out
[chat/human.ts](https://github.com/get-convex/agent/blob/main/example/convex/chat/human.ts)

## Saving a user message without generating a reply

You can save a message from a user without generating a reply by using the
`saveMessage` function.

```ts
import { saveMessage } from "@convex-dev/agent";
import { components } from "./_generated/api";

await saveMessage(ctx, components.agent, {
  threadId,
  prompt: "The user message",
});
```

## Saving a message from a human as an agent

Similarly, you can save a message from a human as an agent in the same way,
using the `message` field to specify the role and agent name:

```ts
import { saveMessage } from "@convex-dev/agent";
import { components } from "./_generated/api";

await saveMessage(ctx, components.agent, {
  threadId,
  agentName: "Alex",
  message: { role: "assistant", content: "The human reply" },
});
```

## Storing additional metadata about human agents

You can store additional metadata about human agents by using the `saveMessage`
function, and adding the `metadata` field.

```ts
await saveMessage(ctx, components.agent, {
  threadId,
  agentName: "Alex",
  message: { role: "assistant", content: "The human reply" },
  metadata: {
    provider: "human",
    providerMetadata: {
      human: {
        /* ... */
      },
    },
  },
});
```

## Deciding who responds next

You can choose whether the LLM or human responds next in a few ways:

1. Explicitly store in the database whether the user or LLM is assigned to the
   thread.
2. Using a call to a cheap and fast LLM to decide if the user question requires
   a human response.
3. Using vector embeddings of the user question and message history to make the
   decision, based on a corpus of sample questions and what questions are better
   handled by humans.
4. Have the LLM generate an object response that includes a field indicating
   whether the user question requires a human response.
5. Providing a tool to the LLM to decide if the user question requires a human
   response. The human response is then the tool response message.

## Human responses as tool calls

You can have the LLM generate a tool call to a human agent to provide context to
answer the user question by providing a tool that doesn't have a handler. Note:
this generally happens when the LLM still intends to answer the question, but
needs human intervention to do so, such as confirmation of a fact.

```ts
import { tool } from "ai";
import { z } from "zod/v3";

const askHuman = tool({
  description: "Ask a human a question",
  parameters: z.object({
    question: z.string().describe("The question to ask the human"),
  }),
});

export const ask = action({
  args: { question: v.string(), threadId: v.string() },
  handler: async (ctx, { question, threadId }) => {
    const result = await agent.generateText(
      ctx,
      { threadId },
      {
        prompt: question,
        tools: { askHuman },
      },
    );
    const supportRequests = result.toolCalls
      .filter((tc) => tc.toolName === "askHuman")
      .map(({ toolCallId, args: { question } }) => ({
        toolCallId,
        question,
      }));
    if (supportRequests.length > 0) {
      // Do something so the support agent knows they need to respond,
      // e.g. save a message to their inbox
      // await ctx.runMutation(internal.example.sendToSupport, {
      //   threadId,
      //   supportRequests,
      // });
    }
  },
});

export const humanResponseAsToolCall = internalAction({
  args: {
    humanName: v.string(),
    response: v.string(),
    toolCallId: v.string(),
    threadId: v.string(),
    messageId: v.string(),
  },
  handler: async (ctx, args) => {
    await agent.saveMessage(ctx, {
      threadId: args.threadId,
      message: {
        role: "tool",
        content: [
          {
            type: "tool-result",
            result: args.response,
            toolCallId: args.toolCallId,
            toolName: "askHuman",
          },
        ],
      },
      metadata: {
        provider: "human",
        providerMetadata: {
          human: { name: args.humanName },
        },
      },
    });
    // Continue generating a response from the LLM
    await agent.generateText(
      ctx,
      { threadId: args.threadId },
      {
        promptMessageId: args.messageId,
      },
    );
  },
});
```



================================================
FILE: npm-packages/docs/docs/agents/messages.mdx
================================================
---
title: Messages
sidebar_label: "Messages"
sidebar_position: 300
description: "Sending and receiving messages with an agent"
---

The Agent component stores message and [thread](./threads.mdx) history to enable
conversations between humans and agents.

To see how humans can act as agents, see [Human Agents](./human-agents.mdx).

## Retrieving messages

For clients to show messages, you need to expose a query that returns the
messages. For streaming, see
[retrieving streamed deltas](./streaming.mdx#retrieving-streamed-deltas) for a
modified version of this query.

See
[chat/basic.ts](https://github.com/get-convex/agent/blob/main/example/convex/chat/basic.ts)
for the server-side code, and
[chat/streaming.ts](https://github.com/get-convex/agent/blob/main/example/convex/chat/streaming.ts)
for the streaming example.

```ts
import { paginationOptsValidator } from "convex/server";
import { v } from "convex/values";
import { listUIMessages } from "@convex-dev/agent";
import { components } from "./_generated/api";

export const listThreadMessages = query({
  args: { threadId: v.string(), paginationOpts: paginationOptsValidator },
  handler: async (ctx, args) => {
    await authorizeThreadAccess(ctx, threadId);

    const paginated = await listUIMessages(ctx, components.agent, args);

    // Here you could filter out / modify the documents
    return paginated;
  },
});
```

Note: Above we used `listUIMessages`, which returns UIMessages, specifically the
Agent extension that includes some extra fields like order, status, etc.
UIMessages combine multiple MessageDocs into a single UIMessage when there are
multiple tool calls followed by an assistant message, making it easy to build
UIs that work with the various "parts" on the UIMessage.

If you want to get MessageDocs, you can use `listMessages` instead.

## Showing messages in React

See
[ChatStreaming.tsx](https://github.com/get-convex/agent/blob/main/example/ui/chat/ChatStreaming.tsx)
for a streaming example, or
[ChatBasic.tsx](https://github.com/get-convex/agent/blob/main/example/ui/chat/ChatBasic.tsx)
for a non-streaming example.

### `useUIMessages` hook

The crux is to use the `useUIMessages` hook. For streaming, pass in
`stream: true` to the hook.

```tsx
import { api } from "../convex/_generated/api";
import { useUIMessages } from "@convex-dev/agent/react";

function MyComponent({ threadId }: { threadId: string }) {
  const { results, status, loadMore } = useUIMessages(
    api.chat.streaming.listMessages,
    { threadId },
    { initialNumItems: 10 /* stream: true */ },
  );
  return (
    <div>
      {results.map((message) => (
        <div key={message.key}>{message.text}</div>
      ))}
    </div>
  );
}
```

Note: If you want to work with MessageDocs instead of UIMessages, you can use
the older `useThreadMessages` hook instead. However, working with UIMessages
enables richer streaming capabilities, such as status on whether the agent is
actively reasoning.

### UIMessage type

The Agent component extends the AI SDK's `UIMessage` type to provide convenient
metadata for rendering messages.

The core UIMessage type from the AI SDK is:

- `parts` is an array of parts (e.g. "text", "file", "image", "toolCall",
  "toolResult")
- `content` is a string of the message content.
- `role` is the role of the message (e.g. "user", "assistant", "system").

The helper adds these additional fields:

- `key` is a unique identifier for the message.
- `order` is the order of the message in the thread.
- `stepOrder` is the step order of the message in the thread.
- `status` is the status of the message (or "streaming").
- `agentName` is the name of the agent that generated the message.
- `text` is the text of the message.
- `_creationTime` is the timestamp of the message. For streaming messages, it's
  currently assigned to the current time on the streaming client.

To reference these, ensure you're importing `UIMessage` from
`@convex-dev/agent`.

#### `toUIMessages` helper

`toUIMessages` is a helper function that transforms MessageDocs into AI SDK
"UIMessage"s. This is a convenient data model for displaying messages.

If you are using `useThreadMessages` for instance, you can convert the messages
to UIMessages like this:

```ts
import { toUIMessages, type UIMessage } from "@convex-dev/agent";

...
const { results } = useThreadMessages(...);
const uiMessages = toUIMessages(results);
```

### Optimistic updates for sending messages

The `optimisticallySendMessage` function is a helper function for sending a
message, so you can optimistically show a message in the message list until the
mutation has completed on the server.

Pass in the query that you're using to list messages, and it will insert the
ephemeral message at the top of the list.

```ts
const sendMessage = useMutation(
  api.streaming.streamStoryAsynchronously,
).withOptimisticUpdate(
  optimisticallySendMessage(api.streaming.listThreadMessages),
);
```

If your arguments don't include `{ threadId, prompt }` then you can use it as a
helper function in your optimistic update:

```ts
import { optimisticallySendMessage } from "@convex-dev/agent/react";

const sendMessage = useMutation(
  api.chatStreaming.streamStoryAsynchronously,
).withOptimisticUpdate(
  (store, args) => {
    optimisticallySendMessage(api.chatStreaming.listThreadMessages)(store, {
      threadId:
      prompt: /* change your args into the user prompt. */,
    })
  }
);
```

## Saving messages

By default, the Agent will save messages to the database automatically when you
provide them as a prompt, as well as all generated messages.

However, it is useful to save the prompt message ahead of time and use the
`promptMessageId` to continue the conversation. See
[Agent Usage](./agent-usage.mdx) for more details.

You can save messages to the database manually using `saveMessage` or
`saveMessages`, either on the Agent class or as a direct function call.

- You can pass a `prompt` or a full `message` (`ModelMessage` type)
- The `metadata` argument is optional and allows you to provide more details,
  such as `sources`, `reasoningDetails`, `usage`, `warnings`, `error`, etc.

```ts
const { messageId } = await saveMessage(ctx, components.agent, {
  threadId,
  userId,
  message: { role: "user", content: "The user message" },
});
```

Note: when calling `agent.generateText` with the raw prompt, embeddings are
generated automatically for vector search (if you have a text embedding model
configured). Similarly with `agent.saveMessage` when calling from an action.
However, if you're saving messages in a mutation, where calling an LLM is not
possible, it will generate them automatically if `generateText` receives a
`promptMessageId` that lacks an embedding (and you have a text embedding model
configured).

### Without the Agent class:

Note: If you aren't using the Agent class with a text embedding model set, you
need to pass an `embedding` if you want to save it at the same time.

```ts
import { saveMessage } from "@convex-dev/agent";

const { messageId } = await saveMessage(ctx, components.agent, {
  threadId,
  userId,
  message: { role: "assistant", content: result },
  metadata: [{ reasoning, usage, ... }] // See MessageWithMetadata type
  agentName: "my-agent",
  embedding: { vector: [0.1, 0.2, ...], model: "text-embedding-3-small" },
});
```

### Using the Agent class:

```ts
const { messageId } = await agent.saveMessage(ctx, {
  threadId,
  userId,
  prompt,
  metadata,
});
```

```ts
const { messages } = await agent.saveMessages(ctx, {
  threadId, userId,
  messages: [{ role, content }],
  metadata: [{ reasoning, usage, ... }] // See MessageWithMetadata type
});
```

If you are saving the message in a mutation and you have a text embedding model
set, pass `skipEmbeddings: true`. The embeddings for the message will be
generated lazily if the message is used as a prompt. Or you can provide an
embedding upfront if it's available, or later explicitly generate them using
`agent.generateEmbeddings`.

## Configuring the storage of messages

Generally the defaults are fine, but if you want to pass in multiple messages
and have them all saved (vs. just the last one), or avoid saving any input or
output messages, you can pass in a `storageOptions` object, either to the Agent
constructor or per-message.

The use-case for passing in multiple messages but not saving them is if you want
to include some extra messages for context to the LLM, but only the last message
is the user's actual request. e.g.
`messages = [...messagesFromRag, messageFromUser]`. The default is to save the
prompt and all output messages.

```ts
const result = await thread.generateText({ messages }, {
  storageOptions: {
    saveMessages: "all" | "none" | "promptAndOutput";
  },
});
```

## Message ordering

Each message has `order` and `stepOrder` fields, which are incrementing integers
specific to a thread.

When `saveMessage` or `generateText` is called, the message is added to the
thread's next `order` with a `stepOrder` of 0.

As response message(s) are generated in response to that message, they are added
at the same `order` with the next `stepOrder`.

To associate a response message with a previous message, you can pass in the
`promptMessageId` to `generateText` and others.

Note: if the `promptMessageId` is not the latest message in the thread, the
context for the message generation will not include any messages following the
`promptMessageId`.

## Deleting messages

You can delete messages by their `_id` (returned from `saveMessage` or
`generateText`) or `order` / `stepOrder`.

By ID:

```ts
await agent.deleteMessage(ctx, { messageId });
// batch delete
await agent.deleteMessages(ctx, { messageIds });
```

By order (start is inclusive, end is exclusive):

```ts
// Delete all messages with the same order as a given message:
await agent.deleteMessageRange(ctx, {
  threadId,
  startOrder: message.order,
  endOrder: message.order + 1,
});
// Delete all messages with order 1 or 2.
await agent.deleteMessageRange(ctx, { threadId, startOrder: 1, endOrder: 3 });
// Delete all messages with order 1 and stepOrder 2-4
await agent.deleteMessageRange(ctx, {
  threadId,
  startOrder: 1,
  startStepOrder: 2,
  endOrder: 2,
  endStepOrder: 5,
});
```

## Other utilities:

```ts
import { ... } from "@convex-dev/agent";
```

- `serializeDataOrUrl` is a utility function that serializes an AI SDK
  `DataContent` or `URL` to a Convex-serializable format.
- `filterOutOrphanedToolMessages` is a utility function that filters out tool
  call messages that don't have a corresponding tool result message.
- `extractText` is a utility function that extracts text from a
  `ModelMessage`-like object.

### Validators and types

There are types to validate and provide types for various values

```ts
import { ... } from "@convex-dev/agent";
```

- `vMessage` is a validator for a `ModelMessage`-like object (with a `role` and
  `content` field e.g.).
- `MessageDoc` and `vMessageDoc` are the types for a message (which includes a
  `.message` field with the `vMessage` type).
- `Thread` is the type of a thread returned from `continueThread` or
  `createThread`.
- `ThreadDoc` and `vThreadDoc` are the types for thread metadata.
- `AgentComponent` is the type of the installed component (e.g.
  `components.agent`).
- `ToolCtx` is the `ctx` type for calls to `createTool` tools.



================================================
FILE: npm-packages/docs/docs/agents/playground.mdx
================================================
---
title: Playground
sidebar_label: "Playground"
sidebar_position: 400
description: "A simple way to test, debug, and develop with the agent"
---

The Playground UI is a simple way to test, debug, and develop with the agent.

![Playground UI Screenshot](https://get-convex.github.io/agent/screenshot.png)

- Pick a user to list their threads.
- Browse the user's threads.
- List the selected thread's messages, along with tool call details.
- Show message metadata details.
- Experiment with contextual message lookup, adjusting context options.
- Send a message to the thread, with configurable saving options.
- It uses api keys to communicate securely with the backend.

There is also a [hosted version here](https://get-convex.github.io/agent/).

## Setup

**Note**: You must already have a Convex project set up with the Agent. See the
[docs](./getting-started.mdx) for setup instructions.

In your agent Convex project, make a file `convex/playground.ts` with:

```ts
import { definePlaygroundAPI } from "@convex-dev/agent";
import { components } from "./_generated/api";
import { weatherAgent, fashionAgent } from "./example";

/**
 * Here we expose the API so the frontend can access it.
 * Authorization is handled by passing up an apiKey that can be generated
 * on the dashboard or via CLI via:
 * npx convex run --component agent apiKeys:issue
 */
export const {
  isApiKeyValid,
  listAgents,
  listUsers,
  listThreads,
  listMessages,
  createThread,
  generateText,
  fetchPromptContext,
} = definePlaygroundAPI(components.agent, {
  agents: [weatherAgent, fashionAgent],
});
```

From in your project's repo, issue yourself an API key:

```sh
npx convex run --component agent apiKeys:issue '{name:"..."}'
```

Note: to generate multiple keys, give a different name to each key. To revoke
and reissue a key, pass the same name.

Then visit the [hosted version](https://get-convex.github.io/agent/).

It will ask for your Convex deployment URL, which can be found in `.env.local`.
It will also ask for your API key that you generated above. If you used a
different path for `convex/playground.ts` you can enter it. E.g. if you had
`convex/foo/bar.ts` where you exported the playground API, you'd put in
`foo/bar`.

## Running it locally

You can run the playground locally with:

```sh
npx @convex-dev/agent-playground
```

It uses the `VITE_CONVEX_URL` env variable, usually pulling it from .env.local.



================================================
FILE: npm-packages/docs/docs/agents/rag.mdx
================================================
---
title: RAG (Retrieval-Augmented Generation) with the Agent component
sidebar_label: "RAG"
sidebar_position: 700
description: "Examples of how to use RAG with the Convex Agent component"
---

The Agent component has built-in capabilities to search message history with
hybrid text & vector search. You can also use the RAG component to use other
data to search for context.

## What is RAG?

Retrieval-Augmented Generation (RAG) is a technique that allows an LLM to search
through custom knowledge bases to answer questions.

RAG combines the power of Large Language Models (LLMs) with knowledge retrieval.
Instead of relying solely on the model's training data, RAG allows your AI to:

- Search through custom documents and knowledge bases
- Retrieve relevant context for answering questions
- Provide more accurate, up-to-date, and domain-specific responses
- Cite sources and explain what information was used

## RAG Component

<div className="center-image" style={{ maxWidth: "560px" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/dGmtAmdAaFs?si=ce-M8pt6EWDZ8tfd"
    title="RAG Component YouTube Video"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>

The RAG component is a Convex component that allows you to add data that you can
search. It breaks up the data into chunks and generates embeddings to use for
vector search. See the [RAG component docs](https://convex.dev/components/rag)
for details, but here are some key features:

- **Namespaces:** Use namespaces for user-specific or team-specific data to
  isolate search domains.
- **Add Content**: Add or replace text content by key.
- **Semantic Search**: Vector-based search using configurable embedding models
- **Custom Filtering:** Define filters on each document for efficient vector
  search.
- **Chunk Context**: Get surrounding chunks for better context.
- **Importance Weighting**: Weight content by providing a 0 to 1 "importance" to
  affect per-document vector search results.
- **Chunking flexibility:** Bring your own document chunking, or use the
  default.
- **Graceful Migrations**: Migrate content or whole namespaces without
  disruption.

import { ComponentCardList } from "@site/src/components/ComponentCard";

<ComponentCardList
  items={[
    {
      title: "RAG (Retrieval-Augmented Generation)",
      description:
        "Search documents for relevant content to prompt an LLM using embeddings.",
      href: "https://www.convex.dev/components/rag",
    },
  ]}
/>

## RAG Approaches

This directory contains two different approaches to implementing RAG:

### 1. Prompt-based RAG

A straightforward implementation where the system automatically searches for
relevant context for a user query.

- The message history will only include the original user prompt and the
  response, not the context.
- Looks up the context and injects it into the user's prompt.
- Works well if you know the user's question will _always_ benefit from extra
  context.

For example code, see
[ragAsPrompt.ts](https://github.com/get-convex/agent/blob/main/example/convex/rag/ragAsPrompt.ts)
for the overall code. The simplest version is:

```ts
const context = await rag.search(ctx, {
  namespace: "global",
  query: userPrompt,
  limit: 10,
});

const result = await agent.generateText(
  ctx,
  { threadId },
  {
    prompt: `# Context:\n\n ${context.text}\n\n---\n\n# Question:\n\n"""${userPrompt}\n"""`,
  },
);
```

### 2. Tool-based RAG

The LLM can intelligently decide when to search for context or add new
information by providing a tool to search for context.

- The message history will include the original user prompt and message history.
- After a tool call and response, the message history will include the tool call
  and response for the LLM to reference.
- The LLM can decide when to search for context or add new information.
- This works well if you want the Agent to be able to dynamically search.

See
[ragAsTools.ts](https://github.com/get-convex/agent/blob/main/example/convex/rag/ragAsTools.ts)
for the code. The simplest version is:

```ts
searchContext: createTool({
  description: "Search for context related to this user prompt",
  args: z.object({ query: z.string().describe("Describe the context you're looking for") }),
  handler: async (ctx, { query }) => {
    const context = await rag.search(ctx, { namespace: userId, query });
    return context.text;
  },
}),
```

## Key Differences

| Feature            | Basic RAG                    | Tool-based RAG                         |
| ------------------ | ---------------------------- | -------------------------------------- |
| **Context Search** | Always searches              | AI decides when to search              |
| **Adding Context** | Manual via separate function | AI can add context during conversation |
| **Flexibility**    | Simple, predictable          | Intelligent, adaptive                  |
| **Use Case**       | FAQ systems, document search | Dynamic knowledge management           |
| **Predictability** | Defined by code              | AI may query too much or little        |

## Ingesting content

On the whole, the RAG component works with text. However, you can turn other
files into text, either using parsing tools or asking an LLM to do it.

### Parsing images

Image parsing does oddly well with LLMs. You can use `generateText` to describe
and transcribe the image, and then use that description to search for relevant
context. And by storing the associated image, you can then pass the original
file around once you've retrieved it via searching.

[See an example here](https://github.com/get-convex/rag/blob/main/example/convex/getText.ts#L28-L42).

```ts
const description = await thread.generateText({
  message: {
    role: "user",
    content: [{ type: "image", data: url, mimeType: blob.type }],
  },
});
```

### Parsing PDFs

For PDF parsing, I suggest using Pdf.js in the browser.

**Why not server-side?**

Opening up the pdf can use hundreds of MB of memory, and requires downloading a
big pdfjs bundle - so big it's usually fetched dynamically in practice. You
probably wouldn't want to load that bundle on every function call server-side,
and you're more limited on memory usage in serverless environments. If the
browser already has the file, it's a pretty good environment to do the heavy
lifting in (and free!).

There's an example in
[the RAG demo](https://github.com/get-convex/rag/blob/main/example/src/pdfUtils.ts#L14),
[used in the UI here](https://github.com/get-convex/rag/blob/main/example/src/components/UploadSection.tsx#L51),
[with Pdf.js served statically](https://github.com/get-convex/rag/blob/main/example/public/pdf-worker/).

If you really want to do it server-side and don't worry about cost or latency,
you can pass it to an LLM, but note it takes a long time for big files.

[See an example here](https://github.com/get-convex/rag/blob/main/example/convex/getText.ts#L50-L65).

### Parsing text files

Generally you can use text files directly, for code or markdown or anything with
a natural structure an LLM can understand.

However, to get good embeddings, you can once again use an LLM to translate the
text into a more structured format.

[See an example here](https://github.com/get-convex/rag/blob/main/example/convex/getText.ts#L68-L89).

## Examples in Action

To see these examples in action, check out the
[RAG example](https://github.com/get-convex/rag/blob/main/example/convex/example.ts).

- Adding text, pdf, and image content to the RAG component
- Searching and generating text based on the context.
- Introspecting the context produced by searching.
- Browsing the chunks of documents produced.
- Try out searching globally, per-user, or with custom filters.

Run the example with:

```bash
git clone https://github.com/get-convex/rag.git
cd rag
npm run setup
npm run example
```



================================================
FILE: npm-packages/docs/docs/agents/rate-limiting.mdx
================================================
---
title: Rate Limiting
sidebar_label: "Rate Limiting"
sidebar_position: 1200
description: "Control the rate of requests to your AI agent"
---

Rate limiting is a way to control the rate of requests to your AI agent,
preventing abuse and managing API budgets.

To demonstrate using the
[Rate Limiter component](https://www.convex.dev/components/rate-limiter), there
is an example implementation you can run yourself.

It rate limits the number of messages a user can send in a given time period, as
well as the total token usage for a user. When a limit is exceeded, the client
can reactively tell the user how long to wait (even if they exceeded the limit
in another browser tab!).

For general usage tracking, see [Usage Tracking](./usage-tracking.mdx).

## Overview

The rate limiting example demonstrates two types of rate limiting:

1. **Message Rate Limiting**: Prevents users from sending messages too
   frequently
2. **Token Usage Rate Limiting**: Controls AI model token consumption over time

## Running the Example

```sh
git clone https://github.com/get-convex/agent.git
cd agent
npm run setup
npm run dev
```

Try sending multiple questions quickly to see the rate limiting in action!

## Rate Limiting Strategy

Below we'll go through each configuration. You can also see the full example
implementation in
[rateLimiting.ts](https://github.com/get-convex/agent/blob/main/example/convex/rate_limiting/rateLimiting.ts).

```ts
import { MINUTE, RateLimiter, SECOND } from "@convex-dev/rate-limiter";
import { components } from "./_generated/api";

export const rateLimiter = new RateLimiter(components.rateLimiter, {
  sendMessage: {
    kind: "fixed window",
    period: 5 * SECOND,
    rate: 1,
    capacity: 2,
  },
  globalSendMessage: { kind: "token bucket", period: MINUTE, rate: 1_000 },
  tokenUsagePerUser: {
    kind: "token bucket",
    period: MINUTE,
    rate: 2000,
    capacity: 10000,
  },
  globalTokenUsage: { kind: "token bucket", period: MINUTE, rate: 100_000 },
});
```

### 1. Fixed Window Rate Limiting for Messages

```ts
// export const rateLimiter = new RateLimiter(components.rateLimiter, {
sendMessage: { kind: "fixed window", period: 5 * SECOND, rate: 1, capacity: 2 }
```

- Allows 1 message every 5 seconds per user.
- Prevents spam and rapid-fire requests.
- Allows up to a 2 message burst to be sent within 5 seconds via `capacity`, if
  they had usage leftover from the previous 5 seconds.

Global limit:

```ts
globalSendMessage: { kind: "token bucket", period: MINUTE, rate: 1_000 },
```

- Allows 1000 messages per minute globally, to stay under the API limit.
- As a token bucket, it will continuously accrue tokens at the rate of 1000
  tokens per minute until it caps out at 1000. All available tokens can be used
  in quick succession.

### 2. Token Bucket Rate Limiting for Token Usage

```ts
tokenUsage: { kind: "token bucket", period: MINUTE, rate: 1_000 }
globalTokenUsage: { kind: "token bucket", period: MINUTE, rate: 100_000 },
```

- Allows 1000 tokens per minute per user (a userId is provided as the key), and
  100k tokens per minute globally.
- Provides burst capacity while controlling overall usage. If it hasn't been
  used in a while, you can consume all tokens at once. However, you'd then need
  need to wait for tokens to gradually accrue before making more requests.
- Having a per-user limit is useful to prevent single users from hogging all of
  the token bandwidth you have available with your LLM provider, while a global
  limit helps stay under the API limit without throwing an error midway through
  a potentially long multi-step request.

## How It Works

### Step 1: Pre-flight Rate Limit Checks

Before processing a question, the system:

1. Checks if the user can send another message (frequency limit)
2. Estimates token usage for the question
3. Verifies the user has sufficient token allowance
4. Throws an error if either limit would be exceeded
5. If the rate limits aren't exceeded, the LLM request is made.

See
[rateLimiting.ts](https://github.com/get-convex/agent/blob/main/example/convex/rate_limiting/rateLimiting.ts)
for the full implementation.

```ts
// In the mutation that would start generating a message.
await rateLimiter.limit(ctx, "sendMessage", { key: userId, throws: true });
// Also check global limit.
await rateLimiter.limit(ctx, "globalSendMessage", { throws: true });

// A heuristic based on the previous token usage in the thread + the question.
const count = await estimateTokens(ctx, args.threadId, args.question);
// Check token usage, but don't consume the tokens yet.
await rateLimiter.check(ctx, "tokenUsage", {
  key: userId,
  count: estimateTokens(args.question),
  throws: true,
});
// Also check global limit.
await rateLimiter.check(ctx, "globalTokenUsage", {
  count,
  reserve: true,
  throws: true,
});
```

If there is not enough allowance, the rate limiter will throw an error that the
client can catch and prompt the user to wait a bit before trying again.

The difference between `limit` and `check` is that `limit` will consume the
tokens immediately, while `check` will only check if the limit would be
exceeded. We actually mark the tokens as used once the request is complete with
the total usage.

### Step 2: Post-generation Usage Tracking

While rate limiting message sending frequency is a good way to prevent many
messages being sent in a short period of time, each message could generate a
very long response or use a lot of context tokens. For this we also track token
usage as its own rate limit.

After the AI generates a response, we mark the tokens as used using the total
usage. We use `reserve: true` to allow a (temporary) negative balance, in case
the generation used more tokens than estimated. A "reservation" here means
allocating tokens beyond what is allowed. Typically this is done ahead of time,
to "reserve" capacity for a big request that can be scheduled in advance. In
this case, we're marking capacity that has already been consumed. This prevents
future requests from starting until the "debt" is paid off.

When using the Agent component, we can do this in the "usageHandler", which is
called after the AI generates a response.

```ts
import { Agent, type Config } from "@convex-dev/rate-limiter";

const sharedConfig = {
  usageHandler: async (ctx, { usage, userId }) => {
    if (!userId) {
      return;
    }
    // We consume the token usage here, once we know the full usage.
    // This is too late for the first generation, but prevents further requests
    // until we've paid off that debt.
    await rateLimiter.limit(ctx, "tokenUsage", {
      key: userId,
      // You could weight different kinds of tokens differently here.
      count: usage.totalTokens,
      // Reserving the tokens means it won't fail here, but will allow it
      // to go negative, disallowing further requests at the `check` call below.
      reserve: true,
    });
  },
} satisfies Config;

// use it in your agent definitions
const agent = new Agent(components.agent, {
  name,
  languageModel,
  ...sharedConfig,
});
```

The "trick" here is that, while a user can make a request that exceeds the limit
for a single request, they then have to wait longer to accrue the tokens for
another request. So averaged over time they can't consume more than the rate
limit.

This balances pragmatism of trying to prevent requests ahead of time with an
estimate, while also rate limiting the actual usage.

## Client-side Handling

See
[RateLimiting.tsx](https://github.com/get-convex/agent/blob/main/example/ui/rate_limiting/RateLimiting.tsx)
for the client-side code.

While the client isn't the final authority on whether a request should be
allowed, it can still show a waiting message while the rate limit is being
checked, and an error message when the rate limit is exceeded. This prevents the
user from making attempts that are likely to fail.

It makes use of the `useRateLimit` hook to check the rate limits. See the full
[Rate Limiting docs here](https://www.convex.dev/components/rate-limiter).

```ts
import { useRateLimit } from "@convex-dev/rate-limiter/react";
//...
const { status } = useRateLimit(api.example.getRateLimit);
```

In `convex/example.ts` we expose `getRateLimit`:

```ts
export const { getRateLimit, getServerTime } = rateLimiter.hookAPI<DataModel>(
  "sendMessage",
  { key: (ctx) => getAuthUserId(ctx) },
);
```

Showing a waiting message while the rate limit is being checked:

```ts
{status && !status.ok && (
    <div className="text-xs text-gray-500 text-center">
    <p>Message sending rate limit exceeded.</p>
    <p>
        Try again after <Countdown ts={status.retryAt} />
    </p>
    </div>
)}
```

Showing an error message when the rate limit is exceeded:

```ts
import { isRateLimitError } from "@convex-dev/rate-limiter";

// in a button handler
await submitQuestion({ question, threadId }).catch((e) => {
  if (isRateLimitError(e)) {
    toast({
      title: "Rate limit exceeded",
      description: `Rate limit exceeded for ${e.data.name}.
          Try again after ${getRelativeTime(Date.now() + e.data.retryAfter)}`,
    });
  }
});
```

## Token Estimation

The example includes a simple token estimation function:

```ts
import { QueryCtx } from "./_generated/server";
import { fetchContextMessages } from "@convex-dev/agent";
import { components } from "./_generated/api";

// This is a rough estimate of the tokens that will be used.
// It's not perfect, but it's a good enough estimate for a pre-generation check.
export async function estimateTokens(
  ctx: QueryCtx,
  threadId: string | undefined,
  question: string,
) {
  // Assume roughly 4 characters per token
  const promptTokens = question.length / 4;
  // Assume a longer non-zero reply
  const estimatedOutputTokens = promptTokens * 3 + 1;
  const latestMessages = await fetchContextMessages(ctx, components.agent, {
    threadId,
    searchText: question,
    contextOptions: { recentMessages: 2 },
  });
  // Our new usage will roughly be the previous tokens + the question.
  // The previous tokens include the tokens for the full message history and
  // output tokens, which will be part of our new history.
  const lastUsageMessage = latestMessages
    .reverse()
    .find((message) => message.usage);
  const lastPromptTokens = lastUsageMessage?.usage?.totalTokens ?? 1;
  return lastPromptTokens + promptTokens + estimatedOutputTokens;
}
```



================================================
FILE: npm-packages/docs/docs/agents/streaming.mdx
================================================
---
title: Streaming
sidebar_label: "Streaming"
sidebar_position: 340
description: "Streaming messages with an agent"
---

Streaming messages is a great way to give a user feedback and keep an
application feeling responsive while using LLMs.

Traditionally streaming happens via HTTP streaming, where the client sends a
request and waits until the full response is streamed back. This works out of
the box when using the Agent, in the same way you would with the AI SDK. See
[below](#consuming-the-stream-yourself-with-the-agent) if that is all you're
looking for.

However, with the Agent component you can also stream messages asynchronously,
meaning the generation doesn't have to happen in an HTTP handler (`httpAction`),
and the response can be streamed back to one or more clients even if their
network connection is interrupted.

It works by saving the streaming parts to the database in groups (deltas), and
the clients subscribe to new deltas for the given thread, as they're generated.
As a bonus, you don't even need to use the Agent's version of `streamText` to
use the delta streaming approach (see
[below](#advanced-streaming-deltas-asynchronously-without-using-an-agent)).

Example:

- Server:
  [streaming.ts](https://github.com/get-convex/agent/blob/main/example/convex/chat/streaming.ts)
- Client:
  [ChatStreaming.tsx](https://github.com/get-convex/agent/blob/main/example/ui/chat/ChatStreaming.tsx)

## Streaming message deltas

The easiest way to stream is to pass `{ saveStreamDeltas: true }` to
`agent.streamText`. This will save chunks of the response as deltas as they're
generated, so all clients can subscribe to the stream and get live-updating text
via normal Convex queries.

```ts
agent.streamText(ctx, { threadId }, { prompt }, { saveStreamDeltas: true });
```

This can be done in an async function, where http streaming to a client is not
possible. Under the hood it will chunk up the response and debounce saving the
deltas to prevent excessive bandwidth usage. You can pass more options to
`saveStreamDeltas` to configure the chunking and debouncing.

```ts
  { saveStreamDeltas: { chunking: "line", throttleMs: 1000 } },
```

- `chunking` can be "word", "line", a regex, or a custom function.
- `throttleMs` is how frequently the deltas are saved. This will send multiple
  chunks per delta, writes sequentially, and will not write faster than the
  throttleMs
  ([single-flighted](https://stack.convex.dev/throttling-requests-by-single-flighting)
  ).

## Retrieving streamed deltas

For clients to stream messages, you need to expose a query that returns the
stream deltas. This is very similar to
[retrieving messages](./messages.mdx#retrieving-messages), with a few changes:

```ts
import { paginationOptsValidator } from "convex/server";
// highlight-next-line
import { vStreamArgs, listUIMessages, syncStreams } from "@convex-dev/agent";
import { components } from "./_generated/api";

export const listThreadMessages = query({
  args: {
    threadId: v.string(),
    // Pagination options for the non-streaming messages.
    paginationOpts: paginationOptsValidator,
    // highlight-next-line
    streamArgs: vStreamArgs,
  },
  handler: async (ctx, args) => {
    await authorizeThreadAccess(ctx, threadId);

    // Fetches the regular non-streaming messages.
    const paginated = await listUIMessages(ctx, components.agent, args);

    // highlight-next-line
    const streams = await syncStreams(ctx, components.agent, args);

    // highlight-next-line
    return { ...paginated, streams };
  },
});
```

Similar to with [non-streaming messages](./messages.mdx#useuimessages-hook), you
can use the `useUIMessages` hook to fetch the messages, passing in
`stream: true` to enable streaming.

```ts
const { results, status, loadMore } = useUIMessages(
  api.chat.streaming.listMessages,
  { threadId },
  // highlight-next-line
  { initialNumItems: 10, stream: true },
);
```

### Text smoothing with `SmoothText` and `useSmoothText`

The `useSmoothText` hook is a simple hook that smooths the text as it changes.
It can work with any text, but is especially handy for streaming text.

```ts
import { useSmoothText } from "@convex-dev/agent/react";

// in the component
const [visibleText] = useSmoothText(message.text);
```

You can configure the initial characters per second. It will adapt over time to
match the average speed of the text coming in.

By default it won't stream the first text it receives unless you pass in
`startStreaming: true`. To start streaming immediately when you have a mix of
streaming and non-streaming messages, do:

```ts
import { useSmoothText, type UIMessage } from "@convex-dev/agent/react";

function Message({ message }: { message: UIMessage }) {
  const [visibleText] = useSmoothText(message.text, {
    startStreaming: message.status === "streaming",
  });
  return <div>{visibleText}</div>;
}
```

If you don't want to use the hook, you can use the `SmoothText` component.

```tsx
import { SmoothText } from "@convex-dev/agent/react";

//...
<SmoothText text={message.text} />;
```

## Consuming the stream yourself with the Agent

You can consume the stream in all the ways you can with the underlying AI SDK -
for instance iterating over the content, or using
[`result.toDataStreamResponse()`](https://ai-sdk.dev/docs/reference/ai-sdk-core/stream-text#to-data-stream-response).

If you are not also saving the deltas, it might look like this:

```ts
const result = await agent.streamText(ctx, { threadId }, { prompt });

for await (const textPart of result.textStream) {
  console.log(textPart);
}
```

If you want to both iterate as the stream is happening, as well as save the
deltas, you can pass `{ saveStreamDeltas: { returnImmediately: true } }` to
`streamText`. This will return immediately, and you can then iterate over the
stream live, or return the stream in an HTTP Response.

```ts
const result = await agent.streamText(
  ctx,
  { threadId },
  { prompt },
  { saveStreamDeltas: { returnImmediately: true } },
);

return result.toUIMessageStreamResponse();
```

If you don't want to have the Agent involved at all, the next section will show
you how to save the deltas yourself.

## Advanced: Streaming deltas asynchronously without using an Agent

To stream messages without using the Agent's wrapper of `streamText`, you can
use the `streamText` function from the AI SDK directly.

It consists of using the `DeltaStreamer` class to save the deltas to the
database, and then using the above approach to retrieve the messages, though you
can use a more direct `useStreamingUIMessages` hook that doesn't involve reading
any non-streaming messages from the database.

The requirements for reading and writing the streams are just that they use a
`threadId` from the Agent component, and that each stream is saved with a
distinct `order`, for ordering on the client side.

```ts
import { components } from "./_generated/api";
import { type ActionCtx } from "./_generated/server";
import { DeltaStreamer, compressUIMessageChunks } from "@convex-dev/agent";
import { streamText } from "ai";
import { openai } from "@ai-sdk/openai";

async function stream(ctx: ActionCtx, threadId: string, order: number) {
  const streamer = new DeltaStreamer(
    components.agent,
    ctx,
    {
      throttleMs: 100,
      onAsyncAbort: async () => console.error("Aborted asynchronously"),
      // This will collapse multiple tiny deltas into one if they're being sent
      // in quick succession.
      compress: compressUIMessageChunks,
      abortSignal: undefined,
    },
    {
      threadId,
      format: "UIMessageChunk",
      order,
      stepOrder: 0,
      userId: undefined,
    },
  );
  // Do the normal streaming with the AI SDK
  const response = streamText({
    model: openai.chat("gpt-4o-mini"),
    prompt: "Tell me a joke",
    abortSignal: streamer.abortController.signal,
    onError: (error) => {
      console.error(error);
      streamer.fail(errorToString(error.error));
    },
  });

  // We could await here if we wanted to wait for the stream to finish,
  // but instead we have it process asynchronously so we can return a streaming
  // http Response.
  void streamer.consumeStream(response.toUIMessageStream());

  return {
    // e.g. to do `response.toTextStreamResponse()` for HTTP streaming.
    response,
    // We don't need this on the client, but with it we can have some clients
    // selectively not stream down deltas when they're using HTTP streaming
    // already.
    streamId: await streamer.getStreamId(),
  };
}
```

To fetch the deltas for the client, you can use the `syncStreams` function, as
you would with normal Agent streaming. If you don't want to fetch the
non-streaming messages, it can be simplified to:

```ts
import { v } from "convex/values";
import { vStreamArgs, syncStreams } from "@convex-dev/agent";
import { query } from "./_generated/server";
import { components } from "./_generated/api";

export const listStreams = query({
  args: {
    threadId: v.string(),
    streamArgs: vStreamArgs,
  },
  handler: async (ctx, args) => {
    // await authorizeThreadAccess(ctx, args.threadId);
    const streams = await syncStreams(ctx, components.agent, {
      ...args,
      // By default syncStreams only returns streaming messages. However, if
      // your messages aren't saved in the same transaction as the streaming
      // ends, you might want to include them here to avoid UI flashes.
      includeStatuses: ["streaming", "aborted", "finished"],
    });
    return { streams };
  },
});
```

On the client side, you can use the `useStreamingUIMessages` hook to fetch the
messages. If you defined more arguments than just `threadId`, they'll get passed
along with `threadId` here.

```ts
const messages = useStreamingUIMessages(api.example.listStreams, { threadId });
```

You can pass in another parameter to either skip certain `streamId`s or to start
at some `order` to ignore previous streams.



================================================
FILE: npm-packages/docs/docs/agents/threads.mdx
================================================
---
title: Threads
sidebar_label: "Threads"
sidebar_position: 200
description: "Group messages together in a conversation history"
---

Threads are a way to group messages together in a linear history. All messages
saved in the Agent component are associated with a thread. When a message is
generated based on a prompt, it saves the user message and generated agent
message(s) automatically.

Threads can be associated with a user, and messages can each individually be
associated with a user. By default, messages are associated with the thread's
user.

## Creating a thread

You can create a thread in a mutation or action. If you create it in an action,
it will also return a `thread` (see below) and you can start calling LLMs and
generating messages. If you specify a userId, the thread will be associated with
that user and messages will be saved to the user's history.

```ts
import { createThread } from "@convex-dev/agent";

const threadId = await createThread(ctx, components.agent);
```

You may also pass in metadata to set on the thread:

```ts
const userId = await getAuthUserId(ctx);
const threadId = await createThread(ctx, components.agent, {
  userId,
  title: "My thread",
  summary: "This is a summary of the thread",
});
```

Metadata may be provided as context to the agent automatically in the future,
but for now it's a convenience that helps organize threads in the
[Playground](./playground.mdx).

## Generating a message in a thread

You can generate a message in a thread via the agent functions:
`agent.generateText`, `agent.generateObject`, `agent.streamText`, and
`agent.streamObject`. Any agent can generate a message in a thread created by
any other agent.

```ts
const agent = new Agent(components.agent, { languageModel, instructions });

export const generateReplyToPrompt = action({
  args: { prompt: v.string(), threadId: v.string() },
  handler: async (ctx, { prompt, threadId }) => {
    // await authorizeThreadAccess(ctx, threadId);
    const result = await agent.generateText(ctx, { threadId }, { prompt });
    return result.text;
  },
});
```

See [Messages](./messages.mdx) for more details on creating and saving messages.

## Continuing a thread using the `thread` object from `agent.continueThread`

You can also continue a thread by creating an agent-specific `thread` object,
either when calling `agent.createThread` or `agent.continueThread` from within
an action. This allows calling methods without specifying those parameters each
time.

```ts
const { thread } = await agent.continueThread(ctx, { threadId });
const result = await thread.generateText({ prompt });
```

The `thread` from `continueThread` or `createThread` (available in actions only)
is a `Thread` object, which has convenience methods that are thread-specific:

- `thread.getMetadata()` to get the `userId`, `title`, `summary` etc.
- `thread.updateMetadata({ patch: { title, summary, userId} })` to update the
  metadata
- `thread.generateText({ prompt, ... })` - equivalent to
  `agent.generateText(ctx, { threadId }, { prompt, ... })`
- `thread.streamText({ prompt, ... })` - equivalent to
  `agent.streamText(ctx, { threadId }, { prompt, ... })`
- `thread.generateObject({ prompt, ... })` - equivalent to
  `agent.generateObject(ctx, { threadId }, { prompt, ... })`
- `thread.streamObject({ prompt, ... })` - equivalent to
  `agent.streamObject(ctx, { threadId }, { prompt, ... })`

See [Messages docs](./messages.mdx) for more details on generating messages.

## Deleting threads

You can delete threads by their `threadId`.

Asynchronously (from a mutation or action):

```ts
await agent.deleteThreadAsync(ctx, { threadId });
```

Synchronously in batches (from an action):

```ts
await agent.deleteThreadSync(ctx, { threadId });
```

You can also delete all threads by a user by their `userId`.

```ts
await agent.deleteThreadsByUserId(ctx, { userId });
```

## Getting all threads owned by a user

```ts
const threads = await ctx.runQuery(
  components.agent.threads.listThreadsByUserId,
  { userId, paginationOpts: args.paginationOpts },
);
```

## Deleting all threads and messages associated with a user

Asynchronously (from a mutation or action):

```ts
await ctx.runMutation(components.agent.users.deleteAllForUserIdAsync, {
  userId,
});
```

Synchronously (from an action):

```ts
await ctx.runMutation(components.agent.users.deleteAllForUserId, { userId });
```

## Getting messages in a thread

See [messages.mdx](./messages.mdx) for more details.

```ts
import { listMessages } from "@convex-dev/agent";

const messages = await listMessages(ctx, components.agent, {
  threadId,
  excludeToolMessages: true,
  paginationOpts: { cursor: null, numItems: 10 }, // null means start from the beginning
});
```

Or for the UIMessage type (easier for rendering UIs):

```ts
import { listUIMessages } from "@convex-dev/agent";

const messages = await listUIMessages(ctx, components.agent, {
  threadId,
  paginationOpts: { cursor: null, numItems: 10 },
});
```



================================================
FILE: npm-packages/docs/docs/agents/tools.mdx
================================================
---
title: Tools
sidebar_label: "Tools"
sidebar_position: 500
description: "Using tool calls with the Agent component"
---

The Agent component supports tool calls, which are a way to allow an LLM to call
out to external services or functions. This can be useful for:

- Retrieving data from the database
- Writing or updating data in the database
- Searching the web for more context
- Calling an external API
- Requesting that a user takes an action before proceeding (human-in-the-loop)

## Defining tools

You can provide tools at different times:

- Agent constructor: (`new Agent(components.agent, { tools: {...} })`)
- Creating a thread: `createThread(ctx, { tools: {...} })`
- Continuing a thread: `continueThread(ctx, { tools: {...} })`
- On thread functions: `thread.generateText({ tools: {...} })`
- Outside of a thread: `supportAgent.generateText(ctx, {}, { tools: {...} })`

Specifying tools at each layer will overwrite the defaults. The tools will be
`args.tools ?? thread.tools ?? agent.options.tools`. This allows you to create
tools in a context that is convenient.

## Using tools

The Agent component will automatically handle passing tool call results back in
and re-generating if you pass `stopWhen: stepCountIs(num)` where `num > 1` to
`generateText` or `streamText`.

The tool call and result will be stored as messages in the thread associated
with the source message. See [Messages](./messages.mdx) for more details.

## Creating a tool with a Convex context

There are two ways to create a tool that has access to the Convex context.

1. Use the `createTool` function, which is a wrapper around the AI SDK's `tool`
   function.

```ts
export const ideaSearch = createTool({
  description: "Search for ideas in the database",
  args: z.object({ query: z.string().describe("The query to search for") }),
  handler: async (ctx, args, options): Promise<Array<Idea>> => {
    // ctx has agent, userId, threadId, messageId
    // as well as ActionCtx properties like auth, storage, runMutation, and runAction
    const ideas = await ctx.runQuery(api.ideas.searchIdeas, {
      query: args.query,
    });
    console.log("found ideas", ideas);
    return ideas;
  },
});
```

2. Define tools at runtime in a context with the variables you want to use.

```ts
async function createTool(ctx: ActionCtx, teamId: Id<"teams">) {
  const myTool = tool({
    description: "My tool",
    parameters: z.object({...}).describe("The arguments for the tool"),
    execute: async (args, options): Promise<BarReturnType> => {
      return await ctx.runQuery(internal.foo.bar, args);
    },
  });
}
```

In both cases, the args and options match the underlying AI SDK's `tool`
function.

If you run into type errors, ensure you're annotating the return type of the
execute function, and if necessary, the return type of the `handler`s of any
functions you call with `ctx.run*`.

Note: it's highly recommended to use zod with `.describe` to provide details
about each parameter. This will be used to provide a description of the tool to
the LLM.

### Adding custom context to tools

It's often useful to have extra metadata in the context of a tool.

By default, the context passed to a tool is a `ToolCtx` with:

- `agent` - the Agent instance calling it
- `userId` - the user ID associated with the call, if any
- `threadId` - the thread ID, if any
- `messageId` - the message ID of the prompt message passed to generate/stream.
- Everything in `ActionCtx`, such as `auth`, `storage`, `runQuery`, etc. Note:
  in scheduled functions, workflows, etc, the auth user will be `null`.

To add more fields to the context, you can pass a custom context to the call,
such as `agent.generateText({ ...ctx, orgId: "123" })`.

You can enforce the type of the context by passing a type when constructing the
Agent.

```ts
const myAgent = new Agent<{ orgId: string }>(...);
```

Then, in your tools, you can use the `orgId` field.

```ts
type MyCtx = ToolCtx & { orgId: string };

const myTool = createTool({
  args: z.object({ ... }),
  description: "...",
  handler: async (ctx: MyCtx, args) => {
    // use ctx.orgId
  },
});
```

## Using an LLM or Agent as a tool

You can do generation within a tool call, for instance if you wanted one Agent
to ask another Agent a question.

Note: you don't have to structure agents calling each other as tool calls. You
could instead decide which Agent should respond next based on other context and
have many Agents contributing in the same thread.

The simplest way to model Agents as tool calls is to have each tool call work in
an independent thread, or do generation without a thread at all. Then, the
output is returned as the tool call result for the next LLM step to use. When
you do it this way, you **don't** need to explicitly save the tool call result
to the parent thread.

### Direct LLM generation without a thread:

```ts
const llmTool = createTool({
  description: "Ask a question to some LLM",
  args: z.object({
    message: z.string().describe("The message to ask the LLM"),
  }),
  handler: async (ctx, args): Promise<string> => {
    const result = await generateText({
      system: "You are a helpful assistant.",
      // Pass through all messages from the current generation
      prompt: [...options.messages, { role: "user", content: args.message }],
      model: myLanguageModel,
    });
    return result.text;
  },
});
```

### Using an Agent as a tool

```ts
const agentTool = createTool({
  description: `Ask a question to agent ${agent.name}`,
  args: z.object({
    message: z.string().describe("The message to ask the agent"),
  }),
  handler: async (ctx, args, options): Promise<string> => {
    const { userId } = ctx;
    const { thread } = await agent.createThread(ctx, { userId });
    const result = await thread.generateText(
      {
        // Pass through all messages from the current generation
        prompt: [...options.messages, { role: "user", content: args.message }],
      },
      // Save all the messages from the current generation to this thread.
      { storageOptions: { saveMessages: "all" } },
    );
    // Optionally associate the child thread with the parent thread in your own
    // tables.
    await saveThreadAsChild(ctx, ctx.threadId, thread.threadId);
    return result.text;
  },
});
```



================================================
FILE: npm-packages/docs/docs/agents/usage-tracking.mdx
================================================
---
title: Usage Tracking
sidebar_label: "Usage Tracking"
sidebar_position: 1300
description: "Tracking token usage of the Agent component"
---

You can provide a `usageHandler` to the agent to track token usage. See an
example in
[this demo](https://github.com/get-convex/agent/blob/main/example/convex/usage_tracking/usageHandler.ts)
that captures usage to a table, then scans it to generate per-user invoices.

You can provide a `usageHandler` to the agent, per-thread, or per-message.

```ts
const supportAgent = new Agent(components.agent, {
  ...
  usageHandler: async (ctx, args) => {
    const {
      // Who used the tokens
      userId, threadId, agentName,
      // What LLM was used
      model, provider,
      // How many tokens were used (extra info is available in providerMetadata)
      usage, providerMetadata
    } = args;
    // ... log, save usage to your database, etc.
  },
});
```

Tip: Define the `usageHandler` within a function where you have more variables
available to attribute the usage to a different user, team, project, etc.

## Storing usage in a table

To track usage for e.g. billing, you can define a table in your schema and
insert usage into it for later processing.

```ts
export const usageHandler: UsageHandler = async (ctx, args) => {
  if (!args.userId) {
    console.debug("Not tracking usage for anonymous user");
    return;
  }
  await ctx.runMutation(internal.example.insertRawUsage, {
    userId: args.userId,
    agentName: args.agentName,
    model: args.model,
    provider: args.provider,
    usage: args.usage,
    providerMetadata: args.providerMetadata,
  });
};

export const insertRawUsage = internalMutation({
  args: {
    userId: v.string(),
    agentName: v.optional(v.string()),
    model: v.string(),
    provider: v.string(),
    usage: vUsage,
    providerMetadata: v.optional(vProviderMetadata),
  },
  handler: async (ctx, args) => {
    const billingPeriod = getBillingPeriod(Date.now());
    return await ctx.db.insert("rawUsage", {
      ...args,
      billingPeriod,
    });
  },
});

function getBillingPeriod(at: number) {
  const now = new Date(at);
  const startOfMonth = new Date(now.getFullYear(), now.getMonth());
  return startOfMonth.toISOString().split("T")[0];
}
```

With an associated schema in `convex/schema.ts`:

```ts
export const schema = defineSchema({
  rawUsage: defineTable({
    userId: v.string(),
    agentName: v.optional(v.string()),
    model: v.string(),
    provider: v.string(),

    // stats
    usage: vUsage,
    providerMetadata: v.optional(vProviderMetadata),

    // In this case, we're setting it to the first day of the current month,
    // using UTC time for the month boundaries.
    // You could alternatively store it as a timestamp number.
    // You can then fetch all the usage at the end of the billing period
    // and calculate the total cost.
    billingPeriod: v.string(), // When the usage period ended
  }).index("billingPeriod_userId", ["billingPeriod", "userId"]),

  invoices: defineTable({
    userId: v.string(),
    billingPeriod: v.string(),
    amount: v.number(),
    status: v.union(
      v.literal("pending"),
      v.literal("paid"),
      v.literal("failed"),
    ),
  }).index("billingPeriod_userId", ["billingPeriod", "userId"]),
  // ... other tables
});
```

## Generating invoices via a cron job

You can use a cron job to generate invoices at the end of the billing period.

See
[usage_tracking/invoicing.ts](https://github.com/get-convex/agent/blob/main/example/convex/usage_tracking/invoicing.ts)
for an example of how to generate invoices.

You can then add it to `convex/crons.ts`:

```ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Generate invoices for the previous month
crons.monthly(
  "generateInvoices",
  // Wait a day after the new month starts to generate invoices
  { day: 2, hourUTC: 0, minuteUTC: 0 },
  internal.usage.generateInvoices,
  {},
);

export default crons;
```



================================================
FILE: npm-packages/docs/docs/agents/workflows.mdx
================================================
---
title: Workflows
sidebar_label: "Workflows"
sidebar_position: 800
description: "Defining long-lived workflows for the Agent component"
---

Agentic Workflows can be decomposed into two elements:

1. Prompting an LLM (including message history, context, etc.).
2. Deciding what to do with the LLM's response.

We generally call them workflows when there are multiple steps involved, they
involve dynamically deciding what to do next, are long-lived, or have a mix of
business logic and LLM calls.

Tool calls and MCP come into play when the LLM's response is a specific request
for an action to take. The list of available tools and result of the calls are
used in the prompt to the LLM.

One especially powerful form of Workflows are those that can be modeled as
[durable functions](https://stack.convex.dev/durable-workflows-and-strong-guarantees)
that can be long-lived, survive server restarts, and have strong guarantees
around retrying, idempotency, and completing.

The simplest version of this could be doing a couple pre-defined steps, such as
first getting the weather forecast, then getting fashion advice based on the
weather. For a code example, see
[workflows/chaining.ts](https://github.com/get-convex/agent/blob/main/example/convex/workflows/chaining.ts).

```ts
export const getAdvice = action({
  args: { location: v.string(), threadId: v.string() },
  handler: async (ctx, { location, threadId }) => {
    // This uses tool calls to get the weather forecast.
    await weatherAgent.generateText(
      ctx,
      { threadId },
      { prompt: `What is the weather in ${location}?` },
    );
    // This includes previous message history from the thread automatically and
    // uses tool calls to get user-specific fashion advice.
    await fashionAgent.generateText(
      ctx,
      { threadId },
      { prompt: `What should I wear based on the weather?` },
    );
    // We don't need to return anything, since the messages are saved
    // automatically and clients will get the response via subscriptions.
  },
});
```

## Building reliable workflows

One common pitfall when working with LLMs is their unreliability. API providers
have outages, and LLMs can be flaky. To build reliable workflows, you often need
three properties:

1. Reliable retries
2. Load balancing
3. Durability and idempotency for multi-step workflows

Thankfully there are Convex components to leverage for these properties.

### Retries

By default, Convex mutations have these properties by default. However, calling
LLMs require side-effects and using the network calls, which necessitates using
actions. If you are only worried about retries, you can use the
[Action Retrier](https://convex.dev/components/retrier) component.

However, keep reading, as the [Workpool](https://convex.dev/components/workpool)
and [Workflow](https://convex.dev/components/workflow) components provide more
robust solutions, including retries.

### Load balancing

With long-running actions in a serverless environment, you may consume a lot of
resources. And with tasks like ingesting data for RAG or other spiky workloads,
there's a risk of running out of resources. To mitigate this, you can use the
[Workpool](https://convex.dev/components/workpool) component. You can set a
limit on the number of concurrent workers and add work asynchronously, with
configurable retries and a callback to handle eventual success / failure.

However, if you also want to manage multi-step workflows, you should use the
[Workflow](https://convex.dev/components/workflow) component, which also
provides retries and load balancing out of the box.

### Durability and idempotency for multi-step workflows

When doing multi-step workflows that can fail mid-way, you need to ensure that
the workflow can be resumed from where it left off, without duplicating work.
The [Workflow](https://convex.dev/components/workflow) builds on the
[Workpool](https://convex.dev/components/workpool) to provide durable execution
of long running functions with retries and delays.

Each step in the workflow is run, with the result recorded. Even if the server
fails mid-way, it will resume with the latest incomplete step, with configurable
retry settings.

## Using the Workflow component for long-lived durable workflows

The [Workflow component](https://convex.dev/components/workflow) is a great way
to build long-lived, durable workflows. It handles retries and guarantees of
eventually completing, surviving server restarts, and more. Read more about
durable workflows in
[this Stack post](https://stack.convex.dev/durable-workflows-and-strong-guarantees).

To use the agent alongside workflows, you can run individual idempotent steps
that the workflow can run, each with configurable retries, with guarantees that
the workflow will eventually complete. Even if the server crashes mid-workflow,
the workflow will pick up from where it left off and run the next step. If a
step fails and isn't caught by the workflow, the workflow's onComplete handler
will get the error result.

### Using the Agent within a workflow

You can use the [Workflow component](https://convex.dev/components/workflow) to
run agent flows. It handles retries and guarantees of eventually completing,
surviving server restarts, and more. Read more about durable workflows
[in this Stack post](https://stack.convex.dev/durable-workflows-and-strong-guarantees).

Within a workflow, each "step" is a single idempotent operation. The arguments
and return values are stored as part of the workflow's state, so it can resume
wherever it left off by replaying the history. This allows workflows to run for
a long time, survive server restarts, retry individual steps, pause, and more.

Some Agent functions can be called directly from a workflow, passing `step`
instead of `ctx`. Under the hood, these functions are calling `step.runMutation`
instead of the `ctx.runMutation` that is otherwise done. The two calls are
roughly the same, though there is more overhead associated with calling steps
since the arguments and return values count towards the workflow's overall
database bandwidth limit. As such, try to avoid passing large amounts of data in
as arguments or returned from steps, and prefer to save that data and pass
around IDs instead.

```ts
const workflow = new WorkflowManager(components.workflow);

export const supportAgentWorkflow = workflow.define({
  args: { prompt: v.string(), userId: v.string() },
  handler: async (step, { prompt, userId }) => {
    // Some functions can be called directly from a workflow, passing `step`
    // instead of `ctx`. This doesn't work for anything action-related.
    const { threadId } = await createThread(step, components.agent, {
      userId,
      title: prompt,
    });
    // Under the hood, these functions are calling step.runMutation,
    // so saving the message is a workflow step. The equivalent would be to call
    // step.runMutation with your own mutation that called saveMessage with ctx.
    const { messageId } = await saveMessage(step, components.agent, {
      threadId,
      prompt,
    });
    // For functions that require `fetch` or otherwise need an action, run them
    // as steps explicitly.
    const { text } = await step.runAction(
      internal.example.getSupport,
      { threadId, userId, promptMessageId: messageId },
      // Passing in a promptMessageId allows us to safely retry the step.
      // If it fails partway, the retry will re-use the same prompt message and
      // any existing responses.
      { retry: true },
    );
    const { object } = await step.runAction(
      internal.example.getStructuredSupport,
      {
        userId,
        prompt: text,
      },
    );
    // You can also run mutations as steps explicitly.
    await step.runMutation(internal.example.sendUserMessage, {
      userId,
      message: object.instruction,
    });
  },
});
```

### Exposing Agent functions as Convex Actions

You can expose the agent's capabilities as Convex functions to be used as steps
in a workflow, as an alternative to writing an action for each step.

For an action that generates or streams text in a thread:

```ts
// Similar to thread.generateText / thread.streamText
export const getSupport = supportAgent.asTextAction({
  stopWhen: stepCountIs(10),
});
```

You can also expose a standalone action that generates an object.

```ts
// Similar to thread.generateObject / thread.streamObject
export const getStructuredSupport = supportAgent.asObjectAction({
  schema: z.object({
    analysis: z.string().describe("A detailed analysis of the user's request."),
    instruction: z.string().describe("A suggested action to take."),
  }),
});
```

See example code in
[workflows/chaining.ts](https://github.com/get-convex/agent/blob/main/example/convex/workflows/chaining.ts).

## Complex workflow patterns

While there is only an example of a simple workflow here, there are many complex
patterns that can be built with the Agent component:

- Dynamic routing to agents based on an LLM call or vector search
- Fanning out to LLM calls, then combining the results
- Orchestrating multiple agents
- Cycles of Reasoning and Acting (ReAct)
- Modeling a network of agents messaging each other
- Workflows that can be paused and resumed

import { ComponentCardList } from "@site/src/components/ComponentCard";

<ComponentCardList
  items={[
    {
      title: "Workpool",
      description:
        "Builds on the Action Retrier to provide parallelism limits and retries to manage large numbers of external requests efficiently.",
      href: "https://www.convex.dev/components/workpool",
    },
    {
      title: "Workflow",
      description:
        "Builds on the Workpool to provide durable execution of long running functions with retries and delays.",
      href: "https://www.convex.dev/components/workflow",
    },
  ]}
/>



================================================
FILE: npm-packages/docs/docs/ai/convex-mcp-server.mdx
================================================
---
title: "Convex MCP Server"
sidebar_position: 300
description: "Convex MCP server"
---

The Convex
[Model Context Protocol](https://docs.cursor.com/context/model-context-protocol)
(MCP) server provides several tools that allow AI agents to interact with your
Convex deployment.

## Setup

Add the following command to your MCP servers configuration:

`npx -y convex@latest mcp start`

For Cursor you can use this quick link to install:

[![Install MCP Server](https://cursor.com/deeplink/mcp-install-dark.svg)](https://cursor.com/en/install-mcp?name=convex&config=eyJjb21tYW5kIjoibnB4IC15IGNvbnZleEBsYXRlc3QgbWNwIHN0YXJ0In0%3D)

or see editor specific instructions:

- [Cursor](/ai/using-cursor.mdx#setup-the-convex-mcp-server)
- [Windsurf](/ai/using-windsurf.mdx#setup-the-convex-mcp-server)
- [VS Code](/ai/using-github-copilot.mdx#setup-the-convex-mcp-server)
- Claude Code: add the MCP server and test with
  ```bash
  claude mcp add-json convex '{"type":"stdio","command":"npx","args":["convex","mcp","start"]}'
  claude mcp get convex
  ```

## Configuration Options

The MCP server supports several command-line options to customize its behavior:

### Project Directory

By default, the MCP server can run for multiple projects, and each tool call
specifies its project directory. To run the server for a single project instead,
use:

```bash
npx -y convex@latest mcp start --project-dir /path/to/project
```

### Deployment Selection

By default, the MCP server connects to your development deployment. You can
specify a different deployment using these options:

- `--prod`: Run the MCP server on your project's production deployment (requires
  `--dangerously-enable-production-deployments`)
- `--preview-name <name>`: Run on a preview deployment with the given name
- `--deployment-name <name>`: Run on a specific deployment by name
- `--env-file <path>`: Path to a custom environment file for choosing the
  deployment (e.g., containing `CONVEX_DEPLOYMENT` or `CONVEX_SELF_HOSTED_URL`).
  Uses the same format as `.env.local` or `.env` files.

### Production Deployments

By default, the MCP server cannot access production deployments. This is a
safety measure to prevent accidental modifications to production data. If you
need to access production deployments, you must explicitly enable this:

```bash
npx -y convex@latest mcp start --dangerously-enable-production-deployments
```

<Admonition type="caution" title="Use with care">

Enabling production access allows the MCP server to read and modify data in your
production deployment. Only enable this when you specifically need to interact
with production, and be careful with any operations that modify data.

</Admonition>

### Disabling Tools

You can disable specific tools if you want to restrict what the MCP server can
do:

```bash
npx -y convex@latest mcp start --disable-tools data,run,envSet
```

Available tools that can be disabled: `data`, `envGet`, `envList`, `envRemove`,
`envSet`, `functionSpec`, `logs`, `run`, `runOneoffQuery`, `status`, `tables`

## Available Tools

### Deployment Tools

- **`status`**: Queries available deployments and returns a deployment selector
  that can be used with other tools. This is typically the first tool you'll use
  to find your Convex deployment.

### Table Tools

- **`tables`**: Lists all tables in a deployment along with their:

  - Declared schemas (if present)
  - Inferred schemas (automatically tracked by Convex)
  - Table names and metadata

- **`data`**: Allows pagination through documents in a specified table.

- **`runOneoffQuery`**: Enables writing and executing sandboxed JavaScript
  queries against your deployment's data. These queries are read-only and cannot
  modify the database.

### Function Tools

- **`functionSpec`**: Provides metadata about all deployed functions, including:

  - Function types
  - Visibility settings
  - Interface specifications

- **`run`**: Executes deployed Convex functions with provided arguments.

- **`logs`**: Fetches a chunk of recent function execution log entries, similar
  to `npx convex logs` but as structured objects.

### Environment Variable Tools

- **`envList`**: Lists all environment variables for a deployment
- **`envGet`**: Retrieves the value of a specific environment variable
- **`envSet`**: Sets a new environment variable or updates an existing one
- **`envRemove`**: Removes an environment variable from the deployment

[Read more about how to use the Convex MCP Server](https://stack.convex.dev/convex-mcp-server)



================================================
FILE: npm-packages/docs/docs/ai/using-cursor.mdx
================================================
---
title: "Using Cursor with Convex"
sidebar_position: 100
sidebar_label: Using Cursor
description: "Tips and best practices for using Cursor with Convex"
slug: "using-cursor"
---

[Cursor](https://cursor.com), the AI code editor, makes it easy to write and
maintain apps built with Convex. Let's walk through how to setup Cursor for the
best possible results with Convex.

## Add Convex `.cursor/rules`

To get the best results from Cursor put the model specific `.mdc` files in your
project's `.cursor/rules` directory.

- [Convex Cursor Rules](https://convex.link/convex_rules.mdc)

<video
  src="/video/showing_where_to_put_convex_rules.mp4"
  autoPlay
  loop
  controls
></video>

We're constantly working on improving the quality of these rules for Convex by
using rigorous evals. You can help by
[contributing to our evals repo](https://github.com/get-convex/convex-evals).

## Setup the Convex MCP Server

The Convex CLI comes with a
[Convex Model Context Protocol](/ai/convex-mcp-server.mdx) (MCP) server built
in. The Convex MCP server gives your AI coding agent access to the your Convex
deployment to query and optimize your project.

### Quick Install

You can click this handy deep-link below:

[![Install MCP Server](https://cursor.com/deeplink/mcp-install-dark.svg)](https://cursor.com/en/install-mcp?name=convex&config=eyJjb21tYW5kIjoibnB4IC15IGNvbnZleEBsYXRlc3QgbWNwIHN0YXJ0In0%3D)

### Manual Install

To get started with Cursor, open "Cursor Settings > Tools & Integrations", click
on "New MCP Server", and add a "convex" section to "mcpServers" in the
`mcp.json` file that's opened.

```json
{
  "mcpServers": {
    "convex": {
      "command": "npx",
      "args": ["-y", "convex@latest", "mcp", "start"]
    }
  }
}
```

You can also install the Convex MCP
[for just one project](https://docs.cursor.com/en/context/mcp#configuration-locations).

After adding the server, ensure the "convex" server is enabled and lit up green
(it make take a minute the first time while the NPM package downloads).

Now start asking it questions like:

- Evaluate my convex schema and suggest improvements
- What are this app's public endpoints?
- Run the `my_convex_function` query

## Tips and tricks

### Install and run Convex yourself

Keeping Convex running is crucial because
[it automatically generates](https://docs.convex.dev/cli#run-the-convex-dev-server)
the client-side types. Without this, the agent can get stuck in a linting loop
since it can't access the types for the queries and mutations it created.

We recommended that you install (`npm install convex`) and run convex
(`npx convex dev`) yourself in a terminal window.

### Keep your requests small

The best results when using agentic LLMs can be found when keeping the amount of
changes you want to make small and git commit frequently. This lets you be more
specific around the context you provide the agent and it means the agent doesn't
need to do a lot of searching for context.

After each successful prompt or series of prompts it is a good idea to commit
your changes so that its simple to rollback to that point should the next prompt
cause issues.

### Update and reference your `README.md`

The agent needs context about the specific business goals for your project.
While it can infer some details from the files it reads, this becomes more
challenging as your project grows. Providing general information about your
project gives the agent a helpful head start.

Rather than including this information in each prompt, it's better to write a
comprehensive README.md file in your project root and reference it.

[Some people](https://youtu.be/2PjmPU07KNs?t=145) advocate for crafting a
Product Requirements Document (PRD), this may be a good idea for more complex
projects.

### Add Convex docs

Adding Convex docs can let you specifically refer to Convex features when
building your app.

From **`Cursor Settings`** > **`Indexing & Docs`** > **`Docs`** add new doc, use
the URL "https://docs.convex.dev/home"

![Chat UI](/img/cursor-with-convex/adding_convex_docs.webp)

Cursor will then index all of the Convex docs for the LLM to use.

![Chat UI](/img/cursor-with-convex/indexed_docs.webp)

You can then reference those docs in your prompt with the `@Convex` symbol.

![Chat UI](/img/cursor-with-convex/reference_convex_docs.webp)

<Admonition type="tip" title="Add more Convex knowledge">

You can perform the above steps for https://stack.convex.dev/ too if you would
like to provide even more context to the agent.

</Admonition>



================================================
FILE: npm-packages/docs/docs/ai/using-github-copilot.mdx
================================================
---
title: "Using GitHub Copilot with Convex"
sidebar_position: 200
sidebar_label: Using GitHub Copilot
description: "Tips and best practices for using GitHub Copilot with Convex"
slug: "using-github-copilot"
---

[GitHub Copilot](https://github.com/features/copilot), the AI built into VS
Code, makes it easy to write and maintain apps built with Convex. Let's walk
through how to setup GitHub Copilot for the best possible results with Convex.

## Add Convex Instructions

Add the following
[instructions](https://code.visualstudio.com/docs/copilot/copilot-customization#_instruction-files)
file to your `.github/instructions` directory in your project and it will
automatically be included when working with TypeScript or JavaScript files:

- [convex.instructions.md](https://convex.link/convex_github_copilot_instructions)

![Showing Where to Put GitHub Copilot Instructions](/img/showing-where-to-put-convex-instructions.png)

If you would rather that the instructions file is NOT automatically pulled into
context then open the file in your editor and alter the `applyTo` field at the
top. Read more about instructions files here:
https://code.visualstudio.com/docs/copilot/copilot-customization#_use-instructionsmd-files

We're constantly working on improving the quality of these rules for Convex by
using rigorous evals. You can help by
[contributing to our evals repo](https://github.com/get-convex/convex-evals).

## Setup the Convex MCP Server

The Convex CLI comes with a
[Convex Model Context Protocol](/ai/convex-mcp-server.mdx) (MCP) server built
in. The Convex MCP server gives your AI coding agent access to the your Convex
deployment to query and optimize your project.

To get started with
[MCP in VS Code](https://code.visualstudio.com/docs/copilot/chat/mcp-servers)
then create a file in `.vscode/mcp.json` and add the following:

```json
{
  "servers": {
    "convex-mcp": {
      "type": "stdio",
      "command": "npx",
      "args": ["-y", "convex@latest", "mcp", "start"]
    }
  }
}
```

Once this is done it will take a few seconds to start up the MCP server and then
you should see the Convex tool listed in the codelens:

![Convex Tool in Codelens](/img/convex-tool-in-codelens.png)

and in the selection of tools that the model has access to in chat:

![Convex Tool in Chat](/img/convex-tools-in-chat.png)

Now start asking it questions like:

- Evaluate and convex schema and suggest improvements
- What are this app's public endpoints?
- Run the `my_convex_function` query

If you want to use the MCP server globally for all your projects then you can
add it to your user settings, please see these docs for more information:
https://code.visualstudio.com/docs/copilot/chat/mcp-servers#_add-an-mcp-server-to-your-user-settings



================================================
FILE: npm-packages/docs/docs/ai/using-windsurf.mdx
================================================
---
title: "Using Windsurf with Convex"
sidebar_position: 200
sidebar_label: Using Windsurf
description: "Tips and best practices for using Windsurf with Convex"
slug: "using-windsurf"
---

[Windsurf](https://codeium.com/windsurf), the AI code editor, makes it easy to
write and maintain apps built with Convex. Let's walk through how to setup
Windsurf for the best possible results with Convex.

## Add Convex Rules

Add the following rules file to your project and refer to it directly when
prompting for changes:

- [Convex Rules](https://convex.link/convex_rules.txt)

We're constantly working on improving the quality of these rules for Convex by
using rigorous evals. You can help by
[contributing to our evals repo](https://github.com/get-convex/convex-evals).

## Setup the Convex MCP Server

The Convex CLI comes with a
[Convex Model Context Protocol](/ai/convex-mcp-server.mdx) (MCP) server built
in. The Convex MCP server gives your AI coding agent access to the your Convex
deployment to query and optimize your project.

To get started with Windsurf, open "Windsurf Settings > Cascade > Model Context
Protocol (MCP) Servers", click on "Add Server", click "Add custom server", and
add the following configuration for Convex.

```json
{
  "mcpServers": {
    "convex": {
      "command": "npx",
      "args": ["-y", "convex@latest", "mcp", "start"]
    }
  }
}
```

After adding the server return to the "Windsurf Settings > Cascade > Model
Context Protocol (MCP) Servers" screen an click "Refresh" button for Windsurf to
pick up the new server.

Once this is done you should see the Convex tool listed in the servers:

![Chat UI](/img/windsurf-with-convex/windsurf_convex_mcp.png)

Now start asking it questions like:

- Evaluate and convex schema and suggest improvements
- What are this app's public endpoints?
- Run the `my_convex_function` query



================================================
FILE: npm-packages/docs/docs/auth/_under_the_hood.mdx
================================================
The authentication flow looks like this under the hood:

1. The user clicks a login button
2. The user is redirected to a page where they log in via whatever method you
   configure in {props.provider}
3. After a successful login {props.provider} redirects back to your page, or a
   different page which you configure via {props.configProp}.
4. The {props.providerProvider} now knows that the user is authenticated.
5. The {props.integrationProvider} fetches an auth token from {props.provider}.
6. The `ConvexReactClient` passes this token down to your Convex backend to
   validate
7. Your Convex backend retrieves the public key from {props.provider} to check
   that the token's signature is valid.
8. The `ConvexReactClient` is notified of successful authentication, and
   {props.integrationProvider} now knows that the user is authenticated with
   Convex. `useConvexAuth` returns `isAuthenticated: true` and the
   `Authenticated` component renders its children.

{props.integrationProvider} takes care of refetching the token when needed to
make sure the user stays authenticated with your backend.



================================================
FILE: npm-packages/docs/docs/auth/auth0.mdx
================================================
---
title: "Convex & Auth0"
sidebar_label: "Auth0"
sidebar_position: 30
description: "Integrate Auth0 authentication with Convex"
---

import LogoutButtonTSX from "!!raw-loader!@site/../demos/users-and-auth/src/LogoutButton.tsx";
import UnderTheHood from "@site/docs/auth/_under_the_hood.mdx";
import ConfigTS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite-ts/src/_mainAuth0.tsx";
import ConfigJS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/src/_mainAuth0.jsx";
import ConfigEnvTS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite-ts/src/_mainAuth0Env.tsx";
import ConfigEnvJS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/src/_mainAuth0Env.jsx";

[Auth0](https://auth0.com) is an authentication platform providing login via
passwords, social identity providers, one-time email or SMS access codes,
multi-factor authentication, and single sign on and basic user management.

**Example:**
[Convex Authentication with Auth0](https://github.com/get-convex/convex-demos/tree/main/users-and-auth)

If you're using Next.js see the
[Next.js setup guide](https://docs.convex.dev/client/nextjs).

## Get started

This guide assumes you already have a working React app with Convex. If not
follow the [Convex React Quickstart](/quickstart/react.mdx) first. Then:

<StepByStep>
  <Step title="Follow the Auth0 React quickstart">
    Follow the [Auth0 React Quickstart](https://auth0.com/docs/quickstart/spa/react/interactive).

    Sign up for a free Auth0 account.

    Configure your application, using `http://localhost:3000, http://localhost:5173` for Callback
    and Logout URLs and Allowed Web Origins.

    Come back when you finish the _Install the Auth0 React SDK_ step.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/auth0-signup.png" alt="Sign up to Auth0" width={300} />
    </p>

  </Step>
  <Step title="Create the auth config">
    In the `convex` folder create a new file <JSDialectFileName name="auth.config.ts" /> with
    the server-side configuration for validating access tokens.

    Paste in the `domain` and `clientId` values shown in
    _Install the Auth0 React SDK_ step of the Auth0 quickstart or
    in your Auth0 application's Settings dashboard.

    ```ts title="convex/auth.config.ts"
    import { AuthConfig } from "convex/server";

    export default {
      providers: [
        {
          domain: "your-domain.us.auth0.com",
          applicationID: "yourclientid",
        },
      ]
    } satisfies AuthConfig;
    ```

  </Step>
  <Step title="Deploy your changes">
    Run `npx convex dev` to automatically sync your configuration to your backend.

    ```sh
    npx convex dev
    ```

  </Step>
  <Step title="Configure ConvexProviderWithAuth0">
    Now replace your `ConvexProvider` with an `Auth0Provider` wrapping `ConvexProviderWithAuth0`.
    Add the `domain` and `clientId` as props to the `Auth0Provider`.

    Paste in the `domain` and `clientId` values shown in
    _Install the Auth0 React SDK_ step of the Auth0 quickstart or
    in your Auth0 application's Settings dashboard as props to `Auth0Provider`.

    <TSAndJSSnippet
      title="src/main.tsx"
      sourceTS={ConfigTS}
      sourceJS={ConfigJS}
      highlightPatterns={[
        "Auth0Provider",
        "ConvexProviderWithAuth0",
        "domain=",
        "clientId=",
        "authorizationParams=",
          "redirect_uri: ",
        "}}",
        "useRefreshTokens=",
        "cacheLocation=",
        "  >",
      ]}
    />

  </Step>
</StepByStep>

## Login and logout flows

Now that you have everything set up, you can use the
[`useAuth0()`](https://auth0.github.io/auth0-react/functions/useAuth0.html) hook
to create login and logout buttons for your app.

The login button will redirect the user to the Auth0 universal login page. For
details see
[Add Login to Your Application](https://auth0.com/docs/quickstart/spa/react/interactive#add-login-to-your-application)
in the Auth0 React Quickstart.

```tsx title="src/login.ts"
import { useAuth0 } from "@auth0/auth0-react";

export default function LoginButton() {
  const { loginWithRedirect } = useAuth0();
  return <button onClick={loginWithRedirect}>Log in</button>;
}
```

The logout button will redirect the user to the Auth0 logout endpoint. For
details see
[Add Logout to your Application](https://auth0.com/docs/quickstart/spa/react/interactive#add-logout-to-your-application)
in the Auth0 React Quickstart.

<TSAndJSSnippet
  title="src/logout.ts"
  sourceTS={LogoutButtonTSX}
  sourceJS={LogoutButtonTSX}
/>

## Logged-in and logged-out views

Use the [`useConvexAuth()`](/api/modules/react#useconvexauth) hook instead of
the `useAuth0` hook when you need to check whether the user is logged in or not.
The `useConvex` hook makes sure that the browser has fetched the auth token
needed to make authenticated requests to your Convex backend:

```tsx title="src/App.ts"
import { useConvexAuth } from "convex/react";

function App() {
  const { isLoading, isAuthenticated } = useConvexAuth();

  return (
    <div className="App">
      {isAuthenticated ? "Logged in" : "Logged out or still loading"}
    </div>
  );
}
```

You can also use the `Authenticated`, `Unauthenticated` and `AuthLoading` helper
components which use the `useConvexAuth` hook under the hood:

```tsx title="src/App.ts"
import { Authenticated, Unauthenticated, AuthLoading } from "convex/react";

function App() {
  return (
    <div className="App">
      <Authenticated>Logged in</Authenticated>
      <Unauthenticated>Logged out</Unauthenticated>
      <AuthLoading>Still loading</AuthLoading>
    </div>
  );
}
```

## User information in React

You can access information about the authenticated user like their name from the
`useAuth0` hook:

```tsx title="src/badge.ts"
import { useAuth0 } from "@auth0/auth0-react";

export default function Badge() {
  const { user } = useAuth0();
  return <span>Logged in as {user.name}</span>;
}
```

## User information in functions

See [Auth in Functions](/auth/functions-auth.mdx) to learn about how to access
information about the authenticated user in your queries, mutations and actions.

See [Storing Users in the Convex Database](/auth/database-auth.mdx) to learn
about how to store user information in the Convex database.

## Configuring dev and prod tenants

To configure a different Auth0 tenant (environment) between your Convex
development and production deployments you can use environment variables
configured on the Convex dashboard.

### Configuring the backend

First, change your <JSDialectFileName name="auth.config.ts" /> file to use
environment variables:

```ts title="convex/auth.config.ts"
import { AuthConfig } from "convex/server";

export default {
  providers: [
    {
      domain: process.env.AUTH0_DOMAIN!,
      applicationID: process.env.AUTH0_CLIENT_ID!,
    },
  ],
} satisfies AuthConfig;
```

**Development configuration**

Open the Settings for your dev deployment on the Convex
[dashboard](https://dashboard.convex.dev) and add the variables there:

<p style={{ textAlign: "center" }}>
  <img
    src="/screenshots/auth0-convex-dashboard.png"
    alt="Convex dashboard dev deployment settings"
    width={600}
  />
</p>

Now switch to the new configuration by running `npx convex dev`.

**Production configuration**

Similarly on the Convex [dashboard](https://dashboard.convex.dev) switch to your
production deployment in the left side menu and set the values for your
production Auth0 tenant there.

Now switch to the new configuration by running `npx convex deploy`.

### Configuring a React client

To configure your client you can use environment variables as well. The exact
name of the environment variables and the way to refer to them depends on each
client platform (Vite vs Next.js etc.), refer to our corresponding
[Quickstart](/quickstarts.mdx) or the relevant documentation for the platform
you're using.

Change the props to `Auth0Provider` to take in environment variables:

<TSAndJSSnippet
  title="src/main.tsx"
  sourceTS={ConfigEnvTS}
  sourceJS={ConfigEnvJS}
  highlightPatterns={["domain=", "clientId="]}
/>

**Development configuration**

Use the `.env.local` or `.env` file to configure your client when running
locally. The name of the environment variables file depends on each client
platform (Vite vs Next.js etc.), refer to our corresponding
[Quickstart](/quickstarts.mdx) or the relevant documentation for the platform
you're using:

```py title=".env.local"
VITE_AUTH0_DOMAIN="your-domain.us.auth0.com"
VITE_AUTH0_CLIENT_ID="yourclientid"
```

**Production configuration**

Set the environment variables in your production environment depending on your
hosting platform. See [Hosting](/production/hosting/hosting.mdx).

## Debugging authentication

If a user goes through the Auth0 login flow successfully, and after being
redirected back to your page `useConvexAuth` gives `isAuthenticated: false`,
it's possible that your backend isn't correctly configured.

The <JSDialectFileName name="auth.config.ts" /> file in your `convex/` directory
contains a list of configured authentication providers. You must run
`npx convex dev` or `npx convex deploy` after adding a new provider to sync the
configuration to your backend.

For more thorough debugging steps, see
[Debugging Authentication](/auth/debug.mdx).

## Under the hood

<UnderTheHood
  provider="Auth0"
  integrationProvider={<code>ConvexProviderWithAuth0</code>}
  providerProvider={<code>Auth0Provider</code>}
  configProp={
    <>
      the{" "}
      <a
        href="https://auth0.github.io/auth0-react/interfaces/AuthorizationParams.html"
        target="_blank"
      >
        <code>authorizationParams</code>
      </a>{" "}
      prop
    </>
  }
/>



================================================
FILE: npm-packages/docs/docs/auth/clerk.mdx
================================================
---
title: "Convex & Clerk"
sidebar_label: "Clerk"
sidebar_position: 10
description: "Integrate Clerk authentication with Convex"
---

import UnderTheHood from "@site/docs/auth/_under_the_hood.mdx";
import ConfigTS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite-ts/src/_mainClerk.tsx";
import ConfigJS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/src/_mainClerk.jsx";
import ConfigEnvTS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite-ts/src/_mainClerkEnv.tsx";
import ConfigEnvJS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/src/_mainClerkEnv.jsx";
import App from "!!raw-loader!@site/../private-demos/snippets/src/clerkApp.tsx";
import Messages from "!!raw-loader!@site/../private-demos/snippets/convex/clerkMessages.ts";

[Clerk](https://clerk.com) is an authentication platform providing login via
passwords, social identity providers, one-time email or SMS access codes, and
multi-factor authentication and user management.

## Get started

Convex offers a provider that is specifically for integrating with Clerk called
`<ConvexProviderWithClerk>`. It works with any of Clerk's React-based SDKs, such
as the Next.js and Expo SDKs.

See the following sections for the Clerk SDK that you're using:

- [React](#react) - Use this as a starting point if your SDK is not listed
- [Next.js](#nextjs)
- [TanStack Start](#tanstack-start)

### React

**Example:**
[React with Convex and Clerk](https://github.com/get-convex/template-react-vite-clerk)

This guide assumes you already have a working React app with Convex. If not
follow the [Convex React Quickstart](/quickstart/react.mdx) first. Then:

<StepByStep>
  <Step title="Sign up for Clerk">
    Sign up for a free Clerk account at [clerk.com/sign-up](https://dashboard.clerk.com/sign-up).

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/clerk-signup.png" alt="Sign up to Clerk" width={200} />
    </p>

  </Step>
  <Step title="Create an application in Clerk">
    Choose how you want your users to sign in.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/clerk-createapp.png" alt="Create a Clerk application" width={200} />
    </p>

  </Step>
  <Step title="Create a JWT Template">
    In the Clerk Dashboard, navigate to the [JWT templates](https://dashboard.clerk.com/last-active?path=jwt-templates) page.

    Select _New template_ and then from the list of templates, select _Convex_. You'll be redirected to the template's settings page. **Do NOT rename the JWT token. It must be called `convex`.**

    Copy and save the _Issuer_ URL somewhere secure. This URL is the issuer domain for Clerk's JWT templates, which is your Clerk app's _Frontend API URL_. In development, it's format will be `https://verb-noun-00.clerk.accounts.dev`. In production, it's format will be `https://clerk.<your-domain>.com`.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/clerk-createjwt.png" alt="Create a JWT template" width={400} />
    </p>

  </Step>
  <Step title="Configure Convex with the Clerk issuer domain">
    In your app's `convex` folder, create a new file <JSDialectFileName name="auth.config.ts" /> with the following code. This is the server-side configuration for validating access tokens.

    ```ts title="convex/auth.config.ts"
    import { AuthConfig } from "convex/server";

    export default {
      providers: [
        {
          // Replace with your own Clerk Issuer URL from your "convex" JWT template
          // or with `process.env.CLERK_JWT_ISSUER_DOMAIN`
          // and configure CLERK_JWT_ISSUER_DOMAIN on the Convex Dashboard
          // See https://docs.convex.dev/auth/clerk#configuring-dev-and-prod-instances
          domain: process.env.CLERK_JWT_ISSUER_DOMAIN!,
          applicationID: "convex",
        },
      ]
    } satisfies AuthConfig;
    ```

  </Step>
  <Step title="Deploy your changes">
    Run `npx convex dev` to automatically sync your configuration to your backend.

    ```sh
    npx convex dev
    ```

  </Step>
  <Step title="Install clerk">
    In a new terminal window, install the Clerk React SDK:

    ```sh
    npm install @clerk/clerk-react
    ```

  </Step>
  <Step title="Set your Clerk API keys">
    In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page. In the **Quick Copy** section, copy your Clerk Publishable Key and set it as the `CLERK_PUBLISHABLE_KEY` environment variable. If you're using Vite, you will need to prefix it with `VITE_`.

    ```env title=".env"
    VITE_CLERK_PUBLISHABLE_KEY=YOUR_PUBLISHABLE_KEY
    ```

  </Step>
  <Step title="Configure ConvexProviderWithClerk">
    Both Clerk and Convex have provider components that are required to provide authentication and client context.

    You should already have `<ConvexProvider>` wrapping your app. Replace it with `<ConvexProviderWithClerk>`, and pass Clerk's `useAuth()` hook to it.

    Then, wrap it with `<ClerkProvider>`. `<ClerkProvider>` requires a `publishableKey` prop, which you can set to the `VITE_CLERK_PUBLISHABLE_KEY` environment variable.

    <TSAndJSSnippet
      title="src/main.tsx"
      sourceTS={ConfigTS}
      sourceJS={ConfigJS}
      highlightPatterns={["ClerkProvider", "ConvexProviderWithClerk"]}
    />

  </Step>

  <Step title="Show UI based on authentication state">
    You can control which UI is shown when the user is signed in or signed out using Convex's `<Authenticated>`, `<Unauthenticated>` and `<AuthLoading>` helper components. These should be used instead of Clerk's `<SignedIn>`, `<SignedOut>` and `<ClerkLoading>` components, respectively.

    It's important to use the [`useConvexAuth()`](/api/modules/react#useconvexauth) hook instead of
    Clerk's `useAuth()` hook when you need to check whether the user is logged in or
    not. The `useConvexAuth()` hook makes sure that the browser has fetched the auth
    token needed to make authenticated requests to your Convex backend, and that the
    Convex backend has validated it.

    In the following example, the `<Content />` component is a child of `<Authenticated>`, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require authentication.

    ```tsx title="src/App.tsx"
    import { SignInButton, UserButton } from "@clerk/clerk-react";
    import { Authenticated, Unauthenticated, AuthLoading, useQuery } from "convex/react";
    import { api } from "../convex/_generated/api";

    function App() {
      return (
        <main>
          <Unauthenticated>
            <SignInButton />
          </Unauthenticated>
          <Authenticated>
            <UserButton />
            <Content />
          </Authenticated>
          <AuthLoading>
            <p>Still loading</p>
          </AuthLoading>
        </main>
      );
    }

    function Content() {
      const messages = useQuery(api.messages.getForCurrentUser);
      return <div>Authenticated content: {messages?.length}</div>;
    }

    export default App;
    ```

  </Step>

  <Step title="Use authentication state in your Convex functions">
    If the client is authenticated, you can access the information
    stored in the JWT via `ctx.auth.getUserIdentity`.

    If the client isn't authenticated, `ctx.auth.getUserIdentity` will return `null`.

    **Make sure that the component calling this query is a child of `<Authenticated>` from
    `convex/react`**. Otherwise, it will throw on page load.

    <TSAndJSSnippet
      title="convex/messages.ts"
      sourceTS={Messages}
      sourceJS={Messages}
    />

  </Step>
</StepByStep>

### Next.js

**Example:**
[Next.js with Convex and Clerk](https://github.com/get-convex/template-nextjs-clerk)

This guide assumes you already have a working Next.js app with Convex. If not
follow the [Convex Next.js Quickstart](/quickstart/nextjs.mdx) first. Then:

<StepByStep>
  <Step title="Sign up for Clerk">
    Sign up for a free Clerk account at [clerk.com/sign-up](https://dashboard.clerk.com/sign-up).

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/clerk-signup.png" alt="Sign up to Clerk" width={200} />
    </p>

  </Step>
  <Step title="Create an application in Clerk">
    Choose how you want your users to sign in.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/clerk-createapp.png" alt="Create a Clerk application" width={200} />
    </p>

  </Step>
  <Step title="Create a JWT Template">
    In the Clerk Dashboard, navigate to the [JWT templates](https://dashboard.clerk.com/last-active?path=jwt-templates) page.

    Select _New template_ and then from the list of templates, select _Convex_. You'll be redirected to the template's settings page. **Do NOT rename the JWT token. It must be called `convex`.**

    Copy and save the _Issuer_ URL somewhere secure. This URL is the issuer domain for Clerk's JWT templates, which is your Clerk app's _Frontend API URL_. In development, it's format will be `https://verb-noun-00.clerk.accounts.dev`. In production, it's format will be `https://clerk.<your-domain>.com`.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/clerk-createjwt.png" alt="Create a JWT template" width={400} />
    </p>

  </Step>
  <Step title="Configure Convex with the Clerk issuer domain">
    In your app's `convex` folder, create a new file <JSDialectFileName name="auth.config.ts" /> with the following code. This is the server-side configuration for validating access tokens.

    ```ts title="convex/auth.config.ts"
    import { AuthConfig } from "convex/server";

    export default {
      providers: [
        {
          // Replace with your own Clerk Issuer URL from your "convex" JWT template
          // or with `process.env.CLERK_JWT_ISSUER_DOMAIN`
          // and configure CLERK_JWT_ISSUER_DOMAIN on the Convex Dashboard
          // See https://docs.convex.dev/auth/clerk#configuring-dev-and-prod-instances
          domain: process.env.CLERK_JWT_ISSUER_DOMAIN!,
          applicationID: "convex",
        },
      ]
    } satisfies AuthConfig;
    ```

  </Step>
  <Step title="Deploy your changes">
    Run `npx convex dev` to automatically sync your configuration to your backend.

    ```sh
    npx convex dev
    ```

  </Step>
  <Step title="Install clerk">
    In a new terminal window, install the Clerk Next.js SDK:

    ```sh
    npm install @clerk/nextjs
    ```

  </Step>
  <Step title="Set your Clerk API keys">
    In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys and set them as the `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` and `CLERK_SECRET_KEY` environment variables, respectively.

    ```env title=".env"
    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=YOUR_PUBLISHABLE_KEY
    CLERK_SECRET_KEY=YOUR_SECRET_KEY
    ```

  </Step>
  <Step title="Add Clerk middleware">
    Clerk's `clerkMiddleware()` helper grants you access to user authentication state throughout your app.

    Create a `middleware.ts` file.

    In your `middleware.ts` file, export the `clerkMiddleware()` helper:

    ```tsx {{ filename: 'middleware.ts' }}
    import { clerkMiddleware } from '@clerk/nextjs/server'

    export default clerkMiddleware()

    export const config = {
      matcher: [
        // Skip Next.js internals and all static files, unless found in search params
        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
        // Always run for API routes
        '/(api|trpc)(.*)',
      ],
    }
    ```

    By default, `clerkMiddleware()` will not protect any routes. All routes are public and you must opt-in to protection for routes.https://clerk.com/docs/references/nextjs/clerk-middleware) to learn how to require authentication for specific routes.

  </Step>
  <Step title="Configure ConvexProviderWithClerk">
    Both Clerk and Convex have provider components that are required to provide authentication and client context.

    Typically, you'd replace `<ConvexProvider>` with `<ConvexProviderWithClerk>`, but with Next.js App Router, things are a bit more complex.

    `<ConvexProviderWithClerk>` calls `ConvexReactClient()` to get Convex's client, so it must be used in a Client Component. Your `app/layout.tsx`, where you would use `<ConvexProviderWithClerk>`, is a Server Component, and a Server Component cannot contain Client Component code. To solve this, you must first create a _wrapper_ Client Component around `<ConvexProviderWithClerk>`.

    ```tsx {{ filename: 'components/ConvexClientProvider.tsx' }}
    'use client'

    import { ReactNode } from 'react'
    import { ConvexReactClient } from 'convex/react'
    import { ConvexProviderWithClerk } from 'convex/react-clerk'
    import { useAuth } from '@clerk/nextjs'

    if (!process.env.NEXT_PUBLIC_CONVEX_URL) {
      throw new Error('Missing NEXT_PUBLIC_CONVEX_URL in your .env file')
    }

    const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL)

    export default function ConvexClientProvider({ children }: { children: ReactNode }) {
      return (
        <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
          {children}
        </ConvexProviderWithClerk>
      )
    }
    ```

  </Step>
  <Step title="Wrap your app in Clerk and Convex">
    Now, your Server Component, `app/layout.tsx`, can render `<ConvexClientProvider>` instead of rendering `<ConvexProviderWithClerk>` directly. It's important that `<ClerkProvider>` wraps `<ConvexClientProvider>`, and not the other way around, as Convex needs to be able to access the Clerk context.

    ```tsx {{ filename: 'app/layout.tsx', mark: [5, 31] }}
    import type { Metadata } from 'next'
    import { Geist, Geist_Mono } from 'next/font/google'
    import './globals.css'
    import { ClerkProvider } from '@clerk/nextjs'
    import ConvexClientProvider from '@/components/ConvexClientProvider'

    const geistSans = Geist({
      variable: '--font-geist-sans',
      subsets: ['latin'],
    })

    const geistMono = Geist_Mono({
      variable: '--font-geist-mono',
      subsets: ['latin'],
    })

    export const metadata: Metadata = {
      title: 'Clerk Next.js Quickstart',
      description: 'Generated by create next app',
    }

    export default function RootLayout({
      children,
    }: Readonly<{
      children: React.ReactNode
    }>) {
      return (
        <html lang="en">
          <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
            <ClerkProvider>
              <ConvexClientProvider>{children}</ConvexClientProvider>
            </ClerkProvider>
          </body>
        </html>
      )
    }
    ```

  </Step>
  <Step title="Show UI based on authentication state">
    You can control which UI is shown when the user is signed in or signed out using Convex's `<Authenticated>`, `<Unauthenticated>` and `<AuthLoading>` helper components. These should be used instead of Clerk's `<SignedIn>`, `<SignedOut>` and `<ClerkLoading>` components, respectively.

    It's important to use the [`useConvexAuth()`](/api/modules/react#useconvexauth) hook instead of
    Clerk's `useAuth()` hook when you need to check whether the user is logged in or
    not. The `useConvexAuth()` hook makes sure that the browser has fetched the auth
    token needed to make authenticated requests to your Convex backend, and that the
    Convex backend has validated it.

    In the following example, the `<Content />` component is a child of `<Authenticated>`, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require authentication.

    ```tsx title="app/page.tsx"
    "use client";

    import { Authenticated, Unauthenticated } from "convex/react";
    import { SignInButton, UserButton } from "@clerk/nextjs";
    import { useQuery } from "convex/react";
    import { api } from "../convex/_generated/api";

    export default function Home() {
      return (
        <>
          <Authenticated>
            <UserButton />
            <Content />
          </Authenticated>
          <Unauthenticated>
            <SignInButton />
          </Unauthenticated>
        </>
      );
    }

    function Content() {
      const messages = useQuery(api.messages.getForCurrentUser);
      return <div>Authenticated content: {messages?.length}</div>;
    }
    ```

  </Step>

  <Step title="Use authentication state in your Convex functions">
    If the client is authenticated, you can access the information
    stored in the JWT via `ctx.auth.getUserIdentity`.

    If the client isn't authenticated, `ctx.auth.getUserIdentity` will return `null`.

    **Make sure that the component calling this query is a child of `<Authenticated>` from
    `convex/react`**. Otherwise, it will throw on page load.

    <TSAndJSSnippet
      title="convex/messages.ts"
      sourceTS={Messages}
      sourceJS={Messages}
    />

  </Step>
</StepByStep>

### TanStack Start

**Example:**
[TanStack Start with Convex and Clerk](https://github.com/get-convex/templates/tree/main/template-tanstack-start)

See the
[TanStack Start with Clerk guide](/client/tanstack/tanstack-start/clerk.mdx) for
more information.

## Next steps

### Accessing user information in functions

See [Auth in Functions](/auth/functions-auth.mdx) to learn about how to access
information about the authenticated user in your queries, mutations and actions.

See [Storing Users in the Convex Database](/auth/database-auth.mdx) to learn
about how to store user information in the Convex database.

### Accessing user information client-side

To access the authenticated user's information, use Clerk's `User` object, which
can be accessed using Clerk's
[`useUser()`](https://clerk.com/docs/hooks/use-user) hook. For more information
on the `User` object, see the
[Clerk docs](https://clerk.com/docs/references/javascript/user).

```tsx title="components/Badge.tsx"
export default function Badge() {
  const { user } = useUser();

  return <span>Logged in as {user.fullName}</span>;
}
```

## Configuring dev and prod instances

To configure a different Clerk instance between your Convex development and
production deployments, you can use environment variables configured on the
Convex dashboard.

### Configuring the backend

In the Clerk Dashboard, navigate to the
[**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page. Copy
your Clerk Frontend API URL. This URL is the issuer domain for Clerk's JWT
templates, and is necessary for Convex to validate access tokens. In
development, it's format will be `https://verb-noun-00.clerk.accounts.dev`. In
production, it's format will be `https://clerk.<your-domain>.com`.

Paste your Clerk Frontend API URL into your `.env` file, set it as the
`CLERK_JWT_ISSUER_DOMAIN` environment variable.

```env title=".env"
CLERK_JWT_ISSUER_DOMAIN=https://verb-noun-00.clerk.accounts.dev
```

Then, update your <JSDialectFileName name="auth.config.ts" /> file to use the
environment variable.

```ts title="convex/auth.config.ts"
import { AuthConfig } from "convex/server";

export default {
  providers: [
    {
      domain: process.env.CLERK_JWT_ISSUER_DOMAIN!,
      applicationID: "convex",
    },
  ],
} satisfies AuthConfig;
```

**Development configuration**

In the left sidenav of the Convex [dashboard](https://dashboard.convex.dev),
switch to your development deployment and set the values for your development
Clerk instance.

{/* TODO: Update screenshot to use `CLERK_FRONTEND_API_URL`. It should be in the format `https://verb-noun-00.clerk.accounts.dev` */}

<p style={{ textAlign: "center" }}>
  <img
    src="/screenshots/clerk-convex-dashboard.png"
    alt="Convex dashboard dev deployment settings"
    width={600}
  />
</p>

Then, to switch your deployment to the new configuration, run `npx convex dev`.

**Production configuration**

In the left sidenav of the Convex [dashboard](https://dashboard.convex.dev),
switch to your production deployment and set the values for your production
Clerk instance.

{/* TODO: Add screenshot of production configuration in Convex dashboard. The `CLERK_FRONTEND_API_URL` should be in the format `https://clerk.<your-domain>.com` */}

Then, to switch your deployment to the new configuration, run
`npx convex deploy`.

### Configuring Clerk's API keys

Clerk's API keys differ depending on whether they are for development or
production. Don't forget to update the environment variables in your `.env` file
as well as your hosting platform, such as Vercel or Netlify.

**Development configuration**

Clerk's Publishable Key for development follows the format `pk_test_...`.

```py title=".env.local"
VITE_CLERK_PUBLISHABLE_KEY="pk_test_..."
```

**Production configuration**

Clerk's Publishable Key for production follows the format `pk_live_...`.

```py title=".env"
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="pk_live_..."
```

## Debugging authentication

If a user goes through the Clerk login flow successfully, and after being
redirected back to your page, `useConvexAuth()` returns
`isAuthenticated: false`, it's possible that your backend isn't correctly
configured.

The <JSDialectFileName name="auth.config.ts" /> file contains a list of
configured authentication providers. You must run `npx convex dev` or
`npx convex deploy` after adding a new provider to sync the configuration to
your backend.

For more thorough debugging steps, see
[Debugging Authentication](/auth/debug.mdx).

## Under the hood

<UnderTheHood
  provider="Clerk"
  integrationProvider={<code>ConvexProviderWithClerk</code>}
  providerProvider={<code>ClerkProvider</code>}
  configProp={
    <>
      the{" "}
      <a
        href="https://clerk.com/docs/authentication/sign-in#override-ur-ls"
        target="_blank"
      >
        <code>afterSignIn</code>
      </a>{" "}
      prop
    </>
  }
/>



================================================
FILE: npm-packages/docs/docs/auth/convex-auth.mdx
================================================
---
title: "Convex Auth"
sidebar_label: "Convex Auth"
sidebar_position: 1
description: "Built-in authentication for Convex applications"
---

[Convex Auth](https://labs.convex.dev/auth) is a library for implementing
authentication directly within your Convex backend. This allows you to
authenticate users without needing an authentication service or even a hosting
server. Convex Auth currently supports client-side React web apps served from a
CDN and React Native mobile apps.

**Example:** [Live Demo](https://labs.convex.dev/auth-example)
([Source](https://github.com/get-convex/convex-auth-example))

<BetaAdmonition feature="Convex Auth" verb="is" />

Support for
[authentication in Next.js](https://labs.convex.dev/auth/authz/nextjs) server
components, API routes, middleware, SSR etc. is under active development. If
you'd like to help test this experimental support please
[let us know how it goes in Discord](https://convex.dev/community).

## Get Started

To start a new project from scratch with Convex and Convex Auth, run:

```sh
npm create convex@latest
```

and choose `React (Vite)` and `Convex Auth`.

---

To add Convex Auth to an existing project, follow the full
[setup guide](https://labs.convex.dev/auth/setup).

## Overview

Convex Auth enables you to implement the following authentication methods:

1. Magic Links & OTPs - send a link or code via email
2. OAuth - sign in with GitHub / Google / Apple etc.
3. Passwords - including password reset flow and optional email verification

The library doesn't come with UI components, but you can copy code from the docs
and example repo to quickly build a UI in React.

Learn more in the [Convex Auth docs](https://labs.convex.dev/auth).



================================================
FILE: npm-packages/docs/docs/auth/database-auth.mdx
================================================
---
title: "Storing Users in the Convex Database"
sidebar_label: "Database"
sidebar_position: 120
description: "Store user information in your Convex database"
---

import Schema from "!!raw-loader!@site/../demos/users-and-clerk/convex/schema.ts";
import useStoreUserEffectTS from "!!raw-loader!@site/../demos/users-and-clerk/src/useStoreUserEffect.ts";
import useStoreUserEffectJS from "!!raw-loader!@site/../private-demos/snippets/users-and-clerk/useStoreUserEffect.js";
import MessagesTS from "!!raw-loader!@site/../demos/users-and-clerk/convex/messages.ts";
import UsersTS from "!!raw-loader!@site/../demos/users-and-clerk/convex/users.ts";
import App from "!!raw-loader!@site/../private-demos/snippets/src/clerkStoreUserApp.tsx";
import WebhooksSchema from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/convex/schema.ts";
import WebhookMutations from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/convex/users.ts";
import WebhookEndpoint from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/convex/http.ts";
import WebhookMessages from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/convex/messages.ts";
import WebhookHook from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/src/useCurrentUser.ts";
import WebhookClient from "!!raw-loader!@site/../demos/users-and-clerk-webhooks/src/App.tsx";

_If you're using [Convex Auth](/auth/convex-auth.mdx) the user information is
already stored in your database. There's nothing else you need to implement._

You might want to store user information directly in your Convex database, for
the following reasons:

- Your functions need information about other users, not just about the
  currently logged-in user
- Your functions need access to information other than the fields available in
  the [Open ID Connect JWT](/auth/functions-auth.mdx)

There are two ways you can choose from for storing user information in your
database (but only the second one allows storing information not contained in
the JWT):

1. Have your app's [client call a mutation](#call-a-mutation-from-the-client)
   that stores the information from the JWT available on
   [`ctx.auth`](/api/interfaces/server.Auth)
2. [Implement a webhook](#set-up-webhooks) and have your identity provider call
   it whenever user information changes

## Call a mutation from the client

**Example:**
[Convex Authentication with Clerk](https://github.com/get-convex/convex-demos/tree/main/users-and-clerk)

### (optional) Users table schema

You can define a `"users"` table, optionally with an
[index](/database/reading-data/indexes/indexes.md) for efficient looking up the
users in the database.

In the examples below we will use the `tokenIdentifier` from the
`ctx.auth.getUserIdentity()` to identify the user, but you could use the
`subject` field (which is usually set to the unique user ID from your auth
provider) or even `email`, if your authentication provider provides email
verification and you have it enabled.

Which field you use will determine how multiple providers interact, and how hard
it will be to migrate to a different provider.

<Snippet source={Schema} snippet="user" title="convex/schema.ts" />

### Mutation for storing current user

This is an example of a mutation that stores the user's `name` and
`tokenIdentifier`:

<TSAndJSSnippet sourceTS={UsersTS} sourceJS={UsersTS} title="convex/users.js" />

### Calling the store user mutation from React

You can call this mutation when the user logs in from a `useEffect` hook. After
the mutation succeeds you can update local state to reflect that the user has
been stored.

This helper hook that does the job:

<TSAndJSSnippet
  sourceTS={useStoreUserEffectTS}
  sourceJS={useStoreUserEffectJS}
  title="src/useStoreUserEffect.ts"
/>

You can use this hook in your top-level component. If your queries need the user
document to be present, make sure that you only render the components that call
them after the user has been stored:

<TSAndJSSnippet sourceTS={App} sourceJS={App} title="src/App.tsx" />

In this way the `useStoreUserEffect` hook replaces the `useConvexAuth` hook.

### Using the current user's document ID

Similarly to the store user mutation, you can retrieve the current user's ID, or
throw an error if the user hasn't been stored.

Now that you have users stored as documents in your Convex database, you can use
their IDs as foreign keys in other documents:

<TSAndJSSnippet
  sourceTS={MessagesTS}
  sourceJS={MessagesTS}
  snippet="load-user"
  title="convex/messages.ts"
  suffix={`    // do something with \`user\`...
  }
});`}
/>

### Loading users by their ID

The information about other users can be retrieved via their IDs:

<TSAndJSSnippet
  sourceTS={MessagesTS}
  sourceJS={MessagesTS}
  snippet="use-users"
  title="convex/messages.ts"
  prefix={`import { query } from "./_generated/server";
`}
/>

## Set up webhooks

This guide will use Clerk, but Auth0 can be set up similarly via
[Auth0 Actions](https://auth0.com/docs/customize/actions/actions-overview).

With this implementation Clerk will call your Convex backend via an HTTP
endpoint any time a user signs up, updates or deletes their account.

**Example:**
[Convex Authentication with Clerk and Webhooks](https://github.com/get-convex/convex-demos/tree/main/users-and-clerk-webhooks)

### Configure the webhook endpoint in Clerk

On your Clerk dashboard, go to _Webhooks_, click on _+ Add Endpoint_.

Set _Endpoint URL_ to
`https://<your deployment name>.convex.site/clerk-users-webhook` (note the
domain ends in **`.site`**, not `.cloud`). You can see your deployment name in
the `.env.local` file in your project directory, or on your Convex dashboard as
part of the [Deployment URL](/dashboard/deployments/settings.md). For example,
the endpoint URL could be:
`https://happy-horse-123.convex.site/clerk-users-webhook`.

In _Message Filtering_, select **user** for all user events (scroll down or use
the search input).

Click on _Create_.

After the endpoint is saved, copy the _Signing Secret_ (on the right side of the
UI), it should start with `whsec_`. Set it as the value of the
`CLERK_WEBHOOK_SECRET` environment variable in your Convex
[dashboard](https://dashboard.convex.dev).

### (optional) Users table schema

You can define a `"users"` table, optionally with an
[index](/database/reading-data/indexes/indexes.md) for efficient looking up the
users in the database.

In the examples below we will use the `subject` from the
`ctx.auth.getUserIdentity()` to identify the user, which should be set to the
Clerk user ID.

<Snippet source={WebhooksSchema} snippet="table" title="convex/schema.ts" />

### Mutations for upserting and deleting users

This is an example of mutations that handle the updates received via the
webhook:

<TSAndJSSnippet
  sourceTS={WebhookMutations}
  sourceJS={WebhookMutations}
  title="convex/users.ts"
/>

There are also a few helpers in this file:

- `current` exposes the user information to the client, which will helps the
  client determine whether the webhook already succeeded
- `upsertFromClerk` will be called when a user signs up or when they update
  their account
- `deleteFromClerk` will be called when a user deletes their account via Clerk
  UI from your app
- `getCurrentUserOrThrow` retrieves the currently logged-in user or throws an
  error
- `getCurrentUser` retrieves the currently logged-in user or returns null
- `userByExternalId` retrieves a user given the Clerk ID, and is used only for
  retrieving the current user or when updating an existing user via the webhook

### Webhook endpoint implementation

This how the actual HTTP endpoint can be implemented:

<TSAndJSSnippet
  sourceTS={WebhookEndpoint}
  sourceJS={WebhookEndpoint}
  title="convex/http.ts"
/>

If you deploy your code now and sign in, you should see the user being created
in your Convex database.

### Using the current user's document

You can use the helpers defined before to retrieve the current user's document.

Now that you have users stored as documents in your Convex database, you can use
their IDs as foreign keys in other documents:

<TSAndJSSnippet
  sourceTS={WebhookMessages}
  sourceJS={WebhookMessages}
  snippet="current-user"
  title="convex/messages.ts"
/>

### Loading users by their ID

The information about other users can be retrieved via their IDs:

<TSAndJSSnippet
  sourceTS={MessagesTS}
  sourceJS={MessagesTS}
  snippet="use-users"
  title="convex/messages.ts"
/>

### Waiting for current user to be stored

If you want to use the current user's document in a query, make sure that the
user has already been stored. You can do this by explicitly checking for this
condition before rendering the components that call the query, or before
redirecting to the authenticated portion of your app.

For example you can define a hook that determines the current authentication
state of the client, taking into account whether the current user has been
stored:

<TSAndJSSnippet
  sourceTS={WebhookHook}
  sourceJS={WebhookHook}
  title="src/useCurrentUser.ts"
/>

And then you can use it to render the appropriate components:

<TSAndJSSnippet
  sourceTS={WebhookClient}
  sourceJS={WebhookClient}
  snippet="client-blocking"
  title="src/App.tsx"
/>



================================================
FILE: npm-packages/docs/docs/auth/debug.mdx
================================================
---
title: "Debugging Authentication"
sidebar_label: "Debugging"
sidebar_position: 130
description: "Troubleshoot authentication issues in Convex"
---

# Debugging Authentication

You have followed one of our authentication guides but something is not working.
You have double checked that you followed all the steps, and that you used the
correct secrets, but you are still stuck.

## Frequently encountered issues

### `ctx.auth.getUserIdentity()` returns `null` in a query

This often happens when subscribing to queries via `useQuery` in React, without
waiting for the client to be authenticated. Even if the user has been logged-in
previously, it takes some time for the client to authenticate with the Convex
backend. Therefore on page load, `ctx.auth.getUserIdentity()` called within a
query returns `null`.

To handle this, you can either:

1. Use the `Authenticated` component from `convex/react` to wrap the component
   that includes the `useQuery` call (see the last two steps in the
   [Clerk guide](/auth/clerk.mdx#get-started))
2. Or return `null` or some other "sentinel" value from the query and handle it
   on the client

If you are using `fetchQuery` for
[Next.js Server Rendering](/client/nextjs/app-router/server-rendering.mdx), make
sure you are explicitly passing in a JWT token as documented
[here](/client/nextjs/app-router/server-rendering.mdx#server-side-authentication).

If this hasn't helped, follow the steps below to resolve your issue.

## Step 1: Check whether authentication works on the backend

1. Add the following code to the _beginning_ of your function (query, mutation,
   action or http action):

```ts
console.log("server identity", await ctx.auth.getUserIdentity());
```

2. Then call this function from whichever client you're using to talk to Convex.

3. Open the
   [logs page on your dashboard](https://dashboard.convex.dev/deployment/logs).

4. What do you see on the logs page?

   **Answer: I don't see anything**:

   - Potential cause: You don't have the right dashboard open. Confirm that the
     Deployment URL on _Settings_ > _URL and Deploy Key_ page matches how your
     client is configured.
   - Potential cause: Your client is not connected to Convex. Check your client
     logs (browser logs) for errors. Reload the page / restart the client.
   - Potential cause: The code has not been pushed. For dev deployments make
     sure you have `npx convex dev` running. For prod deployments make sure you
     successfully pushed via `npx convex deploy`. Go to the _Functions_ page on
     the dashboard and check that the code shown there includes the
     `console.log` line you added.

   When you resolved the cause you should see the log appear.

   **Answer: I see a log with `'server identity' null`**:

   - Potential cause: The client is not supplying an auth token.
   - Potential cause: Your deployment is misconfigured.
   - Potential cause: Your client is misconfigured.

   Proceed to
   [step 2](#step-2-check-whether-authentication-works-on-the-frontend).

   **Answer: I see a log with `'server identity' { tokenIdentifier: '... } `**

   Great, you are all set!

## Step 2: Check whether authentication works on the frontend

No matter which client you use, it must pass a JWT token to your backend for
authentication to work.

The most bullet-proof way of ensuring your client is passing the token to the
backend, is to inspect the traffic between them.

1. If you're using a client from the web browser, open the _Network_ tab in your
   browser's developer tools.

2. Check the token

   - For Websocket-based clients (`ConvexReactClient` and `ConvexClient`),
     filter for the `sync` name and select `WS` as the type of traffic. Check
     the `sync` items. After the client is initialized (commonly after loading
     the page), it will send a message (check the _Messages_ tab) with
     `type: "Authenticate"`, and `value` will be the authentication token.

     <p style={{ textAlign: "center" }}>
       <img
         src="/screenshots/auth-ws.png"
         alt="Network tab inspecting Websocket messages"
         width={500}
       />
     </p>

   - For HTTP based clients (`ConvexHTTPClient` and the
     [HTTP API](/http-api/index.md)), select `Fetch/XHR` as the type of traffic.
     You should see an individual network request for each function call, with
     an `Authorization` header with value `Bearer ` followed by the
     authentication token.

     <p style={{ textAlign: "center" }}>
       <img
         src="/screenshots/auth-http.png"
         alt="Network tab inspecting HTTP headers"
         width={480}
       />
     </p>

3. Do you see the authentication token in the traffic?

   **Answer: No**:

   - Potential cause: The Convex client is not configured to get/fetch a JWT
     token. You're not using
     `ConvexProviderWithClerk`/`ConvexProviderWithAuth0`/`ConvexProviderWithAuth`
     with the `ConvexReactClient` or you forgot to call `setAuth` on
     `ConvexHTTPClient` or `ConvexClient`.
   - Potential cause: You are not signed in, so the token is `null` or
     `undefined` and the `ConvexReactClient` skipped authentication altogether.
     Verify that you are signed in via `console.log`ing the token from whichever
     auth provider you are using:

     - Clerk:

       ```tsx
       // import { useAuth } from "@clerk/nextjs"; // for Next.js
       import { useAuth } from "@clerk/clerk-react";

       const { getToken } = useAuth();
       console.log(getToken({ template: "convex" }));
       ```

     - Auth0:

       ```tsx
       import { useAuth0 } from "@auth0/auth0-react";

       const { getAccessTokenSilently } = useAuth0();
       const response = await getAccessTokenSilently({
         detailedResponse: true,
       });
       const token = response.id_token;
       console.log(token);
       ```

     - Custom: However you implemented `useAuthFromProviderX`

     If you don't see a long string that looks like a token, check the browser
     logs for errors from your auth provider. If there are none, check the
     Network tab to see whether requests to your provider are failing. Perhaps
     the auth provider is misconfigured. Double check the auth provider
     configuration (in the corresponding React provider or however your auth
     provider is configured for the client). Try clearing your cookies in the
     browser (in dev tools _Application_ > _Cookies_ > _Clear all cookies_
     button).

   **Answer: Yes, I see a long string that looks like a JWT**:

   Great, copy the whole token (there can be `.`s in it, so make sure you're not
   copying just a portion of it).

4. Open https://jwt.io/, scroll down and paste the token in the Encoded textarea
   on the left of the page. On the right you should see:

   - In _HEADER_, `"typ": "JWT"`
   - in _PAYLOAD_, a valid JSON with at least `"aud"`, `"iss"` and `"sub"`
     fields. If you see gibberish in the payload you probably didn't copy the
     token correctly or it's not a valid JWT token.

   If you see a valid JWT token, repeat
   [step 1](#step-1-check-whether-authentication-works-on-the-backend). If you
   still don't see correct identity, proceed to step 3.

## Step 3: Check that backend configuration matches frontend configuration

You have a valid JWT token on the frontend, and you know that it is being passed
to the backend, but the backend is not validating it.

1. Open the _Settings_ > _Authentication_ on your dashboard. What do you see?

   **Answer: I see
   `This deployment has no configured authentication providers`**:

   - Cause: You do not have an `auth.config.ts` (or `auth.config.js`) file in
     your `convex` directory, or you haven't pushed your code. Follow the
     authentication guide to create a valid auth config file. For dev
     deployments make sure you have `npx convex dev` running. For prod
     deployments make sure you successfully pushed via `npx convex deploy`.

   \*\*Answer: I see one or more _Domain_ and _Application ID_ pairs.

Great, let's check they match the JWT token.

2. Look at the `iss` field in the JWT token payload at https://jwt.io/. Does it
   match a _Domain_ on the _Authentication_ page?

   **Answer: No, I don't see the `iss` URL on the Convex dashboard**:

   - Potential cause: You copied the wrong value into your
     <JSDialectFileName name="auth.config.ts" />
     's `domain`, or into the environment variable that is used there. Go back
     to the authentication guide and make sure you have the right URL from your
     auth provider.
   - Potential cause: Your client is misconfigured:

     - Clerk: You have the wrong `publishableKey` configured. The key must
       belong to the Clerk instance that you used to configure your

       <JSDialectFileName name="auth.config.ts" />.

       - Also make sure that the JWT token in Clerk is called `convex`, as
         that's the name `ConvexProviderWithClerk` uses to fetch the token!

     - Auth0: You have the wrong `domain` configured (on the client!). The
       domain must belong to the Auth0 instance that you used to configure your
       <JSDialectFileName name="auth.config.ts" />.
     - Custom: Make sure that your client is correctly configured to match your
       <JSDialectFileName name="auth.config.ts" />.

   **Answer: Yes, I do see the `iss` URL**:

   Great, let's move one.

3. Look at the `aud` field in the JWT token payload at https://jwt.io/. Does it
   match the _Application ID_ under the correct _Domain_ on the _Authentication_
   page?

   **Answer: No, I don't see the `aud` value in the _Application ID_ field**:

   - Potential cause: You copied the wrong value into your
     <JSDialectFileName name="auth.config.ts" />
     's `applicationID`, or into the environment variable that is used there. Go
     back to the authentication guide and make sure you have the right value
     from your auth provider.
   - Potential cause: Your client is misconfigured:
     - Clerk: You have the wrong `publishableKey` configured.The key must belong
       to the Clerk instance that you used to configure your
       <JSDialectFileName name="auth.config.ts" />.
     - Auth0: You have the wrong `clientId` configured. Make sure you're using
       the right `clientId` for the Auth0 instance that you used to configure
       your <JSDialectFileName name="auth.config.ts" />.
     - Custom: Make sure that your client is correctly configured to match your
       <JSDialectFileName name="auth.config.ts" />.

   **Answer: Yes, I do see the `aud` value in the _Application ID_ field**:

   Great, repeat
   [step 1](#step-1-check-whether-authentication-works-on-the-backend) and you
   should be all set!



================================================
FILE: npm-packages/docs/docs/auth/functions-auth.mdx
================================================
---
title: "Auth in Functions"
sidebar_label: "Functions"
sidebar_position: 100
description: "Access user authentication in Convex functions"
---

import Example from "!!raw-loader!@site/../private-demos/snippets/convex/authFunctions.ts";
import FieldsTS from "!!raw-loader!@site/../private-demos/snippets/convex/authFunctionsFields.ts";
import FieldsJS from "!!raw-loader!@site/../private-demos/snippets/convex/authFunctionsFieldsJS.js";
import Fetch from "!!raw-loader!@site/../private-demos/snippets/src/httpAuthCall.ts";

_If you're using Convex Auth, see the
[authorization doc](https://labs.convex.dev/auth/authz#use-authentication-state-in-backend-functions)._

Within a Convex [function](/functions.mdx), you can access information about the
currently logged-in user by using the [`auth`](/api/interfaces/server.Auth)
property of the [`QueryCtx`](/generated-api/server#queryctx),
[`MutationCtx`](/generated-api/server#mutationctx), or
[`ActionCtx`](/generated-api/server#actionctx) object:

<TSAndJSSnippet
  sourceTS={Example}
  sourceJS={Example}
  title="convex/myFunctions.ts"
/>

## User identity fields

The [UserIdentity](/api/interfaces/server.UserIdentity) object returned by
`getUserIdentity` is guaranteed to have `tokenIdentifier`, `subject` and
`issuer` fields. Which other fields it will include depends on the identity
provider used and the configuration of JWT tokens and
[OpenID scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).

`tokenIdentifier` is a combination of `subject` and `issuer` to ensure
uniqueness even when multiple providers are used.

If you followed one of our integrations with Clerk or Auth0 at least the
following fields will be present: `familyName`, `givenName`, `nickname`,
`pictureUrl`, `updatedAt`, `email`, `emailVerified`. See their corresponding
standard definition in the
[OpenID docs](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).

<TSAndJSSnippet
  sourceTS={FieldsTS}
  sourceJS={FieldsJS}
  title="convex/myFunctions.ts"
/>

### Clerk claims configuration

If you're using Clerk, the fields returned by `getUserIdentity` are determined
by your JWT template's _Claims_ config. If you've set custom claims, they will
be returned by `getUserIdentity` as well.

### Custom JWT Auth

If you're using [Custom JWT auth](/auth/advanced/custom-jwt.mdx) instead of
OpenID standard fields you'll find each nested field available at
dot-containing-string field names like `identity["properties.email"]`.

## HTTP Actions

You can also access the user identity from an HTTP action
[`ctx.auth.getUserIdentity()`](/api/interfaces/server.Auth#getuseridentity), by
calling your endpoint with an `Authorization` header including a JWT token:

<TSAndJSSnippet sourceTS={Fetch} sourceJS={Fetch} title="myPage.ts" />

<StackPosts query="authentication functions" />



================================================
FILE: npm-packages/docs/docs/auth/advanced/custom-auth.mdx
================================================
---
title: "Custom OIDC Provider"
sidebar_label: "Custom OIDC Provider"
sidebar_position: 3
description:
  "Integrate Convex with any OpenID Connect identity provider using custom
  authentication configuration and ConvexProviderWithAuth."
---

**Note: This is an advanced feature!** We recommend sticking with the
[supported third-party authentication providers](/auth.mdx).

Convex can be integrated with any identity provider supporting the
[OpenID Connect](https://openid.net/connect/) protocol. At minimum this means
that the provider can issue
[ID tokens](https://openid.net/specs/openid-connect-core-1_0.html#IDToken) and
exposes the corresponding
[JWKS](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets).
The ID token is passed from the client to your Convex backend which ensures that
the token is valid and enables you to query the user information embedded in the
token, as described in [Auth in Functions](/auth/functions-auth.mdx).

## Server-side integration

Just like with [Clerk](/auth/clerk.mdx) and [Auth0](/auth/auth0.mdx), the
backend needs to be aware of the domain of the Issuer and your application's
specific applicationID for a given identity provider.

Add these to your `convex/auth.config.ts` file:

```ts title="convex/auth.config.ts"
import { AuthConfig } from "convex/server";

export default {
  providers: [
    {
      domain: "https://your.issuer.url.com",
      applicationID: "your-application-id",
    },
  ],
} satisfies AuthConfig;
```

The `applicationID` property must exactly match the `aud` field of your JWT and
the `domain` property must exactly match the `iss` field of the JWT. Use a tool
like [jwt.io](https://jwt.io/) to view an JWT and confirm these fields match
exactly.

If multiple providers are provided, the first one fulfilling the above criteria
will be used.

If you're not able to obtain tokens with an `aud` field, you'll need to instead
configure a [Custom JWT](/auth/advanced/custom-jwt.mdx). If you're not sure if
your token is an OIDC ID token, check
[the spec](https://openid.net/specs/openid-connect-core-1_0-final.html#rfc.section.2)
for a list of all required fields.

OIDC requires the routes `${domain}/.well-known/jwks.json` and
`${domain}/.well-known/openid-configuration`. `domain` may include a path like
`https://your.issuer.url.com/api/auth`. This isn't common for third party auth
providers but may be useful if you're implementing OIDC on your own server.

## Client-side integration

### Integrating a new identity provider

The [`ConvexProviderWithAuth`](/api/modules/react#convexproviderwithauth)
component provides a convenient abstraction for building an auth integration
similar to the ones Convex provides for [Clerk](/auth/clerk.mdx) and
[Auth0](/auth/auth0.mdx).

In the following example we build an integration with an imaginary "ProviderX",
whose React integration includes `AuthProviderXReactProvider` and
`useProviderXAuth` hook.

First we replace `ConvexProvider` with `AuthProviderXReactProvider` wrapping
`ConvexProviderWithAuth` at the root of our app:

```jsx title="src/index.js"
import { AuthProviderXReactProvider } from "providerX";
import { ConvexProviderWithAuth } from "convex/react";

root.render(
  <StrictMode>
    <AuthProviderXReactProvider>
      <ConvexProviderWithAuth client={convex} useAuth={useAuthFromProviderX}>
        <App />
      </ConvexProviderWithAuth>
    </AuthProviderXReactProvider>
  </StrictMode>,
);
```

All we really need is to implement the `useAuthFromProviderX` hook which gets
passed to the `ConvexProviderWithAuth` component.

This `useAuthFromProviderX` hook provides a translation between the auth
provider API and the [`ConvexReactClient`](/api/classes/react.ConvexReactClient)
API, which is ultimately responsible for making sure that the ID token is passed
down to your Convex backend.

```jsx title="src/ConvexProviderWithProviderX.js"
function useAuthFromProviderX() {
  const { isLoading, isAuthenticated, getToken } = useProviderXAuth();
  const fetchAccessToken = useCallback(
    async ({ forceRefreshToken }) => {
      // Here you can do whatever transformation to get the ID Token
      // or null
      // Make sure to fetch a new token when `forceRefreshToken` is true
      return await getToken({ ignoreCache: forceRefreshToken });
    },
    // If `getToken` isn't correctly memoized
    // remove it from this dependency array
    [getToken],
  );
  return useMemo(
    () => ({
      // Whether the auth provider is in a loading state
      isLoading: isLoading,
      // Whether the auth provider has the user signed in
      isAuthenticated: isAuthenticated ?? false,
      // The async function to fetch the ID token
      fetchAccessToken,
    }),
    [isLoading, isAuthenticated, fetchAccessToken],
  );
}
```

### Using the new provider

If you successfully follow the steps above you can now use the standard Convex
utilities for checking the authentication state: the
[`useConvexAuth()`](/api/modules/react#useconvexauth) hook and the
[`Authenticated`](/api/modules/react#authenticated),
[`Unauthenticated`](/api/modules/react#authenticated) and
[`AuthLoading`](/api/modules/react#authloading) helper components.

### Debugging

See [Debugging Authentication](/auth/debug.mdx).

<StackPosts query="authentication" />



================================================
FILE: npm-packages/docs/docs/auth/advanced/custom-jwt.mdx
================================================
---
title: "Custom JWT Provider"
sidebar_label: "Custom JWT Provider"
sidebar_position: 4
description:
  "Configure Convex to work with custom JWT providers that don't implement full
  OIDC protocol, including setup and client-side integration."
---

**Note: This is an advanced feature!** We recommend sticking with the
[supported third-party authentication providers](/auth.mdx).

A [JWT](https://en.wikipedia.org/wiki/JSON_Web_Token) is a string combining
three base64-encoded JSON objects containing claims about who a user is valid
for a limited period of time like an hour. You can create them with a library
like [jose](https://github.com/panva/jose) after receiving some evidence
(typically a cookie) of a user's identity or get them from a third party
authentication service like [Clerk](https://clerk.com). The information in a JWT
is signed (the Convex deployment can tell the information is really from the
issuer and hasn't been modified) but generally not encrypted (you can read it by
base64-decoding the token or pasting it into [jwt.io](https://jwt.io/).

If the JWTs issued to your users by an authentication service contain the right
fields to implement the OpenID Connect (OIDC) protocol, the easiest way to
configure accepting these JWTs is adding an
[OIDC Provider](/auth/advanced/custom-auth) entry in `convex/auth.config.ts`. If
the authentication service or library you're using to issue JWTs doesn't support
these fields (for example [OpenAuth](https://openauth.js.org/) JWTs missing an
`aud` field because they implement the OAuth 2.0 spec but not OIDC) you'll need
to configure a Custom JWT provider in the `convex/auth.config.ts` file.

Custom JWTs are required only to have header fields `kid`, `alg` and `typ`, and
payload fields `sub`, `iss`, and `exp`. An `iat` field is also expected by
Convex clients to implement token refreshing.

## Server-side integration

Use `type: "customJwt"` to configure a Custom JWT auth provider:

```ts title="convex/auth.config.ts"
import { AuthConfig } from "convex/server";

export default {
  providers: [
    {
      type: "customJwt",
      applicationID: "your-application-id",
      issuer: "https://your.issuer.url.com",
      jwks: "https://your.issuer.url.com/.well-known/jwks.json",
      algorithm: "RS256",
    },
  ],
};
```

- `applicationID`: Convex will verify that JWTs have this value in the `aud`
  claim. See below for important information regarding leaving this field out.
  The applicationID field is not required, but necessary to use with many
  authentication providers for security. Read more below before omitting it.
- `issuer`: The issuer URL of the JWT.
- `jwks`: The URL for fetching the JWKS (JSON Web Key Set) from the auth
  provider. If you'd like to avoid hitting an external service you may use a
  data URI, e.g. `"data:text/plain;charset=utf-8;base64,ey..."`
- `algorithm`: The algorithm used to sign the JWT. Only RS256 and ES256 are
  currently supported. See
  [RFC 7518](https://datatracker.ietf.org/doc/html/rfc7518#section-3.1) for more
  details.

The `issuer` property must exactly match the `iss` field of the JWT used and if
specified the `applicationID` property must exactly match the `aud` field. If
your JWT doesn't match, use a tool like [jwt.io](https://jwt.io/) to view an JWT
and confirm these fields match exactly.

### Warning: omitting `applicationID` is often insecure

Leaving out `applicationID` from an auth configuration means the `aud`
(audience) field of your users' JWTs will not be verified. In many cases this is
insecure because a JWT intended for another service can be used to impersonate
them in your service.

Say a user has accounts with `https://todos.com` and `https://banking.com`, two
services which use the same third-party authentication service,
`accounts.google.com`. A JWT accepted by todos.com could be reused to
authenticate with banking.com by either todos.com or an attacker that obtained
access to that JWT.

The `aud` (audience) field of the JWT prevents this: if the JWT was generated
for a specific audience of `https://todos.com` then banking.com can enforce the
`aud` field and know not to accept it.

If the JWTs issued to your users have an `iss` (issuer) URL like
`https://accounts.google.com` that is not specific to your application, it is
not secure to trust these tokens without an ApplicationID because that JWT could
have been collected by a malicious application.

If the JWTs issued to your users have a more specific `iss` field like
`https://api.3rd-party-auth.com/client_0123...` then it may be secure to use no
`aud` field if you control all the services the issuer url grants then access to
and intend for access to any one of these services to grants access to all of
them.

### Custom claims

In addition to top-level fields like `subject`, `issuer`, and `tokenIdentifier`,
subfields of the nested fields of the JWT will be accessible in the auth data
returned from `const authInfo = await ctx.auth.getUserIdentity()` like
`authInfo["properties.id"]` and `authInfo["properties.favoriteColor"]` for a JWT
structured like this:

```json
{
  "properties": {
    "id": "123",
    "favoriteColor": "red"
  },
  "iss": "http://localhost:3000",
  "sub": "user:8fa2be73c2229e85",
  "exp": 1750968478
}
```

## Client-side integration

Your users' browsers need a way to obtain an initial JWT and to request updated
JWTs, ideally before the previous one expires.

See the instructions for
[Custom OIDC Providers](/auth/advanced/custom-auth#client-side-integration) for
how to do this.



================================================
FILE: npm-packages/docs/docs/auth/authkit/auto-provision.mdx
================================================
---
title: "Automatic AuthKit Configuration"
sidebar_label: "Automatic Config"
sidebar_position: 20
description:
  "Configure WorkOS AuthKit integration with automatic provisioning for Convex
  deployments"
---

Convex can **create** AuthKit environments in a WorkOS account made on your
behalf. By default WorkOS gives you only two environments, but giving each
Convex dev deployment its own AuthKit environment is useful for isolating
development user data and configuration changes between multiple developers or
agents working in parallel.

The Convex CLI will **configure** AuthKit environments, regardless of whether
Convex or you created them, if the `WORKOS_CLIENT_ID` and `WORKOS_API_KEY`
environment variables are present in the build environment or the Convex
deployment. While developing locally, Convex can write environment variables to
`.env.local` to make setting up an AuthKit environment a breeze.

## Getting Started

Choose AuthKit as your authentication option in the create convex tool.

```bash
npm create convex@latest
```

These templates include a `convex.json` which cause an AuthKit environment for
this deployment to be created and configured. With just `npx convex dev` you'll
get a WorkOS environment all hooked up!

### Going to production

In the Convex dashboard settings for your production deployment, create an
AuthKit environment in the WorkOS Authentication integration under settings,
integrations. Copy these credentials to your hosting provider environment
variables (in addition to other setup, like adding a production
`CONVEX_DEPLOY_KEY`, setting the build command, and setting other
framework-specific AuthKit environment variables).

### Preview deployments

In the Convex dashboard settings for any deployment in your project, create a
new project-level AuthKit environment in the WorkOS Authentication integration
under settings, integrations. Copy these credentials to your hosting provider
environment variables (in addition to other setup, like adding a preview
`CONVEX_DEPLOY_KEY`, setting the build command, and setting other
framework-specific AuthKit environment variables).

## How it works

AuthKit provisioning and configuration is triggered by the presence of a
`convex.json` file with an `authKit` section with a property corresponding to
the type of code push: `dev`, `preview`, or `prod`.

If this section is present, an AuthKit environment may be provisioned (dev
only), local environment variables set (dev only), and configured (all code push
types).

### Finding the AuthKit environment

The CLI looks for WorkOS credentials `WORKOS_CLIENT_ID` and `WORKOS_API_KEY` in
the following order:

1. Environment variables in the build environment shell or `.env.local` file
2. Convex deployment environment variables

In remote build environments (e.g. building a project in Vercel, Netlify,
Cloudflare) if these two environment variables are not found, the build will
fail.

During local dev, credentials are next fetched from the Convex Cloud API for a
new or existing AuthKit environment. A link to this deployment in the WorkOS
dashboard can be found in the Convex dashboard under the WorkOS integration.

### Configuring the AuthKit environment

Once credentials are found, the `WORKOS_API_KEY` is used to configure the
environment based on the `configure` section of the relevant `authKit` object.
This sets things like an environment's
[redirect URIs](https://workos.com/docs/sso/redirect-uris),
[allowed CORS origins](https://workos.com/docs/authkit/client-only).

### Setting local environment variables

For dev deployments only, environment variables are written to `.env.local`
based on the `localEnvVars` section of the relevant `authKit` config.

## Project-level vs deployment level AuthKit environments

In hosting providers with remote build pipelines like Vercel, it's difficult to
set environment variables like `WORKOS_API_KEY` at build time in a way that's
available to server-side code like Next.js middleware. This makes it necessary
set the `WORKOS_*` environment variables in advance for preview and production
deployments built on these platforms.

After creating the WorkOS AuthKit environments for production and preview
deployments in the dashboard, copy relevant environment variables like
`WORKOS_CLIENT_ID`, `WORKOS_API_KEY`, `WORKOS_REDIRECT_URI`, and
`WORKOS_COOKIE_PASSWORD` to the preview and production environment variables in
your hosting provider.

Deployment-specific AuthKit environments can be created for any deployment are
difficult set up automatically so shared project-level environments are
generally a better fit.

In the `authKit` section of `convex.json`, `localEnvVars`
`automate setting up dev environments by automatically setting the right environment variables in .env.local and automatically configuring the environment with a `redirectUri`.

Environments for hosting providers in build environments like Vercel (production
and preview deploys) can be configured at build time, but the environment
variables for these build environments must be set manually in the build
settings.

## Recommended Configuration

Here's a common setup for a project where production and preview deploys are
deployed to from Vercel. Check your hosting provider's docs to substitute the
right environment variables, and check the guide for using AuthKit with your
framework of choice to customize this example.

```json title="convex.json"
{
  "authKit": {
    "dev": {
      "configure": {
        "redirectUris": ["http://localhost:3000/callback"],
        "appHomepageUrl": "http://localhost:3000",
        "corsOrigins": ["http://localhost:3000"]
      },
      "localEnvVars": {
        "WORKOS_CLIENT_ID": "${authEnv.WORKOS_CLIENT_ID}",
        "WORKOS_API_KEY": "${authEnv.WORKOS_API_KEY}",
        "NEXT_PUBLIC_WORKOS_REDIRECT_URI": "http://localhost:3000/callback"
      }
    },
    "preview": {
      "configure": {
        "redirectUris": ["https://${buildEnv.VERCEL_BRANCH_URL}/callback"],
        "appHomepageUrl": "https://${buildEnv.VERCEL_PROJECT_PRODUCTION_URL}",
        "corsOrigins": ["https://${buildEnv.VERCEL_BRANCH_URL}"]
      }
    },
    "prod": {
      "environmentType": "production",
      "configure": {
        "redirectUris": [
          "https://${buildEnv.VERCEL_PROJECT_PRODUCTION_URL}/callback"
        ],
        "appHomepageUrl": "https://${buildEnv.VERCEL_PROJECT_PRODUCTION_URL}",
        "corsOrigins": ["https://${buildEnv.VERCEL_PROJECT_PRODUCTION_URL}"]
      }
    }
  }
}
```

Additionally, for local dev in **Next.js** and **TanStack Start**, Convex
automatically generates a `WORKOS_COOKIE_PASSWORD` if it's not already in
`.env.local`.



================================================
FILE: npm-packages/docs/docs/auth/authkit/index.mdx
================================================
---
title: "Convex & WorkOS AuthKit"
sidebar_label: "WorkOS AuthKit"
sidebar_position: 20
description: "Integrate WorkOS AuthKit authentication with Convex"
---

import UnderTheHood from "@site/docs/auth/_under_the_hood.mdx";
import ConfigTS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite-ts/src/_mainAuthKit.tsx";
import ConfigJS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/src/_mainAuthKit.jsx";
import Functions from "!!raw-loader!@site/../private-demos/snippets/convex/workosFunctions.ts";

[WorkOS AuthKit](https://authkit.com) is an authentication solution that enables
sign-in using passwords, social login providers, email one-time codes,
two-factor authentication, and user management capabilities.

You can use your own WorkOS account with AuthKit or
[create a WorkOS account with Convex](/docs/auth/authkit/auto-provision.mdx) to
create and do some configuration of AuthKit environments automatically.

## Get started

The quickest way to get started is with a template:

```bash
npm create convex@latest -- -t react-vite-authkit
cd my-app  # or whatever you name the directory
npm run dev
```

Follow the prompts to create a WorkOS team that will be associated with your
Convex team. After this Convex deployments for projects in this team will be
able to automatically provision and configure their own WorkOS environments.

That's it! After this you and other members of your Convex team can create and
configure development WorkOS environments without visiting
[workos.com](https://workos.com).

See
[AuthKit configuration in convex.json](/docs/auth/authkit/auto-provision.mdx) to
modify the convex.json file in this template for your needs.

### Configuring an existing WorkOS account

To use AuthKit with an existing WorkOS account you'll need to configure the
account and copy credentials into the Convex deployment and your local
`.env.local` file.

<StepByStep>
  <Step title="Sign up for WorkOS">
    Sign up for a free WorkOS account at [workos.com/sign-up](https://signin.workos.com/sign-up).

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-signup.png" alt="Sign up for a WorkOS account" width={200} />
    </p>

  </Step>
  <Step title="Set up AuthKit">
    In the WorkOS Dashboard, navigate to **Authentication** and then to **AuthKit**. From here, click the **Set up
    AuthKit** button to enable AuthKit in your account.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-setup-authkit.png" alt="Set up AuthKit in your account" width={600} />
    </p>

  </Step>

  <Step title="Complete AuthKit setup">
    Press the **Begin setup** button with **Use AuthKit's customizable hosted UI** selected. These options can be filled out
    however you like until you get to step 4, **Add default redirect endpoint URI**.

    The Redirect URI is the endpoint that WorkOS will return an authorization code to after signing in. This should
    match your application's domain and port, with `/callback` as the route. For example, if your application is
    running at `localhost:5173` then the value here should be `http://localhost:5173/callback`.

    Complete the AuthKit setup.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-redirect-uri.png" alt="Set the redirect URI endpoint" width={400} />
    </p>

  </Step>

  <Step title="Copy your Client ID and API Key">
    From the [get started](https://dashboard.workos.com/get-started) page under **Quick start**, find your
    `WORKOS_CLIENT_ID` and copy it.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-client-id.png" alt="Getting your WorkOS Client ID" width={400} />
    </p>

  </Step>
</StepByStep>

## Client configuration

Convex offers a provider that is specifically for integrating with WorkOS
AuthKit called `<ConvexProviderWithAuthKit>`. It works using WorkOS's
[authkit-react](https://github.com/workos/authkit-react) SDK.

Once you've completed the WorkOS setup above, choose your framework below to
continue with the integration.

See the following sections for the WorkOS SDK that you're using:

- [React](#react) - Use this as a starting point if your SDK is not listed
- [Next.js](#nextjs)

### React

**Example:**
[React with Convex and AuthKit](https://github.com/workos/template-convex-react-vite-authkit)

This guide assumes you have
[AuthKit set up](#configuring-an-existing-workos-account) and have a working
React app with Convex. If not follow the
[Convex React Quickstart](/quickstart/react.mdx) first. Then:

<StepByStep>
  <Step title="Set up CORS in the WorkOS Dashboard">

    In your WorkOS Dashboard, go to [_Authentication_ > _Sessions_](https://dashboard.workos.com/environment/authentication/sessions) > _Cross-Origin Resource Sharing (CORS)_ and click on **Manage**. Add your local development domain (e.g., `http://localhost:5173` for Vite) to the list. You'll also need to add your production domain when you deploy. This enables your application to authenticate users through WorkOS AuthKit.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/workos-cors-setup.png" alt="Setting up CORS" width={400} />
    </p>

  </Step>

  <Step title="Set up your environment variables">
    In your `.env.local` file, add your `WORKOS_CLIENT_ID` and `WORKOS_REDIRECT_URI` environment variables. If you're using Vite, you'll need to prefix it with `VITE_`.

    **Note:** These values can be found in your [WorkOS Dashboard](https://dashboard.workos.com/).

    ```env title=".env.local"
    # WorkOS AuthKit Configuration
    VITE_WORKOS_CLIENT_ID=your-workos-client-id-here
    VITE_WORKOS_REDIRECT_URI=http://localhost:5173/callback
    ```

  </Step>
  <Step title="Configure Convex with the WorkOS Client ID">
    In your app's `convex` folder, create a new file <JSDialectFileName name="auth.config.ts" /> with the following code. This is the server-side configuration for validating access tokens.

    ```ts title="convex/auth.config.ts"
    const clientId = process.env.WORKOS_CLIENT_ID;

    const authConfig = {
      providers: [
        {
          type: 'customJwt',
          issuer: `https://api.workos.com/`,
          algorithm: 'RS256',
      jwks: `https://api.workos.com/sso/jwks/${clientId}`,
      applicationID: clientId,
        },
        {
          type: 'customJwt',
          issuer: `https://api.workos.com/user_management/${clientId}`,
          algorithm: 'RS256',
          jwks: `https://api.workos.com/sso/jwks/${clientId}`,
        },
      ],
    };

    export default authConfig;
    ```

  </Step>
  <Step title="Deploy your changes">
    Run `npx convex dev` to automatically sync your configuration to your backend.

    You'll see an error and a link to click to fill in the WORKOS_CLIENT_ID environment variable in your Convex deployment. Follow the link, paste in the WorkOS client ID, save, and you should see the `npx convex dev` command show "Convex functions ready."

    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Install AuthKit">
    In a new terminal window, install the AuthKit React SDK:

    ```sh
    npm install @workos-inc/authkit-react @convex-dev/workos
    ```

  </Step>

  <Step title="Configure ConvexProviderWithAuthKit">
    AuthKit and Convex both have provider components that provide authentication and client context to your app.

    You should already have `<ConvexProvider>` wrapping your app. Replace it with `<ConvexProviderWithAuthKit>`, and pass WorkOS's `useAuth()` hook to it.

    Then, wrap it with `<AuthKitProvider>`. `<AuthKitProvider>` requires `clientId` and `redirectUri` props, which you can set to `VITE_WORKOS_CLIENT_ID` and `VITE_WORKOS_REDIRECT_URI`, respectively.


    <TSAndJSSnippet
      title="src/main.tsx"
      sourceTS={ConfigTS}
      sourceJS={ConfigJS}
      highlightPatterns={["AuthKitProvider", "clientId", "redirectUri", "ConvexProviderWithAuthKit"]}
    />

  </Step>

  <Step title="Show UI based on authentication state">
    You can control which UI is shown when the user is signed in or signed out using Convex's `<Authenticated>`, `<Unauthenticated>` and `<AuthLoading>` helper components.

    It's important to use the [`useConvexAuth()`](/api/modules/react#useconvexauth) hook instead of
    AuthKit's `useAuth()` hook when you need to check whether the user is logged in or
    not. The `useConvexAuth()` hook makes sure that the browser has fetched the auth
    token needed to make authenticated requests to your Convex backend, and that the
    Convex backend has validated it.

    In the following example, the `<Content />` component is a child of `<Authenticated>`, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require authentication.

    ```tsx title="src/App.tsx"
    import { Authenticated, Unauthenticated, useQuery } from 'convex/react';
    import { api } from '../convex/_generated/api';
    import { useAuth } from '@workos-inc/authkit-react';

    export default function App() {
      const { user, signIn, signOut } = useAuth();

      return (
        <div className="p-4"> <div className="flex justify-between items-center mb-4">
            <h1>Convex + AuthKit</h1>
            <button onClick={() => (user ? signOut() : void signIn())}>{user ? 'Sign out' : 'Sign in'}</button>
          </div>
          <Authenticated>
            <Content />
          </Authenticated>
          <Unauthenticated>
            <p>Please sign in to view data</p>
          </Unauthenticated>
        </div>
      );
    }

    function Content() {
      const data = useQuery(api.myFunctions.listNumbers, { count: 10 });

      if (!data) return <p>Loading...</p>;

      return (
        <div>
          <p>Welcome {data.viewer}!</p>
          <p>Numbers: {data.numbers?.join(', ') || 'None'}</p>
        </div>
      );
    }
    ```

  </Step>

  <Step title="Use authentication state in your Convex functions">
    If the client is authenticated, you can access the information
    stored in the JWT via `ctx.auth.getUserIdentity`.

    If the client isn't authenticated, `ctx.auth.getUserIdentity` will return `null`.

    **Make sure that the component calling this query is a child of `<Authenticated>` from
    `convex/react`**. Otherwise, it will throw on page load.

    <TSAndJSSnippet
      title="convex/myFunctions.ts"
      sourceTS={Functions}
      sourceJS={Functions}
    />

  </Step>
</StepByStep>

**Note:** The
[React template repository](https://github.com/workos/template-convex-react-vite-authkit)
includes additional features and functions for a complete working application.
This tutorial covers the core integration steps, but the template provides a
more comprehensive implementation.

### Next.js

**Example:**
[Next.js with Convex and AuthKit](https://github.com/workos/template-convex-nextjs-authkit)

This guide assumes you have
[AuthKit set up](#configuring-an-existing-workos-account) and have a working
Next.js app with Convex. If not follow the
[Convex Next.js Quickstart](/quickstart/nextjs.mdx) first. Then:

<StepByStep>
  <Step title="Set up your environment variables">
    In your `.env.local` file, add the following environment variables:

    ```env title=".env.local"
    # WorkOS AuthKit Configuration
    WORKOS_CLIENT_ID=client_your_client_id_here
    WORKOS_API_KEY=sk_test_your_api_key_here
    WORKOS_COOKIE_PASSWORD=your_secure_password_here_must_be_at_least_32_characters_long
    NEXT_PUBLIC_WORKOS_REDIRECT_URI=http://localhost:3000/callback

    # Convex Configuration (you don't have to fill these out, they're generated by Convex)
    # Deployment used by `npx convex dev`
    CONVEX_DEPLOY_KEY=your_convex_deploy_key_here
    NEXT_PUBLIC_CONVEX_URL=https://your-convex-url.convex.cloud
    ```

  </Step>
  <Step title="Configure Convex with the WorkOS Client ID">
    In your app's `convex` folder, create a new file <JSDialectFileName name="auth.config.ts" /> with the following code. This is the server-side configuration for validating access tokens.

    ```ts title="convex/auth.config.ts"
    const clientId = process.env.WORKOS_CLIENT_ID;

    const authConfig = {
      providers: [
        {
          type: 'customJwt',
          issuer: `https://api.workos.com/`,
          algorithm: 'RS256',
          applicationID: clientId,
          jwks: `https://api.workos.com/sso/jwks/${clientId}`,
        },
        {
          type: 'customJwt',
          issuer: `https://api.workos.com/user_management/${clientId}`,
          algorithm: 'RS256',
          jwks: `https://api.workos.com/sso/jwks/${clientId}`,
        },
      ],
    };

    export default authConfig;
    ```

  </Step>
  <Step title="Deploy your changes">
    Run `npx convex dev` to automatically sync your configuration to your backend.

    You'll see an error and a link to click to fill in the WORKOS_CLIENT_ID environment variable in your Convex deployment. Follow the link, paste in the WorkOS client ID, save, and you should see the `npx convex dev` command show "Convex functions ready."

    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Install AuthKit">
    In a new terminal window, install the AuthKit Next.js SDK:

    ```sh
    npm install @workos-inc/authkit-nextjs @convex-dev/workos
    ```

  </Step>

  <Step title="Add AuthKit middleware">
    AuthKit's `authkitMiddleware()` helper grants you access to user authentication state throughout your app.

    Create a `middleware.ts` file.

    In your `middleware.ts` file, export the `authkitMiddleware()` helper:

    ```tsx {{ filename: 'middleware.ts' }}
    import { authkitMiddleware } from '@workos-inc/authkit-nextjs';

    export default authkitMiddleware({
      middlewareAuth: {
        enabled: true,
        unauthenticatedPaths: ['/', '/sign-in', '/sign-up'],
      },
    });

    export const config = {
      matcher: [
        // Skip Next.js internals and all static files, unless found in search params
        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
        // Always run for API routes
        '/(api|trpc)(.*)',
      ],
    };
    ```

  </Step>

  <Step title="Add authentication routes">
    Create the required authentication routes for WorkOS AuthKit to handle sign-in, sign-up, and callback flows.

    These routes enable the authentication flow by providing endpoints for users to sign in, sign up, and return after authentication.

    **Create the callback route** to handle OAuth callbacks:

    ```tsx title="app/callback/route.ts"
    import { handleAuth } from '@workos-inc/authkit-nextjs';

    export const GET = handleAuth();
    ```

  </Step>

  <Step title="Create the sign-in route">

    ```tsx title="app/sign-in/route.ts"
    import { redirect } from 'next/navigation';
    import { getSignInUrl } from '@workos-inc/authkit-nextjs';

    export async function GET() {
      const authorizationUrl = await getSignInUrl();
      return redirect(authorizationUrl);
    }
    ```

  </Step>

  <Step title="Create the sign-up route">
    To redirect users to WorkOS sign-up:

    ```tsx title="app/sign-up/route.ts"
    import { redirect } from 'next/navigation';
    import { getSignUpUrl } from '@workos-inc/authkit-nextjs';

    export async function GET() {
      const authorizationUrl = await getSignUpUrl();
      return redirect(authorizationUrl);
    }
    ```

  </Step>

  <Step title="Configure ConvexProviderWithAuthKit">
    Your Next.js app needs to connect AuthKit authentication with Convex for real-time data. We'll create a single provider component that handles both.

    **Create the Provider Component**

    This single component handles:

    - WorkOS authentication setup
    - Convex client initialization
    - Token management between WorkOS and Convex
    - Loading states and error handling

    Create `components/ConvexClientProvider.tsx`:

    ```tsx title="components/ConvexClientProvider.tsx"
    'use client';

    import { ReactNode, useCallback, useRef } from 'react';
    import { ConvexReactClient } from 'convex/react';
    import { ConvexProviderWithAuth } from 'convex/react';
    import { AuthKitProvider, useAuth, useAccessToken } from '@workos-inc/authkit-nextjs/components';

    const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

    export function ConvexClientProvider({ children }: { children: ReactNode }) {
      return (
        <AuthKitProvider>
          <ConvexProviderWithAuth client={convex} useAuth={useAuthFromAuthKit}>
            {children}
          </ConvexProviderWithAuth>
        </AuthKitProvider>
      );
    }

    function useAuthFromAuthKit() {
      const { user, loading: isLoading } = useAuth();
      const { accessToken, loading: tokenLoading, error: tokenError } = useAccessToken();
      const loading = (isLoading ?? false) || (tokenLoading ?? false);
      const authenticated = !!user && !!accessToken && !loading;

      const stableAccessToken = useRef<string | null>(null);
      if (accessToken && !tokenError) {
        stableAccessToken.current = accessToken;
      }

      const fetchAccessToken = useCallback(async () => {
        if (stableAccessToken.current && !tokenError) {
          return stableAccessToken.current;
        }
        return null;
      }, [tokenError]);

      return {
        isLoading: loading,
        isAuthenticated: authenticated,
        fetchAccessToken,
      };
    }
    ```

  </Step>

  <Step title="Add to your layout">

    Update `app/layout.tsx` to use the provider:

    ```tsx title="app/layout.tsx"
    import type { Metadata } from 'next';
    import { Geist, Geist_Mono } from 'next/font/google';
    import './globals.css';
    import { ConvexClientProvider } from '@/components/ConvexClientProvider';

    const geistSans = Geist({
      variable: '--font-geist-sans',
      subsets: ['latin'],
    });

    const geistMono = Geist_Mono({
      variable: '--font-geist-mono',
      subsets: ['latin'],
    });

    export const metadata: Metadata = {
      title: 'Create Next App',
      description: 'Generated by create next app',
      icons: {
        icon: '/convex.svg',
      },
    };

    export default function RootLayout({
      children,
    }: Readonly<{
      children: React.ReactNode;
    }>) {
      return (
        <html lang="en">
          <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
            <ConvexClientProvider>{children}</ConvexClientProvider>
          </body>
        </html>
      );
    }
    ```

  </Step>

  <Step title="Show UI based on authentication state">
      You can control which UI is shown when the user is signed in or signed out using Convex's `<Authenticated>`, `<Unauthenticated>` and `<AuthLoading>` helper components. These should be used instead of WorkOS AuthKit's
    `useAuth()` loading states and manual authentication checks.

      It's important to use the [`useConvexAuth()`](/api/modules/react#useconvexauth) hook instead of
      WorkOS AuthKit's `useAuth()` hook when you need to check whether the user is logged in or
      not. The `useConvexAuth()` hook makes sure that the browser has fetched the auth
      token needed to make authenticated requests to your Convex backend, and that the
      Convex backend has validated it.

      In the following example, the `<Content />` component is a child of `<Authenticated>`, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require
    authentication.

      ```tsx title="app/page.tsx"
      "use client";

      import { Authenticated, Unauthenticated, useQuery } from "convex/react";
      import { useAuth } from "@workos-inc/authkit-nextjs/components";
      import { api } from "../convex/_generated/api";
      import Link from "next/link";

      export default function Home() {
        const { user, signOut } = useAuth();

        return (
          <div className="p-4">
            <div className="flex justify-between items-center mb-4">
              <h1>Convex + AuthKit</h1>
              <div className="flex gap-2">
                {user ? (
                  <button onClick={() => signOut()}>Sign out</button>
                ) : (
                  <>
                    <Link href="/sign-in">
                      <button>Sign in</button>
                    </Link>
                    <Link href="/sign-up">
                      <button>Sign up</button>
                    </Link>
                  </>
                )}
              </div>
            </div>
            <Authenticated>
              <Content />
            </Authenticated>
            <Unauthenticated>
              <p>Please sign in to view data</p>
            </Unauthenticated>
          </div>
        );
      }

      function Content() {
        const data = useQuery(api.myFunctions.listNumbers, { count: 10 });

        if (!data) return <p>Loading...</p>;

        return (
          <div>
            <p>Welcome {data.viewer}!</p>
            <p>Numbers: {data.numbers?.join(', ') || 'None'}</p>
          </div>
        );
      }
      ```
    </Step>

  <Step title="Use authentication state in your Convex functions">
    If the client is authenticated, you can access the information
    stored in the JWT via `ctx.auth.getUserIdentity`.

    If the client isn't authenticated, `ctx.auth.getUserIdentity` will return `null`.

    **Make sure that the component calling this query is a child of `<Authenticated>` from
    `convex/react`**. Otherwise, it will throw on page load.

    <TSAndJSSnippet
      title="convex/myFunctions.ts"
      sourceTS={Functions}
      sourceJS={Functions}
    />

  </Step>
</StepByStep>

**Note:** The
[Next.js template repository](https://github.com/workos/template-convex-nextjs-authkit)
includes additional features and functions for a complete working application.
This tutorial covers the core integration steps, but the template provides a
more comprehensive implementation.

## Next steps

### Accessing user information in functions

See [Auth in Functions](/auth/functions-auth.mdx) to learn about how to access
information about the authenticated user in your queries, mutations and actions.

See [Storing Users in the Convex Database](/auth/database-auth.mdx) to learn
about how to store user information in the Convex database.

### Accessing user information client-side

To access the authenticated user's information, use AuthKit's `User` object,
which can be accessed using AuthKit's
[`useAuth()`](https://github.com/workos/authkit-react?tab=readme-ov-file#useauth)
hook. For more information on the `User` object, see the
[WorkOS docs](https://workos.com/docs/reference/user-management/user).

```tsx title="components/Badge.tsx"
export default function Badge() {
  const { user } = useAuth();

  return <span>Logged in as {user.firstName}</span>;
}
```

## Configuring dev and prod instances

To configure a different AuthKit instance between your Convex development and
production deployments, you can use environment variables configured on the
Convex dashboard.

### Configuring the backend

In the WorkOS Dashboard, navigate to the
[**API keys**](https://dashboard.workos.com/api-keys) page. Copy your WorkOS
Client ID. This Client ID is necessary for Convex to validate access tokens from
WorkOS AuthKit. In development, its format will be
`client_01XXXXXXXXXXXXXXXXXXXXXXXX`. In production, it will follow the same
format but represent your production WorkOS application.

Paste your WorkOS Client ID into your `.env` file, set it as the
`WORKOS_CLIENT_ID` environment variable. Note that this environment variable is
used server-side and does not need a `NEXT_PUBLIC_` prefix.

```env title=".env"
WORKOS_CLIENT_ID=client_01XXXXXXXXXXXXXXXXXXXXXXXX
```

Then, update your `convex/auth.config.ts` file to use the environment variable:

```ts title="convex/auth.config.ts"
const clientId = process.env.WORKOS_CLIENT_ID;

export default {
  providers: [
    {
      type: "customJwt",
      issuer: `https://api.workos.com/`,
      algorithm: "RS256",
      applicationID: clientId,
      jwks: `https://api.workos.com/sso/jwks/${clientId}`,
    },
    {
      type: "customJwt",
      issuer: `https://api.workos.com/user_management/${clientId}`,
      algorithm: "RS256",
      jwks: `https://api.workos.com/sso/jwks/${clientId}`,
    },
  ],
};
```

**Development configuration**

In the left sidenav of the Convex [dashboard](https://dashboard.convex.dev),
switch to your development deployment and set the `WORKOS_CLIENT_ID` environment
variable to your development WorkOS Client ID.

Then, to switch your deployment to the new configuration, run `npx convex dev`.

**Production configuration**

In the left sidenav of the Convex [dashboard](https://dashboard.convex.dev),
switch to your production deployment and set the `WORKOS_CLIENT_ID` environment
variable to your production WorkOS Client ID.

Then, to switch your deployment to the new configuration, run
`npx convex deploy`.

### Configuring WorkOS AuthKit's API keys

WorkOS AuthKit's API keys differ depending on whether they are for development
or production. Don't forget to update the environment variables in your `.env`
file as well as your hosting platform, such as Vercel or Netlify.

**Development configuration**

WorkOS API Key for development follows the format `sk_test_...`. WorkOS Client
ID for development follows the format `client_01...`.

```env title=".env.local"
WORKOS_CLIENT_ID="client_01XXXXXXXXXXXXXXXXXXXXXXXX"
WORKOS_API_KEY="sk_test_..."
WORKOS_COOKIE_PASSWORD="your_secure_password_here_must_be_at_least_32_characters_long"
NEXT_PUBLIC_WORKOS_REDIRECT_URI="http://localhost:3000/callback"
```

**Production configuration**

WorkOS API Key for production follows the format `sk_live_...`. WorkOS Client ID
for production follows the format `client_01...`.

```env title=".env"
WORKOS_CLIENT_ID="client_01XXXXXXXXXXXXXXXXXXXXXXXX"
WORKOS_API_KEY="sk_live_..."
WORKOS_COOKIE_PASSWORD="your_secure_password_here_must_be_at_least_32_characters_long"
NEXT_PUBLIC_WORKOS_REDIRECT_URI="https://your-domain.com/callback"
```

### Additional WorkOS AuthKit Configuration

WorkOS AuthKit requires additional configuration:

**Cookie Password**: A secure password used to encrypt session cookies. This
must be at least 32 characters long. You can generate a random one with
`openssl rand -base64 24`.

**Redirect URI**: The URL where users are redirected after authentication. This
must be configured in both your environment variables and your WorkOS Dashboard
application settings.

## Debugging authentication

If a user goes through the WorkOS AuthKit login flow successfully, and after
being redirected back to your page, `useConvexAuth()` returns
`isAuthenticated: false`, it's possible that your backend isn't correctly
configured.

The `convex/auth.config.ts` file contains a list of configured authentication
providers. You must run `npx convex dev` or `npx convex deploy` after adding a
new provider to sync the configuration to your backend.

Common issues with WorkOS AuthKit integration:

1. **Incorrect Client ID**: Ensure the `WORKOS_CLIENT_ID` in your Convex
   environment matches your WorkOS application
2. **Missing Environment Variables**: Verify all required WorkOS environment
   variables are set in both your local environment and Convex dashboard
3. **Redirect URI Mismatch**: Ensure the `NEXT_PUBLIC_WORKOS_REDIRECT_URI`
   matches what's configured in your WorkOS Dashboard
4. **Missing `aud` claim**: WorkOS JWTs may not include the `aud` (audience)
   claim by default, which Convex requires for token validation. Check your
   WorkOS Dashboard JWT configuration to ensure the audience claim is properly
   set to your Client ID

For more thorough debugging steps, see the WorkOS AuthKit documentation or
[Debugging Authentication](/auth/debug.mdx).

## Under the hood

<UnderTheHood
  provider="AuthKit"
  integrationProvider={<code>ConvexProviderWithAuthKit</code>}
  providerProvider={<code>AuthKitProvider</code>}
  configProp={
    <>
      the{" "}
      <a
        href="https://workos.com/docs/user-management/vanilla/nodejs/1-configure-your-project/configure-a-redirect-uri"
        target="_blank"
      >
        <code>redirectUri</code>
      </a>{" "}
      prop
    </>
  }
/>



================================================
FILE: npm-packages/docs/docs/auth/authkit/troubleshooting.md
================================================
---
title: "AuthKit Troubleshooting"
sidebar_label: "Troubleshooting"
sidebar_position: 30
description: "Debugging issues with AuthKit authentication with Convex"
---

## Platform not authorized

```
WorkOSPlatformNotAuthorized: Your WorkOS platform API key is not authorized to
access this team. Please ensure the API key has the correct permissions in the
WorkOS dashboard.
```

This error occurs when your WorkOS platform API key is not authorized to access
the WorkOS team associated with your Convex team.

This typically happens when the WorkOS workspace has had Convex removed.

You can contact WorkOS support to ask to restore this permission, or unlink the
current workspace and create a new one:

```bash
npx convex integration workos disconnect-team
npx convex integration workos provision-team
```

You'll need to use a different email address to create your new WorkOS Workspace
as an email address can only be associated with a single WorkOS workspace.



================================================
FILE: npm-packages/docs/docs/cli/background-agents.mdx
================================================
---
title: "Agent Mode"
slug: "agent-mode"
sidebar_position: 20
sidebar_label: "Agent Mode"
description:
  "Configure anonymous development mode for cloud-based coding agents"
---

When logged in on your own machine, agents like Cursor and Claude Code can run
CLI commands like `npx convex env list` that use your logged-in credentials run
commands against your personal dev environment as if you ran the commands
yourself. This works well when you're collaborating with an agent; just like
when the agent runs `git commit -am "Fix."`, the commit will use your local git
credentials.

But when cloud-based coding agents like Jules, Devin, Codex, or Cursor Cloud
Agents run Convex CLI commands, they can't log in. And if you do log in for
them, the agent will use your default dev deployment to develop, conflicting
with your own changes!

Instead, set `CONVEX_AGENT_MODE=anonymous` in this environment, causing the
agent to use [anonymous development](/docs/cli/local-deployments-for-dev.mdx) to
run a separate Convex backend on the VM where the agent is working.

<BetaAdmonition feature="Convex Agent Mode" verb="is" />

You can set this variable in .env.local or set it in the agent's environment.

```
CONVEX_AGENT_MODE=anonymous npx convex dev
```

In the future `CONVEX_AGENT_MODE` may support other behaviors like allowing
agents to provision their own short-lived cloud deployments.



================================================
FILE: npm-packages/docs/docs/cli/deploy-key-types.mdx
================================================
---
title: "Deploy keys"
slug: "deploy-key-types"
sidebar_position: 30
sidebar_label: "Deploy keys"
description:
  "Use deploy keys for authentication in production build environments"
---

When you can't log in or use the CLI interactively to specify a project or
deployment, for example in a production build environment, the environment
variable `CONVEX_DEPLOY_KEY` can be set to a deploy key to make convex CLI
commands run non-interactively.

Deploy keys identify a deployment, project, or team; confer permission to take
certain actions with those resources; and can change the behavior of the convex
CLI.

### Developing locally does not require a deploy key

Running `npx convex dev` on a new machine offers the choice to log in or run
Convex locally without an account.

Logging in stores a _user token_ at `~/.convex/config.json` which is used
automatically for all CLI use going forward on that machine. This token grants
permission to push code to and read/write data from any deployment this user has
access to.

Using Convex locally without logging in
([anonymous development](/docs/cli/local-deployments-for-dev.mdx#anonymous-development))
creates a deployment locally and records this preference for this project in the
`.env.local` file in the project directory. The _admin key_ for this anonymous
backend is stored in `~/.convex/anonymous-convex-backend-state/` along with its
serialized data.

In either of these cases, there's no reason to set `CONVEX_DEPLOY_KEY`.

### How to set a deploy key

Generally deploys keys are set in a dashboard of the service that needs the key
but in most shells you can set it right before the command, like

```
CONVEX_DEPLOY_KEY='key goes here' npx convex dev
```

or export it before you run the command

```
export CONVEX_DEPLOY_KEY='key goes here'
npx convex dev
```

or add it to your `.env.local` file where it will be found by `npx convex` when
run in that directory.

# Common uses of deploy keys

### Deploying from build pipelines

A _production deploy key_ specifies the production deployment of a project and
grants permissions to deploy code to it.

> `prod:qualified-jaguar-123|eyJ2...0=`

You can deploying code from a build pipeline where you can't log in (e.g.
Vercel, Netlify, Cloudflare build pipelines)

Read more about
[deploying to production](https://docs.convex.dev/production/hosting/).

### Deploying to preview deployments

A _preview deploy key_ looks like this:

> `preview:team-slug:project-slug|eyJ2...0=`

Use a preview deploy key to change the behavior of a normal `npx convex deploy`
command to deploy to a preview branch.

Read more about [preview deployments](/production/hosting/preview-deployments).

### Admin keys

An admin key provides complete control over a deployment.

An admin key might look like

> `bold-hyena-681|01c2...c09c`

Unlike other types of deploy key, an admin key does not require a network
connection to https://convex.dev to be used since it's a irrevocable secret
baked into the deployment when created.

These keys are used to control
[anonymous](/docs/cli/local-deployments-for-dev.mdx#anonymous-development)
Convex deployments locally without logging in, but rarely need to be set
explicitly.

Setting `CONVEX_DEPLOY_KEY` to one will cause the Convex CLI to run against that
deployment instead of offering a choice.

## Rarer types of deploy keys

### Project tokens

A _project token_ grants total control over a project to a convex CLI and
carries with it the permission to create and use development and production
deployments in that project.

> `project:team-slug:project-slug|eyJ2...0=`

Project tokens are obtained when a user grants an permission to use a project to
an organization via an Convex OAuth application. Actions made with the token are
on behalf of the user so if a user loses access to a project the token no longer
grant access to it.

### Development deploy keys

A _dev deploy key_ might be used to provide an agent full access to a single
deployment for development.

> `dev:joyful-jaguar-123|eyJ2...0=`

This can help limit the blast radius when developing with an agent.

To give an agent exclusive access to its own dev deployment, see
[Agent Mode](/docs/cli/background-agents.mdx).



================================================
FILE: npm-packages/docs/docs/cli/local-deployments-for-dev.mdx
================================================
---
title: "Local Deployments for Development"
slug: "local-deployments"
sidebar_position: 10
sidebar_label: "Local Deployments"
description: "Develop with Convex using deployments running locally on your machine"
---

Instead of syncing code to a Convex dev deployment hosted in the cloud, you can
develop against a deployment running on your own computer. You can even use the
Convex dashboard with local deployments!

## Background on deployments in Convex

Each Convex deployment contains its own data, functions, scheduled functions,
etc. A project has one production deployment, up to one cloud deployment for
development per team member, and potentially many transient
[preview deployments](/production/hosting/preview-deployments.mdx).

You can also develop with Convex using a deployment running on your own machine.
Since the deployment is running locally, code sync is faster and means resources
like functions calls and database bandwidth don't count against
[the quotas for your Convex plan](https://www.convex.dev/pricing).

You can use local deployments with an existing Convex project, and view your
deployment in the Convex dashboard under your project. You can also use local
deployments without a Convex account and debug and inspect them with a locally
running version of the Convex dashboard.

## Using local deployments

<BetaAdmonition feature="Local deployments" verb="are" />

While using local deployments, the local Convex backend runs as a subprocess of
the `npx convex dev` command and exits when that command is stopped. This means
a `convex dev` command must be running in order to run other commands like
`npx convex run` against this local deployment or for your frontend to connect
to this deployment.

State for local backends is stored the `~/.convex/` directory.

### Anonymous development

You can use local deployments to develop with Convex without having to create an
account. Whenever you want to create an account to deploy your app to production
or to use more Convex features, you can use `npx convex login` to link your
local deployments with your account.

### Local deployments for an existing project

To use a local deployment for an existing project, run:

```sh
npx convex dev --local --once
```

You'll also always be given the option for a local deployment if you run
`npx convex dev --configure`. Other flows may assume you want a cloud deployment
in some situations, for example when connecting to a project for which you
already have a cloud development deployment.

## Local deployments vs. production

Local deployments are not recommended for production use: they're development
deployments, i.e. logs for function results and full stack traces for error
responses are sent to connected clients.

For running a production application, you can use a production deployment hosted
on the Convex cloud. Learn more about deploying to production
[here](/production.mdx).

Alternatively, you can self-host a production deployment using the
[open source convex-backend repo](https://github.com/get-convex/convex-backend).

### Disabling

To stop using local developments for a project, run the following:

```sh
npx convex disable-local-deployments
```

Remember your cloud dev deployment and each local dev deployment are completely
separate, so contain different data. When switching between deployments you may
wish to [export and re-import](/database/import-export/import-export.mdx) the
data to keep using it.

## Limitations

- **No Public URL** - Cloud deployments have public URL to receive incoming HTTP
  requests from services like Twilio, but local deployments listen for HTTP
  requests on your own computer. Similarly, you can't power websites with Convex
  WebSocket connections unless your users browsers know how to reach your
  computer. Set up a proxy like ngrok or use a cloud deployment for these uses
  cases.

- **Node actions require specific Node.js versions** - Running Node.js actions
  (actions defined in files with `"use node;"`) requires having the same version
  of Node.js as your project is
  [configured for](/production/project-configuration#configuring-the-nodejs-version).
  By default this is Node.js 20 today, though this may change in the future. To
  resolve this you can install and set up [nvm](https://github.com/nvm-sh/nvm)
  and then install the required Node.js version. You don't need to use this
  version for the rest of your project.

- **Node.js actions run directly on your computer** - Like a normal Node.js
  server, code running in Node.js actions has unrestricted filesystem access.
  Queries, mutations, and Convex runtime actions still run in isolated
  environments.

- Logs get cleared out every time a `npx convex dev` command is restarted.

- <a id="safari"></a> **Using the dashboard with Safari**: Safari [blocks
  requests to localhost](https://bugs.webkit.org/show_bug.cgi?id=171934), which
  prevents the dashboard from working with local deployments. We recommend using
  another browser if you’re using local deployments.

- <a id="brave"></a> **Using the dashboard with Brave**: Brave [blocks requests
  to localhost by
  default](https://brave.com/privacy-updates/27-localhost-permission/), which
  prevents the dashboard from working with local deployments. You can use the
  following workaround:
  - Go to `brave://flags/`
  - Enable the `#brave-localhost-access-permission` flag
  - Go back to the Convex dashboard
  - Click on **View Site Information**
    (<img src="/screenshots/brave-site-information.png" alt="View Site Information icon" width={24} style={{ verticalAlign: "middle" }} />)
    in the URL bar, then on **Site settings**
  - Change the setting for **Localhost access** to **Allow**



================================================
FILE: npm-packages/docs/docs/client/android.md
================================================
---
title: "Android Kotlin"
sidebar_label: "Android Kotlin"
sidebar_position: 600
description:
  "Android Kotlin client library for mobile applications using Convex"
---

Convex Android client library enables your Android application to interact with
your Convex backend. It allows your frontend code to:

1. Call
   your [queries](/functions/query-functions.mdx), [mutations](/functions/mutation-functions.mdx) and [actions](/functions/actions.mdx)
2. Authenticate users using [Auth0](/auth/auth0.mdx)

The library is open source and
[available on GitHub](https://github.com/get-convex/convex-mobile/tree/main/android).

Follow the [Android Quickstart](/quickstart/android.mdx) to get started.

## Installation

You'll need to make the following changes to your app's `build.gradle[.kts]`
file.

```kotlin
plugins {
    // ... existing plugins
    kotlin("plugin.serialization") version "1.9.0"
}

dependencies {
    // ... existing dependencies
    implementation("dev.convex:android-convexmobile:0.4.1@aar") {
        isTransitive = true
    }
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
}
```

After that, sync Gradle to pick up those changes. Your app will now have access
to the Convex for Android library as well as Kotlin's JSON serialization which
is used to communicate between your code and the Convex backend.

## Connecting to a backend

The `ConvexClient` is used to establish and maintain a connect between your
application and the Convex backend. First you need to create an instance of the
client by giving it your backend deployment URL:

```kotlin
package com.example.convexapp

import dev.convex.android.ConvexClient

val convex = ConvexClient("https://<your domain here>.convex.cloud")
```

You should create and use one instance of the `ConvexClient` for the lifetime of
your application process. It can be convenient to create a custom Android
[`Application`](https://developer.android.com/reference/android/app/Application)
subclass and initialize it there:

```kotlin
package com.example.convexapp

import android.app.Application
import dev.convex.android.ConvexClient

class MyApplication : Application() {
    lateinit var convex: ConvexClient

    override fun onCreate() {
        super.onCreate()
        convex = ConvexClient("https://<your domain here>.convex.cloud")
    }
}
```

Once you've done that, you can access the client from a Jetpack Compose
`@Composable` function like this:

```kotlin
val convex = (application as MyApplication).convex
```

## Fetching data

Convex for Android gives you access to the Convex
[reactor](https://docs.convex.dev/tutorial/reactor), which enables real-time
_subscriptions_ to query results. You subscribe to queries with the `subscribe`
method on `ConvexClient` which returns a `Flow`. The contents of the `Flow` will
change over time as the underlying data backing the query changes.

All methods on `ConvexClient` suspend, and need to be called from a
`CoroutineScope` or another `suspend` function. A simple way to consume a query
that returns a list of strings from a `@Composable` is to use a combination of
mutable state containing a list and `LaunchedEffect`:

```kotlin
var workouts: List<String> by remember { mutableStateOf(listOf()) }
LaunchedEffect("onLaunch") {
    client.subscribe<List<String>>("workouts:get").collect { result ->
        result.onSuccess { receivedWorkouts ->
            workouts = receivedWorkouts
        }
    }
}
```

Any time the data that powers the backend `"workouts:get"` query changes, a new
`Result<List<String>>` will be emitted into the `Flow` and the `workouts` list
will refresh with the new data. Any UI that uses `workouts` will then rebuild,
giving you a fully reactive UI.

Note: you may prefer to put the subscription logic wrapped a Repository as
described in the
[Android architecture patterns](https://developer.android.com/topic/architecture/data-layer).

### Query arguments

You can pass arguments to `subscribe` and they will be supplied to the
associated backend `query` function. The arguments are typed as
`Map<String, Any?>`. The values in the map must be primitive values or other
maps and lists.

```kotlin
val favoriteColors = mapOf("favoriteColors" to listOf("blue", "red"))
client.subscribe<List<String>>("users:list", args = favoriteColors)
```

Assuming a backend query that accepts a `favoriteColors` argument, the value can
be received and used to perform logic in the query function.

<Admonition type="tip">
Use serializable [Kotlin Data classes](/client/android/data-types.md#custom-data-types)
to automatically convert Convex objects to Kotlin model classes.
</Admonition>

<Admonition type="caution">
* There are important gotchas when
  [sending and receiving numbers](/client/android/data-types.md#numerical-types)
  between Kotlin and Convex.
* `_` is a used to signify private fields in Kotlin. If you want to use a
  `_creationTime` and `_id` Convex fields directly without warnings you'll have
  to
  [convert the field name in Kotlin](/client/android/data-types.md#field-name-conversion).
* Depending on your backend functions, you may need to deal with
  [reserved Kotlin keywords](/client/android/data-types.md#field-name-conversion).
</Admonition>

### Subscription lifetime

The `Flow` returned from `subscribe` will persist as long as something is
waiting to consume results from it. When a `@Composable` or `ViewModel` with a
subscription goes out of scope, the underlying query subscription to Convex will
be canceled.

## Editing data

You can use the `mutation` method on `ConvexClient` to trigger a backend
[mutation](https://docs.convex.dev/functions/mutation-functions).

You'll need to use it in another `suspend` function or a `CoroutineScope`.
Mutations can return a value or not. If you expect a type in the response,
indicate it in the call signature.

Mutations can also receive arguments, just like queries. Here's an example of
returning a type from a mutation with arguments:

```kotlin
val recordsDeleted = convex.mutation<@ConvexNum Int>(
  "messages:cleanup",
  args = mapOf("keepLatest" to 100)
)
```

If an error occurs during a call to `mutation`, it will throw an exception.
Typically you may want to catch
[`ConvexError`](https://docs.convex.dev/functions/error-handling/application-errors)
and `ServerError` and handle them however is appropriate in your application.
See documentation on
[error handling](https://docs.convex.dev/functions/error-handling/) for more
details.

## Calling third-party APIs

You can use the `action` method on `ConvexClient` to trigger a backend
[action](https://docs.convex.dev/functions/actions).

Calls to `action` can accept arguments, return values and throw exceptions just
like calls to `mutation`.

Even though you can call actions from Android, it's not always the right choice.
See the action docs for tips on
[calling actions from clients](https://docs.convex.dev/functions/actions#calling-actions-from-clients).

## Authentication with Auth0

You can use `ConvexClientWithAuth` in place of `ConvexClient` to configure
authentication with [Auth0](https://auth0.com/). You'll need the
`convex-android-auth0` library to do that, as well as an Auth0 account and
application configuration.

See the
[README](https://github.com/get-convex/convex-android-auth0/blob/main/README.md)
in the `convex-android-auth0` repo for more detailed setup instructions, and the
[Workout example app](https://github.com/get-convex/android-convex-workout)
which is configured for Auth0. The overall
[Convex authentication docs](https://docs.convex.dev/auth) are a good resource
as well.

It should also be possible to integrate other similar OpenID Connect
authentication providers. See the
[`AuthProvider`](https://github.com/get-convex/convex-mobile/blob/5babd583631a7ff6d739e1a2ab542039fd532548/android/convexmobile/src/main/java/dev/convex/android/ConvexClient.kt#L291)
interface in the `convex-mobile` repo for more info.

## Production and dev deployments

When you're ready to move toward
[production](https://docs.convex.dev/production) for your app, you can setup
your Android build system to point different builds or flavors of your
application to different Convex deployments. One fairly simple way to do it is
by passing different values (e.g. deployment URL) to different build targets or
flavors.

Here's a simple example that shows using different deployment URLs for release
and debug builds:

```kotlin
// In the android section of build.gradle.kts:
buildTypes {
    release {
        // Snip various other config like ProGuard ...
        resValue("string", "convex_url", "YOUR_PROD.convex.cloud")
    }

    debug {
        resValue("string", "convex_url", "YOUR_DEV.convex.cloud")
    }
}
```

Then you can build your `ConvexClient` using a single resource in code, and it
will get the right value at compile time.

```kotlin
val convex = ConvexClient(context.getString(R.string.convex_url))
```

<Admonition type="tip">
You may not want these urls checked into your repository. One pattern is to 
create a custom `my_app.properties` file that is configured to be ignored in
your `.gitignore` file. You can then read this file in your `build.gradle.kts` 
file. You can see this pattern in use in the
[workout sample app](https://github.com/get-convex/android-convex-workout?tab=readme-ov-file#configuration).
</Admonition>

## Structuring your application

The examples shown in this guide are intended to be brief, and don't provide
guidance on how to structure a whole application.

The official
[Android application architecture](https://developer.android.com/topic/architecture/intro)
docs cover best practices for building applications, and Convex also has a
[sample open source application](https://github.com/get-convex/android-convex-workout/tree/main)
that attempts to demonstrate what a small multi-screen application might look
like.

In general, do the following:

1. Embrace Flows and
   [unidirectional data flow](https://developer.android.com/develop/ui/compose/architecture#udf)
2. Have a clear
   [data layer](https://developer.android.com/topic/architecture/data-layer)
   (use Repository classes with `ConvexClient` as your data source)
3. Hold UI state in a
   [ViewModel](https://developer.android.com/topic/architecture/recommendations#viewmodel)

## Testing

`ConvexClient` is an `open` class so it can be mocked or faked in unit tests. If
you want to use more of the real client, you can pass a fake
`MobileConvexClientInterface` in to the `ConvexClient` constructor. Just be
aware that you'll need to provide JSON in Convex's undocumented
[JSON format](https://github.com/get-convex/convex-mobile/blob/5babd583631a7ff6d739e1a2ab542039fd532548/android/convexmobile/src/main/java/dev/convex/android/jsonhelpers.kt#L47).

You can also use the full `ConvexClient` in Android instrumentation tests. You
can setup a special backend instance for testing or run a local Convex server
and run full integration tests.

## Under the hood

Convex for Android is built on top of the official
[Convex Rust client](https://docs.convex.dev/client/rust). It handles
maintaining a WebSocket connection with the Convex backend and implements the
full Convex protocol.

All method calls on `ConvexClient` are handled via a Tokio async runtime on the
Rust side and are safe to call from the application's main thread.

`ConvexClient` also makes heavy use of
[Kotlin's serialization framework](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md),
and most of the functionality in that framework is available for you to use in
your applications. Internally, `ConvexClient` enables the JSON
[`ignoreUnknownKeys`](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/json.md#ignoring-unknown-keys)
and
[`allowSpecialFloatingPointValues`](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/json.md#allowing-special-floating-point-values)
features.



================================================
FILE: npm-packages/docs/docs/client/javascript.mdx
================================================
---
title: "JavaScript"
sidebar_label: "JavaScript"
sidebar_position: 350
description:
  "JavaScript clients for Node.js and browser applications using Convex"
---

import Http from "!!raw-loader!@site/../private-demos/snippets/src/vanilla.ts";

# Convex JavaScript Clients

Convex applications can be accessed from Node.js or any JavaScript runtime that
implements [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) or
[`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket). The
reactive [Convex Client](/api/classes/browser.ConvexClient) allows web
applications and long-running Node.js servers to subscribe to updates on Convex
queries, while the [Convex HTTP client](/api/classes/browser.ConvexHttpClient)
is typically used for server-side rendering, migrations, administrative scripts,
and serverless functions to run queries at a single point in time.

If you're using React, see the dedicated
[`ConvexReactClient`](/api/classes/browser.ConvexClient) described in
[React](/client/react.mdx).

## Convex Client

The [`ConvexClient`](/api/classes/browser.ConvexClient) provides subscriptions
to queries in Node.js and any JavaScript environment that supports WebSockets.

import VanillaTS from "!!raw-loader!@site/../private-demos/snippets/src/vanilla.ts";
import VanillaJS from "!!raw-loader!@site/../private-demos/snippets/src/vanilla.js";

<TSAndJSSnippet title="script.ts" sourceTS={VanillaTS} sourceJS={VanillaJS} />

The Convex client is open source and available on
[GitHub](https://github.com/get-convex/convex-js).

See the [Script Tag Quickstart](/quickstart/script-tag.mdx) to get started.

## HTTP client

import Example from "!!raw-loader!@site/../private-demos/snippets/nodeExample.ts";

The [`ConvexHttpClient`](/api/classes/browser.ConvexHttpClient) works in the
browser, Node.js, and any JavaScript environment with `fetch`.

See the [Node.js Quickstart](/quickstart/nodejs.mdx).

<TSAndJSSnippet title="script.ts" sourceTS={Example} sourceJS={Example} />

## Using Convex without generated `convex/_generated/api.js`

If the source code for your Convex function isn't located in the same project or
in the same monorepos you can use the untyped `api` object called `anyApi`.

import StringsTS from "!!raw-loader!@site/../private-demos/snippets/src/strings.ts";
import StringsJS from "!!raw-loader!@site/../private-demos/snippets/src/strings.js";

<TSAndJSSnippet title="script.ts" sourceTS={StringsTS} sourceJS={StringsJS} />



================================================
FILE: npm-packages/docs/docs/client/open-api.mdx
================================================
---
title: "OpenAPI & Other Languages"
sidebar_label: "OpenAPI"
sidebar_position: 325
---

import Load from "!!raw-loader!@site/../private-demos/snippets/convex/goClientExample.ts";
import Go from "!!raw-loader!@site/../private-demos/snippets/goExample.txt";

Convex doesn’t have explicit support for many languages including Go, Java, and
C++. However, you can generate [OpenAPI](https://swagger.io/specification/)
specifications from your Convex deployment to create type-safe clients for
languages that aren't currently supported. Under the hood, this uses our
[HTTP API](/http-api). This means that your queries will not be
reactive/real-time.

<BetaAdmonition feature="OAS generation" verb="is" />

## Setup

<StepByStep>
  <Step title="Install the Convex Helpers npm package">
    Install the `convex-helpers` package, which contains a CLI command to generate an Open API specification.

    ```sh
    npm install convex-helpers
    ```

  </Step>
  <Step title="Run a command to generate an OpenAPI specification">
    Running this command will call into your configured Convex deployment and generate an `convex-spec.yaml` file based
    on it. You can see additional flags by passing `--help` to the command.

    ```sh
    npx convex-helpers open-api-spec
    ```

  </Step>
  <Step title="Generate a type-safe client">
    You can use a separate tools to generate a client from the `convex-spec.yaml` file. Some popular options are [OpenAPI Tools](https://github.com/OpenAPITools/openapi-generator) and [Swagger](https://swagger.io/tools/swagger-codegen/).
    ```yaml
    # convex-spec.yaml
    openapi: 3.0.3
    info:
      title: Convex App - OpenAPI 3.0
      version: 0.0.0
      servers:
        - url: "{hostUrl}"
      description: Convex App API
      ...
    ```
  </Step>
</StepByStep>

## Example

Below are code snippets of what this workflow looks like in action. These
snippets include two different files:

- `convex/load.ts` - contains Convex function definitions
- `convex.go` - contains `Go` code that uses a generated, type-safe `HTTP`
  client. This client was generated by installing the
  [OpenAPI Tools](https://github.com/OpenAPITools/openapi-generator) package and
  running the command
  `npx openapi-generator-cli generate -i convex-spec.yaml -g go -o convex_client`

<TSAndJSSnippet title="convex/load.ts" sourceTS={Load} sourceJS={Load} />

<Snippet source={Go} title="convex.go" />

## Limits

- Argument and return value validators are not required, but they will enrich
  the types of your OpenAPI spec. Where validators aren't defined, we default to
  `v.any()` as the validator.
- You cannot call internal functions from outside of your Convex deployment.
- We currently do not support `bigints` or `bytes`.



================================================
FILE: npm-packages/docs/docs/client/python.md
================================================
---
title: "Python"
sidebar_position: 400
description: "Python client library for building applications with Convex"
---

See the [Python Quickstart](/quickstart/python.mdx) and the
<a href="https://pypi.org/project/convex/" target="_blank">convex PyPI package
docs</a>. The Python client is open source and available on
[GitHub](https://github.com/get-convex/convex-py).



================================================
FILE: npm-packages/docs/docs/client/react-native.mdx
================================================
---
title: "Convex React Native"
sidebar_label: "React Native"
slug: "react-native"
sidebar_position: 300
description: "How Convex works in a React Native app"
---

To use Convex in [React Native](https://reactnative.dev/) use the
[Convex React client library](/client/react.mdx).

Follow the [React Native Quickstart](/quickstart/react-native.mdx) for the
different configuration needed specifically for React Native.

You can also clone a working
[Convex React Native demo](https://github.com/get-convex/convex-demos/tree/main/react-native).



================================================
FILE: npm-packages/docs/docs/client/react.mdx
================================================
---
title: "Convex React"
sidebar_label: "React"
sidebar_position: 4
description: "React client library for interacting with your Convex backend"
---

import SkipBad from "!!raw-loader!@site/../private-demos/snippets/src/reactSkipBad.tsx";
import SkipGood from "!!raw-loader!@site/../private-demos/snippets/src/reactSkipGood.tsx";

Convex React is the client library enabling your React application to interact
with your Convex backend. It allows your frontend code to:

1. Call your [queries](/functions/query-functions.mdx),
   [mutations](/functions/mutation-functions.mdx) and
   [actions](/functions/actions.mdx)
2. Upload and display files from [File Storage](/file-storage.mdx)
3. Authenticate users using [Authentication](/auth.mdx)
4. Implement full text [Search](/search.mdx) over your data

The Convex React client is open source and available on
[GitHub](https://github.com/get-convex/convex-js).

Follow the [React Quickstart](/quickstart/react.mdx) to get started with React
using [Vite](https://vitejs.dev/).

## Installation

Convex React is part of the `convex` npm package:

```
npm install convex
```

## Connecting to a backend

The [`ConvexReactClient`](/api/classes/react.ConvexReactClient) maintains a
connection to your Convex backend, and is used by the React hooks described
below to call your functions.

First you need to create an instance of the client by giving it your backend
deployment URL. See [Configuring Deployment URL](/client/react/project-setup.md)
on how to pass in the right value:

```jsx
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient("https://<your domain here>.convex.cloud");
```

And then you make the client available to your app by passing it in to a
[`ConvexProvider`](/api/modules/react#convexprovider) wrapping your component
tree:

```jsx
reactDOMRoot.render(
  <React.StrictMode>
    <ConvexProvider client={convex}>
      <App />
    </ConvexProvider>
  </React.StrictMode>,
);
```

## Fetching data

Your React app fetches data using the [`useQuery`](/api/modules/react#usequery)
React hook by calling your [queries](/functions/query-functions.mdx) via an
[`api`](/generated-api/api.md#api) object.

The `npx convex dev` command generates this api object for you in the
`convex/_generated/api.js` module to provide better autocompletion in JavaScript
and end-to-end type safety in
[TypeScript](/understanding/best-practices/typescript.mdx):

```tsx title="src/App.tsx"
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export function App() {
  const data = useQuery(api.functions.myQuery);
  return data ?? "Loading...";
}
```

The `useQuery` hook returns `undefined` while the data is first loading and
afterwards the return value of your query.

### Query arguments

Arguments to your query follow the query name:

```tsx title="src/App.tsx"
export function App() {
  const a = "Hello world";
  const b = 4;
  const data = useQuery(api.functions.myQuery, { a, b });
  //...
}
```

### Reactivity

The `useQuery` hook makes your app automatically reactive: when the underlying
data changes in your database, your component rerenders with the new query
result.

The first time the hook is used it creates a subscription to your backend for a
given query and any arguments you pass in. When your component unmounts, the
subscription is canceled.

### Consistency

Convex React ensures that your application always renders a consistent view of
the query results based on a single state of the underlying database.

Imagine a mutation changes some data in the database, and that 2 different
`useQuery` call sites rely on this data. Your app will never render in an
inconsistent state where only one of the `useQuery` call sites reflects the new
data.

### Paginating queries

See
[Paginating within React Components](/database/pagination.mdx#paginating-within-react-components).

### Skipping queries

<Details summary="Advanced: Loading a query conditionally">

With React it can be tricky to dynamically invoke a hook, because hooks cannot
be placed inside conditionals or after early returns:

<TSAndJSSnippet
  title="src/App.tsx"
  sourceTS={SkipBad}
  sourceJS={SkipBad}
  snippet="example"
  highlightPatterns={["useQuery"]}
/>

For this reason `useQuery` can be "disabled" by passing in `"skip"` instead of
its arguments:

<TSAndJSSnippet
  title="src/App.tsx"
  sourceTS={SkipGood}
  sourceJS={SkipGood}
  highlightPatterns={["skip"]}
/>

When `"skip"` is used the `useQuery` doesn't talk to your backend at all and
returns `undefined`.

</Details>

### One-off queries

<Details summary="Advanced: Fetching a query from a callback">

Sometimes you might want to read state from the database in response to a user
action, for example to validate given input, without making any changes to the
database. In this case you can use a one-off
[`query`](/api/classes/react.ConvexReactClient#query) call, similarly to calling
mutations and actions.

The async method `query` is exposed on the `ConvexReactClient`, which you can
reference in your components via the
[`useConvex()`](/api/modules/react#useconvex) hook.

```tsx title="src/App.tsx"
import { useConvex } from "convex/react";
import { api } from "../convex/_generated/api";

export function App() {
  const convex = useConvex();
  return (
    <button
      onClick={async () => {
        console.log(await convex.query(api.functions.myQuery));
      }}
    >
      Check
    </button>
  );
}
```

</Details>

## Editing data

Your React app edits data using the
[`useMutation`](/api/modules/react#usemutation) React hook by calling your
[mutations](/functions/mutation-functions.mdx).

The `convex dev` command generates this api object for you in the
`convex/_generated/api.js` module to provide better autocompletion in JavaScript
and end-to-end type safety in
[TypeScript](/understanding/best-practices/typescript.mdx):

```tsx title="src/App.tsx"
import { useMutation } from "convex/react";
import { api } from "../convex/_generated/api";

export function App() {
  const doSomething = useMutation(api.functions.doSomething);
  return <button onClick={() => doSomething()}>Click me</button>;
}
```

The hook returns an `async` function which performs the call to the mutation.

### Mutation arguments

Arguments to your mutation are passed to the `async` function returned from
`useMutation`:

```tsx title="src/App.tsx"
export function App() {
  const a = "Hello world";
  const b = 4;
  const doSomething = useMutation(api.functions.doSomething);
  return <button onClick={() => doSomething({ a, b })}>Click me</button>;
}
```

### Mutation response and error handling

The mutation can optionally return a value or throw errors, which you can
[`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await):

```tsx title="src/App.tsx"
export function App() {
  const doSomething = useMutation(api.functions.doSomething);
  const onClick = () => {
    async function callBackend() {
      try {
        const result = await doSomething();
      } catch (error) {
        console.error(error);
      }
      console.log(result);
    }
    void callBackend();
  };
  return <button onClick={onClick}>Click me</button>;
}
```

Or handle as a
[`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise):

```tsx title="src/App.tsx"
export function App() {
  const doSomething = useMutation(api.functions.doSomething);
  const onClick = () => {
    doSomething()
      .catch((error) => {
        console.error(error);
      })
      .then((result) => {
        console.log(result);
      });
  };
  return <button onClick={onClick}>Click me</button>;
}
```

Learn more about [Error Handling](/functions/error-handling/error-handling.mdx)
in functions.

### Retries

Convex React automatically retries mutations until they are confirmed to have
been written to the database. The Convex backend ensures that despite multiple
retries, every mutation call only executes once.

Additionally, Convex React will warn users if they try to close their browser
tab while there are outstanding mutations. This means that when you call a
Convex mutation, you can be sure that the user's edits won't be lost.

### Optimistic updates

Convex queries are fully reactive, so all query results will be automatically
updated after a mutation. Sometimes you may want to update the UI before the
mutation changes propagate back to the client. To accomplish this, you can
configure an _optimistic update_ to execute as part of your mutation.

Optimistic updates are temporary, local changes to your query results which are
used to make your app more responsive.

See [Optimistic Updates](/client/react/optimistic-updates.mdx) on how to
configure them.

## Calling third-party APIs

Your React app can read data, call third-party services, and write data with a
single backend call using the [`useAction`](/api/modules/react#useaction) React
hook by calling your [actions](/functions/actions.mdx).

Like `useQuery` and `useMutation`, this hook is used with the `api` object
generated for you in the `convex/_generated/api.js` module to provide better
autocompletion in JavaScript and end-to-end type safety in
[TypeScript](/understanding/best-practices/typescript.mdx):

```tsx title="src/App.tsx"
import { useAction } from "convex/react";
import { api } from "../convex/_generated/api";

export function App() {
  const doSomeAction = useAction(api.functions.doSomeAction);
  return <button onClick={() => doSomeAction()}>Click me</button>;
}
```

The hook returns an `async` function which performs the call to the action.

### Action arguments

Action arguments work exactly the same as
[mutation arguments](#mutation-arguments).

### Action response and error handling

Action response and error handling work exactly the same as
[mutation response and error handling](#mutation-response-and-error-handling).

Actions do not support automatic retries or optimistic updates.

## Under the hood

The [`ConvexReactClient`](/api/classes/react.ConvexReactClient) connects to your
Convex deployment by creating a
[`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket). The
WebSocket provides a 2-way communication channel over TCP. This allows Convex to
push new query results reactively to the client without the client needing to
poll for updates.

If the internet connection drops, the client will handle reconnecting and
re-establishing the Convex session automatically.



================================================
FILE: npm-packages/docs/docs/client/rust.md
================================================
---
title: "Rust"
sidebar_position: 500
description: "Rust client library for building applications with Convex"
---

See the [Rust Quickstart](/quickstart/rust.mdx) and
<a href="https://docs.rs/convex/latest/convex/" target="_blank">`convex` on
docs.rs docs</a>. The Rust client is open source and available on
[GitHub](https://github.com/get-convex/convex-rs).



================================================
FILE: npm-packages/docs/docs/client/svelte.md
================================================
---
title: "Svelte"
sidebar_position: 250
description: "Reactive Svelte client library for Convex applications"
---

Convex is a great fit for reactive UI frameworks like Svelte. The
[convex-svelte npm package](https://www.npmjs.com/package/convex-svelte)
enhances the [ConvexClient](/api/classes/browser.ConvexClient) with declarative
subscriptions in Svelte 5.

See the [Svelte Quickstart](/quickstart/svelte.mdx) to get started. The Svelte
client is open source and available on
[GitHub](https://github.com/get-convex/convex-svelte).



================================================
FILE: npm-packages/docs/docs/client/swift.md
================================================
---
title: "iOS & macOS Swift"
sidebar_label: "Swift"
sidebar_position: 700
description: "Swift client library for iOS and macOS applications using Convex"
---

The Convex Swift client library enables your iOS or macOS application to
interact with your Convex backend. It allows your frontend code to:

1. Call
   your [queries](/functions/query-functions.mdx), [mutations](/functions/mutation-functions.mdx) and [actions](/functions/actions.mdx)
2. Authenticate users using [Auth0](/auth/auth0.mdx)

The library is open source
and [available on GitHub](https://github.com/get-convex/convex-swift).

Follow the [Swift Quickstart](/quickstart/swift.mdx) to get started.

## Installation

For an iOS or macOS project in Xcode, you’ll need to perform the following steps
to add a dependency on the `ConvexMobile` library.

1. Click on the top-level app container in the project navigator on the left
2. Click on the app name under the PROJECT heading
3. Click the _Package Dependencies_ tab
4. Click the + button

   ![Screenshot 2024-10-02 at 2.33.43 PM.png](/screenshots/swift_qs_step_2.png)

5. Paste
   [`https://github.com/get-convex/convex-swift`](https://github.com/get-convex/convex-swift)
   into the search box and press Enter
6. When the `convex-swift` package loads, click the Add Package button
7. In the _Package Products_ dialog, select your product name in the _Add to
   Target_ dropdown
8. Click _Add Package_

## Connecting to a backend

The `ConvexClient` is used to establish and maintain a connection between your
application and the Convex backend. First you need to create an instance of the
client by giving it your backend deployment URL:

```swift
import ConvexMobile

let convex = ConvexClient(deploymentUrl: "https://<your domain here>.convex.cloud")
```

You should create and use one instance of the `ConvexClient` for the lifetime of
your application process. You can store the client in a global constant like
shown above. An actual connection to the Convex backend won’t be initiated until
you call a method on the `ConvexClient`. After that it will maintain the
connection and re-establish it if it gets dropped.

## Fetching data

The Swift Convex library gives you access to the Convex sync engine, which
enables real-time *subscriptions* to query results. You subscribe to queries
with the `subscribe` method on `ConvexClient` which returns
a [`Publisher`](https://developer.apple.com/documentation/combine). The data
available via the `Publisher` will change over time as the underlying data
backing the query changes.

You can call methods on the `Publisher` to transform and consume the data it
provides.

A simple way to consume a query that returns a list of strings in a `View` is to
use a combination of a `@State` containing a list and the `.task` modifier with
code that loops over the query results as an `AsyncSequence`:

```swift
struct ColorList: View {
  @State private var colors: [String] = []

  var body: some View {
    List {
      ForEach(colors, id: \.self) { color in
        Text(color)
      }
    }.task {
      let latestColors = convex.subscribe(to: "colors:get", yielding: [String].self)
        .replaceError(with: [])
        .values
      for await colors in latestColors {
        self.colors = colors
      }
    }
  }
}
```

Any time the data that powers the backend `"colors:get"` query changes, a
new array of `String` values will appear in the `AsyncSequence` and the
`View`'s `colors` list gets assigned the new data. The UI will then rebuild
reactively to reflect the changed data.

### Query arguments

You can pass arguments to `subscribe` and they will be supplied to the
associated backend `query` function. The arguments must be a Dictionary keyed
with strings and the values should generally be primitive types, Arrays and
other Dictionaries.

```swift
let publisher = convex.subscribe(to: "colors:get",
                               with:["onlyFavorites": true],
                           yielding:[String].self)
```

Assuming the `colors:get` query accepts an `onlyFavorites` argument, the value
can be received and used to perform logic in the query function.

<Admonition type="tip">
Use [Decodable structs](/client/swift/data-types.md#custom-data-types)
to automatically convert Convex objects to Swift structs.
</Admonition>

<Admonition type="caution">
* There are important gotchas when
  [sending and receiving numbers](/client/swift/data-types.md#numerical-types)
  between Swift and Convex.
* Depending on your backend functions, you may need to deal with
  [reserved Swift keywords](/client/swift/data-types.md#field-name-conversion).
</Admonition>

### Subscription lifetime

The `Publisher` returned from `subscribe` will persist as long as the associated
`View` or `ObservableObject`. When either is no longer part of the UI, the
underlying query subscription to Convex will be canceled.

## Editing Data

You can use the `mutation` method on `ConvexClient` to trigger a
backend [mutation](/functions/mutation-functions.mdx).

`mutation` is an `async` method so you'll need to call it within a `Task`.
Mutations can return a value or not.

Mutations can also receive arguments, just like queries. Here's an example of
calling a mutation with arguments that returns a value:

```swift
let isColorAdded: Bool = try await convex.mutation("colors:put", with: ["color": newColor])
```

### Handling errors

If an error occurs during a call to `mutation`, it will throw. Typically you may
want to
catch [`ConvexError`](/functions/error-handling/application-errors.mdx) and `ServerError` and
handle them however is appropriate in your application.

Here’s a small example of how you might handle an error from `colors:put` if it
threw a `ConvexError` with an error message if a color already existed.

```swift
do {
  try await convex.mutation("colors:put", with: ["color": newColor])
} catch ClientError.ConvexError(let data) {
  errorMessage = try! JSONDecoder().decode(String.self, from: Data(data.utf8))
  colorNotAdded = true
}
```

See documentation on [error handling](/functions/error-handling/) for more
details.

## Calling third-party APIs

You can use the `action` method on `ConvexClient` to trigger a
backend [action](/functions/actions.mdx).

Calls to `action` can accept arguments, return values and throw exceptions just
like calls to `mutation`.

Even though you can call actions from your client code, it's not always the
right choice. See the action docs for tips
on [calling actions from clients](/functions/actions.mdx#calling-actions-from-clients).

## Authentication with Auth0

You can use `ConvexClientWithAuth` in place of `ConvexClient` to configure
authentication with [Auth0](https://auth0.com/). You'll need
the `convex-swift-auth0` library to do that, as well as an Auth0 account and
application configuration.

See
the [README](https://github.com/get-convex/convex-swift-auth0/blob/main/README.md) in
the `convex-swift-auth0` repo for more detailed setup instructions, and
the [Workout example app](https://github.com/get-convex/ios-convex-workout) which
is configured for Auth0. The overall [Convex authentication docs](/auth.mdx) are
a good resource as well.

It should also be possible to integrate other similar OpenID Connect
authentication providers. See
the [`AuthProvider`](https://github.com/get-convex/convex-swift/blob/c47aea414c92db2ccf3a0fa4f9db8caf2029b032/Sources/ConvexMobile/ConvexMobile.swift#L188) protocol
in the `convex-swift` repo for more info.

## Production and dev deployments

When you're ready to move toward [production](/production.mdx) for your app, you
can setup your Xcode build system to point different build targets to different
Convex deployments. Build environment configuration is highly specialized, and
it’s possible that you or your team have different conventions, but this is one
way to approach the problem.

1. Create “Dev” and “Prod” folders in your project sources.
2. Add an `Env.swift` file in each one with contents like:

```swift
let deploymentUrl = "https://$DEV_OR_PROD.convex.cloud"
```

3. Put your dev URL in `Dev/Env.swift` and your prod URL in `Prod/Env.swift`.
   Don’t worry if Xcode complains that `deploymentUrl` is defined multiple
   times.
4. Click on your top-level project in the explorer view on the left.
5. Select your build target from the **TARGETS** list.
6. Change the target’s name so it ends in “dev”.
7. Right/Ctrl-click it and duplicate it, giving it a name that ends in “prod”.
8. With the “dev” target selected, click the **Build Phases** tab.
9. Expand the **Compile Sources** section.
10. Select `Prod/Env.swift` and remove it with the - button.
11. Likewise, open the “prod” target and remove `Dev/Env.swift` from its
    sources.

![Screenshot 2024-10-03 at 1.34.34 PM.png](/screenshots/swift_env_setup.png)

Now you can refer to `deploymentUrl` wherever you create your `ConvexClient` and
depending on the target that you build, it will use your dev or prod URL.

## Structuring your application

The examples shown in this guide are intended to be brief, and don't provide
guidance on how to structure a whole application.

If you want a more robust and layered approach, put your code that interacts
with `ConvexClient`in a class that conforms to `ObservableObject`. Then your
`View` can observe that object as a `@StateObject` and will rebuild whenever it
changes.

For example, if we adapt the `colors:get` example from above to a
`ViewModel: ObservableObject` class, the `View` no longer plays a direct part in
fetching the data - it only knows that the list of `colors` is provided by the
`ViewModel`.

```swift
import SwiftUI

class ViewModel: ObservableObject {
  @Published var colors: [String] = []

  init() {
    convex.subscribe(to: "colors:get")
      .replaceError(with: [])
      .receive(on: DispatchQueue.main)
      .assign(to: &$colors)
  }
}

struct ContentView: View {
  @StateObject var viewModel = ViewModel()

  var body: some View {
    List {
      ForEach(viewModel.colors, id: \.self) { color in
        Text(color)
      }
    }
  }
}
```

Depending on your needs and the scale of your app, it might make sense to give
it even more formal structure as demonstrated in something like
https://github.com/nalexn/clean-architecture-swiftui.

## Under the hood

The Swift Convex library is built on top of the
official [Convex Rust client](/client/rust.md). It handles maintaining a
WebSocket connection with the Convex backend and implements the full Convex
protocol.

All method calls on `ConvexClient` are handled via a Tokio async runtime on the
Rust side and are safe to call from the application's main actor.



================================================
FILE: npm-packages/docs/docs/client/vue.md
================================================
---
title: "Vue"
sidebar_position: 250
description: "Community-maintained Vue integration for Convex applications"
---

[Vue](https://vuejs.org/) is an "approachable, performant and versatile
framework for building web user interfaces."

The community-maintained
[`convex-vue`](https://www.npmjs.com/package/convex-vue) npm package is a Vue.js
integration library for Convex. It also powers [convex-nuxt](./vue/nuxt.md).

See the [Vue Quickstart](/quickstart/vue.mdx) to get started or the
[convex-vue GitHub page](https://github.com/chris-visser/convex-vue) for more
documentation.

<Admonition type="info">

The [`convex-vue` library](https://github.com/chris-visser/convex-vue) is
community-maintained. Thank you to the maintainer
[Chris Visser](https://github.com/chris-visser) for his work on this project!

You're welcome to ask questions about the library on the
[Convex Discord](https://convex.dev/community) but opening a
[convex-vue GitHub](https://github.com/chris-visser/convex-vue) issue is a
better way to request a new feature or report a bug.

</Admonition>



================================================
FILE: npm-packages/docs/docs/client/android/data-types.md
================================================
---
title: "Kotlin and Convex type conversion"
sidebar_label: "Data Types"
hidden: false
sidebar_position: 5
description:
  "Customizing and converting types between the Kotlin app and Convex"
---

## Custom data types

When receiving values from Convex, you aren't limited to primitive values. You
can create custom `@Serializable` classes that will be automatically decoded
from response data.

Consider a Convex query function that returns results like this JavaScript
object:

```jsx
{
	name: "Guardians",
	uniformColors: ["blue", "white", "red"],
	wins: 80n,
	losses: 60n
}
```

That can be represented in Kotlin using:

```kotlin
@Serializable
data class BaseballTeam(
    val name: String,
    val uniformColors: List<String>,
    val wins: @ConvexNum Int,
    val losses: @ConvexNum Int)
```

Then you can pass it as the type argument in your `subscribe` call:

```kotlin
convex.subscribe<Team>("mlb:first_place_team", args = mapOf("division" to "AL Central"))
```

The data from the remote function will be deserialized to your custom class.

## Numerical types

Your Convex backend code is written in JavaScript, which has two relatively
common types for numerical data: `number` and `BigInt`.

`number` is used whenever a value is assigned a literal numeric value, whether
`42` or `3.14`. `BigInt` can be used by adding a trailing `n`, like `42n`.
Despite the two types, is very common to use `number` for holding either integer
or floating point values in JavaScript.

Because of this, Convex takes extra care to encode values so they won't lose
precision. Since technically the `number` type is an IEEE 754 floating point
value, anytime you get a plain `number` from Convex it will be represented as
floating point in Kotlin. You can choose to use `Double` or `Float`, depending
on your needs but be aware that `Float` might lose precision from the original.

It also means that Kotlin's `Long` type (64 bit) can't be safely stored in a
`number` (only 53 bits are available to encode integers) and requires a
`BigInt`.

That's a long lead up to explain that in order to represent numerical values in
responses from Convex, you need to hint to Kotlin that they should use custom
decoding.

You can do this in three ways. Use whichever seems most useful to your project.

1. Annotate the plain Kotlin type (`Int`, `Long`, `Float`, `Double`) with
   `@ConvexNum`
2. Use a provided type alias for those types (`Int32`, `Int64`, `Float32`,
   `Float64`)
3. Include a special annotation at the top of any file that defines
   `@Serializable` classes and just use the plain types with no annotation

   ```kotlin
   @file:UseSerializers(
       Int64ToIntDecoder::class,
       Int64ToLongDecoder::class,
       Float64ToFloatDecoder::class,
       Float64ToDoubleDecoder::class
   )

   package com.example.convexapp

   import kotlinx.serialization.UseSerializers

   // @Serializable classes and things.
   ```

In the example, JavaScript's `BigInt` type is used by adding a trailing `n` to
the `wins` and `losses` values which lets the Kotlin code use `Int`. If instead
the code used regular JavaScript `number` types, on the Kotlin side those would
be received as floating point values and deserialization would fail.

If you have a situation like that where `number` is used but by convention only
contains integer values, you can handle that in your `@Serializable` class.

```kotlin
@Serializable
data class BaseballTeam(
    val name: String,
    val uniformColors: List<String>,
    @SerialName("wins") private val internalWins: Double,
    @SerialName("losses") private val internalLosses: Double) {

    // Expose the JavaScript number values as Ints.
    val wins get() = internalWins.toInt()
    val losses get() = internalLosses.toInt()
}
```

The pattern is to store the `Double` values privately and with different names
that the value from the backend. Then add accessors to provide the `Int` values.

## Field name conversion

This pattern was used above, but it bears describing on its own. Sometimes a
value will be produced on the backend with a key that matches a Kotlin keyword
(`{fun: true}`) or doesn't conform to Kotlin naming conventions (e.g. starts
with an underscore). You can use `@SerialName` to handle those cases.

For example, here's how you can ingest the Convex
[document ID](https://docs.convex.dev/database/document-ids) from a backend
response and convert it to a field name that won't trigger Kotlin lint warnings:

```kotlin
@Serializable
data class ConvexDocument(@SerialName("_id") val id: String)
```



================================================
FILE: npm-packages/docs/docs/client/javascript/bun.mdx
================================================
---
title: "Bun"
hidden: false
sidebar_position: 200
description: "Use Convex clients with the Bun JavaScript runtime"
---

[Bun](https://bun.sh/) can be used to run scripts and servers that use Convex
clients and can even run the Convex CLI.

Convex supports point-in-time queries, mutations and actions (see
[HTTP client](/api/classes/browser.ConvexHttpClient)) and those plus query
subscriptions (see [ConvexClient](/api/classes/browser.ConvexClient)) in Bun.

```js
import { ConvexHttpClient, ConvexClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";

// HTTP client
const httpClient = new ConvexHttpClient(process.env.CONVEX_URL);
httpClient.query(api.messages.list).then((messages) => {
  console.log(messages);
});

// Subscription client
const client = new ConvexClient(process.env.CONVEX_URL);
const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) =>
  console.log(messages),
);
await Bun.sleep(1000);
client.mutate(api.messages.send, {}, { body: "hello!", author: "me" });
await Bun.sleep(1000);
```

## Using Convex with Bun without codegen

You can always use the `anyApi` object or strings if you don't have the Convex
functions and api file handy. An api reference like `api.folder.file.exportName`
becomes `anyApi.folder.file.exportName` or `"folder/file:exportName"`.



================================================
FILE: npm-packages/docs/docs/client/javascript/node.mdx
================================================
---
title: "Node.js"
hidden: false
sidebar_position: 100
description: "Use Convex HTTP and subscription clients in Node.js applications"
---

Convex supports point-in-time queries (see
[HTTP client](/api/classes/browser.ConvexHttpClient)) and query subscriptions
(see [ConvexClient](/api/classes/browser.ConvexClient)) in Node.js.

If your JavaScript code uses import/export syntax, calling Convex functions
works just like in a browser.

```js
import { ConvexHttpClient, ConvexClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";

// HTTP client
const httpClient = new ConvexHttpClient(CONVEX_URL_GOES_HERE);
httpClient.query(api.messages.list).then(console.log);

// Subscription client
const client = new ConvexClient(CONVEX_URL_GOES_HERE);
client.onUpdate(api.messages.list, {}, (messages) => console.log(messages));
```

## TypeScript

Just like bundling for the browser, bundling TypeScript code for Node.js with
webpack, esbuild, rollup, vite, and others usually allow you import from code
that uses import/export syntax with no extra setup.

If you use TypeScript to _compile_ your code (this is rare for web projects but
more common with Node.js), add `"allowJs": true` to `tsconfig.json` compiler
options so that TypeScript will compile the `api.js` file as well.

## TypeScript without a compile step

If you want to run your TypeScript script directly without a compile step,
installing [ts-node-esm](https://www.npmjs.com/package/ts-node) and running your
script with ts-node-esm should work if you use `"type": "module"` in your
`package.json`.

## JavaScript with CommonJS (`require()` syntax)

If you don't use `"type": "module"` in the `package.json` of your project you'll
need to use `require()` syntax and Node.js will not be able to import the
`convex/_generated/api.js` file directly.

In the same directory as your `package.json`, create or edit
[`convex.json`](/production/project-configuration.mdx#convexjson):

```json title=convex.json
{
  "generateCommonJSApi": true
}
```

When the `convex dev` command generates files in `convex/_generated/` a new
`api_cjs.cjs` file will be created which can be imported from CommonJS code.

```js
const { ConvexHttpClient, ConvexClient } = require("convex/browser");
const { api } = require("./convex/_generated/api_cjs.cjs");
const httpClient = new ConvexHttpClient(CONVEX_URL_GOES_HERE);
```

## TypeScript with CommonJS without a compile step

Follow the steps above for CommonJS and use
[`ts-node`](https://www.npmjs.com/package/ts-node) to run you code. Be sure your
`tsconfig.json` is configured for CommonJS output.

## Using Convex with Node.js without codegen

You can always use the `anyApi` object or strings if you don't have the Convex
functions and api file handy. An api reference like `api.folder.file.exportName`
becomes `anyApi.folder.file.exportName` or `"folder/file:exportName"`.



================================================
FILE: npm-packages/docs/docs/client/javascript/script-tag.mdx
================================================
---
title: "Script Tag"
sidebar_position: 100
description:
  "Use Convex directly in HTML with script tags, no build tools required"
---

Sometimes you just want to get your data on a web page: no installing packages,
no build steps, no TypeScript. Subscribing to queries deployed to an existing
Convex deployment from a script tag is simple.

import simpleHtml from "!!raw-loader!@site/../demos/html/simple.html";
import typedHtml from "!!raw-loader!@site/../demos/html/typed-example.html";
import script from "!!raw-loader!@site/../demos/html/script.js";

<Snippet
  source={simpleHtml}
  title="index.html"
  replacements={[[/https?:\/\/localhost:8000/g, "CONVEX_URL_GOES_HERE"]]}
/>

VS Code doesn't support TypeScript autocompletion in HTML files so for types and
better autocompletion you can split your code out into a script file:

<Snippet
  source={typedHtml}
  title="index.html"
  replacements={[[/https?:\/\/localhost:8000/g, "CONVEX_URL_GOES_HERE"]]}
/>
<Snippet
  source={script}
  title="script.js"
  replacements={[[/https?:\/\/localhost:8000/g, "CONVEX_URL_GOES_HERE"]]}
/>

See the [Script Tag Quickstart](/quickstart/script-tag.mdx) for instructions for
setting up a new Convex project.



================================================
FILE: npm-packages/docs/docs/client/nextjs/app-router/index.mdx
================================================
---
title: "Next.js"
sidebar_label: "Next.js App Router"
sidebar_position: 200
description: "How Convex works in a Next.js app"
pagination_next: client/nextjs/app-router/server-rendering
---

import Config from "!!raw-loader!@site/../private-demos/quickstarts/nextjs-app-dir-14/app/_ConvexClientProviderAuth.tsx";

[Next.js](https://nextjs.org/) is a React web development framework. When used
with Convex, Next.js provides:

- File-system based routing
- Fast refresh in development
- Font and image optimization

and more!

This page covers the App Router variant of Next.js. Alternatively see the
[Pages Router](/client/nextjs/pages-router/index.mdx) version of this page.

## Getting started

Follow the [Next.js Quickstart](/quickstart/nextjs.mdx) to add Convex to a new
or existing Next.js project.

## Calling Convex functions from client code

To fetch and edit the data in your database from client code, use hooks of the
[Convex React library](/client/react).

<CardLink
  className="convex-hero-card"
  item={{
    href: "/client/react",
    label: "Convex React library documentation",
  }}
/>

## Server rendering (SSR)

Next.js automatically renders both Client and Server Components on the server
during the initial page load.

To keep your UI
[automatically reactive](/functions/query-functions.mdx#caching--reactivity--consistency)
to changes in your Convex database it needs to use Client Components. The
`ConvexReactClient` will maintain a connection to your deployment and will get
updates as data changes and that must happen on the client.

See the dedicated
[Server Rendering](/client/nextjs/app-router/server-rendering.mdx) page for more
details about preloading data for Client Components, fetching data and
authentication in Server Components, and implementing Route Handlers.

## Adding authentication

### Client-side only

The simplest way to add user authentication to your Next.js app is to follow our
React-based authentication guides for [Clerk](/auth/clerk.mdx) or
[Auth0](/auth/auth0.mdx), inside your `app/ConvexClientProvider.tsx` file. For
example this is what the file would look like for Auth0:

<TSAndJSSnippet
  title="app/ConvexClientProvider.tsx"
  sourceTS={Config}
  sourceJS={Config}
/>

Custom loading and logged out views can be built with the helper
`Authenticated`, `Unauthenticated` and `AuthLoading` components from
`convex/react`, see the
[Convex Next.js demo](https://github.com/get-convex/convex-demos/tree/main/nextjs-pages-router/pages/_app.tsx)
for an example.

If only some routes of your app require login, the same helpers can be used
directly in page components that do require login instead of being shared
between all pages from `app/ConvexClientProvider.tsx`. Share a single
[ConvexReactClient](/api/classes/react.ConvexReactClient) instance between pages
to avoid needing to reconnect to Convex on client-side page navigation.

### Server and client side

To access user information or load Convex data requiring `ctx.auth` from Server
Components, Server Actions, or Route Handlers you need to use the Next.js
specific SDKs provided by Clerk and Auth0.

Additional `.env.local` configuration is needed for these hybrid SDKs.

#### Clerk

For an example of using Convex and with Next.js 15, run

<p>
  <b>
    <CodeWithCopyButton text="npm create convex@latest -- -t nextjs-clerk" />
  </b>
</p>

Otherwise, follow the
[Clerk Next.js quickstart](https://clerk.com/docs/quickstarts/nextjs), a guide
from Clerk that includes steps for adding `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`
and `CLERK_SECRET_KEY` to the .env.local file. In Next.js 15, the
`<ClerkProvider>` component imported from the `@clerk/nextjs` v6 package
functions as both a client and a server context provider so you probably won't
need the `ClerkProvider` from `@clerk/clerk-react`.

#### Auth0

See the
[Auth0 Next.js](https://auth0.com/docs/quickstart/webapp/nextjs/01-login) guide.

#### Other providers

Convex uses JWT identity tokens on the client for live query subscriptions and
running mutations and actions, and on the Next.js backend for running queries,
mutations, and actions in server components and API routes.

Obtain the appropriate OpenID Identity JWT in both locations and you should be
able to use any auth provider. See
[Custom Auth](https://docs.convex.dev/auth/advanced/custom-auth) for more.



================================================
FILE: npm-packages/docs/docs/client/nextjs/app-router/server-rendering.mdx
================================================
---
title: "Next.js Server Rendering"
sidebar_label: "Server Rendering"
sidebar_position: 10
description:
  "Implement server-side rendering with Convex in Next.js App Router using
  preloadQuery, fetchQuery, and server actions for improved performance."
---

import PreloadQuery from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/TasksWrapper.tsx";
import AuthedPreloadQuery from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/AuthedTasksWrapper.tsx";
import UsePreloadedQueryTS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/Tasks.tsx";
import UsePreloadedQueryJS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/TasksJS.jsx";
import FetchQuery from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/StaticTasks.tsx";
import ServerActionTS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/example/page.tsx";
import ServerActionJS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/exampleJS/page.jsx";
import RouteHandlerTS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/api/route.ts";
import RouteHandlerJS from "!!raw-loader!@site/../private-demos/nextjs-app-router-snippets/app/apiJS/route.js";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Next.js automatically renders both Client and Server Components on the server
during the initial page load.

By default Client Components will not wait for Convex data to be loaded, and
your UI will render in a "loading" state. Read on to learn how to preload data
during server rendering and how to interact with the Convex deployment from
Next.js server-side.

**Example:**
[Next.js App Router](https://github.com/get-convex/convex-demos/tree/main/nextjs-app-router)

This pages covers the App Router variant of Next.js.

<BetaAdmonition feature="Next.js Server Rendering support" verb="is" />

## Preloading data for Client Components

If you want to preload data from Convex and leverage Next.js
[server rendering](https://nextjs.org/docs/app/building-your-application/rendering/server-components#server-rendering-strategies),
but still retain reactivity after the initial page load, use
[`preloadQuery`](/api/modules/nextjs#preloadquery) from
[`convex/nextjs`](/api/modules/nextjs).

In a
[Server Component](https://nextjs.org/docs/app/building-your-application/rendering/server-components)
call `preloadQuery`:

<TSAndJSSnippet
  title="app/TasksWrapper.tsx"
  sourceTS={PreloadQuery}
  sourceJS={PreloadQuery}
/>

In a
[Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components)
call [`usePreloadedQuery`](/api/modules/react#usepreloadedquery):

<TSAndJSSnippet
  title="app/TasksWrapper.tsx"
  sourceTS={UsePreloadedQueryTS}
  sourceJS={UsePreloadedQueryJS}
/>

[`preloadQuery`](/api/modules/nextjs#preloadquery) takes three arguments:

1. The query reference
2. Optionally the arguments object passed to the query
3. Optionally a [NextjsOptions](/api/modules/nextjs#nextjsoptions) object

`preloadQuery` uses the
[`cache: 'no-store'` policy](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching)
so any Server Components using it will not be eligible for
[static rendering](https://nextjs.org/docs/app/building-your-application/rendering/server-components#server-rendering-strategies).

### Using the query result

[`preloadQuery`](/api/modules/nextjs#preloadquery) returns an opaque `Preloaded`
payload that should be passed through to `usePreloadedQuery`. If you want to use
the return value of the query, perhaps to decide whether to even render the
Client Component, you can pass the `Preloaded` payload to the
[`preloadedQueryResult`](/api/modules/nextjs#preloadedqueryresult) function.

## Using Convex to render Server Components

If you need Convex data on the server, you can load data from Convex in your
[Server Components](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching),
but it will be non-reactive. To do this, use the
[`fetchQuery`](/api/modules/nextjs#fetchquery) function from `convex/nextjs`:

<TSAndJSSnippet
  title="app/StaticTasks.tsx"
  sourceTS={FetchQuery}
  sourceJS={FetchQuery}
/>

## Server Actions and Route Handlers

Next.js supports building HTTP request handling routes, similar to Convex
[HTTP Actions](/functions/http-actions.mdx). You can use Convex from a
[Server Action](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
or a
[Route Handler](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)
as you would any other database service.

To load and edit Convex data in your Server Action or Route Handler, you can use
the `fetchQuery`, `fetchMutation` and `fetchAction` functions.

Here's an example inline Server Action calling a Convex mutation:

<TSAndJSSnippet
  title="app/example/page.tsx"
  sourceTS={ServerActionTS}
  sourceJS={ServerActionJS}
/>

Here's an example Route Handler calling a Convex mutation:

<TSAndJSSnippet
  title="app/api/route.ts"
  sourceTS={RouteHandlerTS}
  sourceJS={RouteHandlerJS}
/>

## Server-side authentication

To make authenticated requests to Convex during server rendering, pass a JWT
token to [`preloadQuery`](/api/modules/nextjs#preloadquery) or
[`fetchQuery`](/api/modules/nextjs#fetchquery) in the third options argument:

<TSAndJSSnippet
  title="app/TasksWrapper.tsx"
  sourceTS={AuthedPreloadQuery}
  sourceJS={AuthedPreloadQuery}
  snippet="example"
/>

The implementation of `getAuthToken` depends on your authentication provider.

<Tabs>
<TabItem value="clerk" label="Clerk">
```ts title="app/auth.ts"
import { auth } from "@clerk/nextjs/server";

export async function getAuthToken() {
  return (await (await auth()).getToken({ template: "convex" })) ?? undefined;
}
```
</TabItem>
<TabItem value="auth0" label="Auth0">
```ts title="app/auth.ts"
// You'll need v4.3 or later of @auth0/nextjs-auth0
import { getSession } from '@auth0/nextjs-auth0';

export async function getAuthToken() {
  const session = await getSession();
  const idToken = session.tokenSet.idToken;
  return idToken;
}
```
</TabItem>
</Tabs>

## Configuring Convex deployment URL

Convex hooks used by Client Components are configured via the
`ConvexReactClient` constructor, as shown in the
[Next.js Quickstart](/quickstart/nextjs.mdx).

To use `preloadQuery`, `fetchQuery`, `fetchMutation` and `fetchAction` in Server
Components, Server Actions and Route Handlers you must either:

1. have `NEXT_PUBLIC_CONVEX_URL` environment variable set to the Convex
   deployment URL
2. or pass the [`url` option](/api/modules/nextjs#nextjsoptions) in the third
   argument to `preloadQuery`, `fetchQuery`, `fetchMutation` or `fetchAction`

## Consistency

[`preloadQuery`](/api/modules/nextjs#preloadquery) and
[`fetchQuery`](/api/modules/nextjs#fetchquery) use the `ConvexHTTPClient` under
the hood. This client is stateless. This means that two calls to `preloadQuery`
are not guaranteed to return consistent data based on the same database state.
This is similar to more traditional databases, but is different from the
[guaranteed consistency](/client/react.mdx#consistency) provided by the
`ConvexReactClient`.

To prevent rendering an inconsistent UI avoid using multiple `preloadQuery`
calls on the same page.



================================================
FILE: npm-packages/docs/docs/client/nextjs/pages-router/index.mdx
================================================
---
title: "Next.js Pages Router"
sidebar_position: 250
sidebar_label: "Next.js Pages Router"
description:
  "Complete guide to using Convex with Next.js Pages Router including
  client-side authentication, API routes, and server-side rendering."
---

import simpleAuthedAppTSX from "!!raw-loader!@site/../demos/nextjs-pages-router/pages/_simpleAuthedApp.tsx";
import apiTS from "!!raw-loader!@site/../demos/nextjs-pages-router/pages/api/clicks.ts";

This pages covers the Pages Router variant of Next.js. Alternatively see the
[App Router](/client/nextjs/app-router/index.mdx) version of this page.

## Getting started

Follow the
[Next.js Pages Router Quickstart](/client/nextjs/pages-router/quickstart-nextjs-pages-router.mdx)
to add Convex to a new or existing Next.js project.

## Adding client-side authentication

The simplest approach to authentication in Next.js is to keep it client-side.

For example Auth0 describes this approach in
[Next.js Authentication with Auth0 guide](https://auth0.com/blog/ultimate-guide-nextjs-authentication-auth0),
describing it in
"[Next.js Static Site Approach](https://auth0.com/blog/ultimate-guide-nextjs-authentication-auth0/#Next-js-Static-Site-Approach)"
and "Serverless with the user on the frontend".

To require login on every page of your application you can add logic to
`_app.jsx` to conditionally render page content, blocking it until the user is
logged in.

If you're using Auth0, the helper component `ConvexProviderWithAuth0` can be
imported from `convex/react-auth0`.

<Snippet
  title="pages/_app.jsx"
  snippet="simpleAuthedApp"
  source={simpleAuthedAppTSX}
/>

Custom loading and logged out views can be built with the helper
`Authenticated`, `Unauthenticated` and `AuthLoading` components from
`convex/react`, see the
[Convex Next.js demo](https://github.com/get-convex/convex-demos/tree/main/nextjs-pages-router/pages/_app.jsx)
for an example.

If only some routes of your app require login, the same helpers can be used
directly in page components that do require login instead of being shared
between all pages from `pages/_app.jsx`. Share a single
[ConvexReactClient](/api/classes/react.ConvexReactClient) instance between pages
to avoid needing to reconnect to Convex on client-side page navigation.

Read more about authenticating users with Convex in [Authentication](/auth.mdx).

## API routes

Next.js supports building HTTP request handling routes, similar to Convex
[HTTP Actions](/functions/http-actions.mdx). Using Next.js routes might be
helpful if you need to use a dependency not supported by the Convex default
runtime.

To build an [API route](https://nextjs.org/docs/api-routes/introduction) add a
file to the `pages/api` directory.

To load and edit Convex data in your endpoints, use the
[`fetchQuery`](/api/modules/nextjs#fetchquery) function from `convex/nextjs`:

<Snippet title="pages/api/clicks.js" source={apiTS} />

## Server-side rendering

**Consider client-side rendering Convex data when using Next.js.** Data from
Convex is
[fully reactive](/functions/query-functions.mdx#caching--reactivity--consistency)
so Convex needs a connection from your deployment to the browser in order to
push updates as data changes.

You can of course load data from Convex in
[`getStaticProps`](https://nextjs.org/docs/basic-features/data-fetching/get-static-props)
or
[`getServerSideProps`](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props),
but it will be non-reactive. To do this, use the
[`fetchQuery`](/api/modules/nextjs#fetchquery) function to call query functions
just like you would in [API routes](#api-routes).

To make authenticated requests to Convex during server-side rendering, you need
authentication info present server-side. Auth0 describes this approach in
[Serverless with the user on the backend](https://auth0.com/blog/ultimate-guide-nextjs-authentication-auth0/#Serverless-with-the-user-on-the-backend).
When server-side rendering, pass the authentication token as `token` to the
third argument of `fetchQuery`.

To preload data on server side before rendering a reactive query on the client
side use [`preloadQuery`](/api/modules/nextjs#preloadquery). Check out the
[App Router version of these docs](/client/nextjs/app-router/server-rendering.mdx)
for more details.



================================================
FILE: npm-packages/docs/docs/client/nextjs/pages-router/quickstart-nextjs-pages-router.mdx
================================================
---
title: Next.js Pages Quickstart
sidebar_label: Quickstart
hide_table_of_contents: true
slug: "quickstart"
description:
  "Get started with Convex in Next.js Pages Router by building a reactive task
  list app with queries, mutations, and real-time updates."
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/nextjs/sampleData.jsonl";
import tasksJs from "!!raw-loader!@site/../private-demos/quickstarts/nextjs/convex/tasks.js";
import app from "!!raw-loader!@site/../private-demos/quickstarts/nextjs/pages/_app.js";
import index from "!!raw-loader!@site/../private-demos/quickstarts/nextjs/pages/index.js";

Learn how to query data from Convex in a Next.js app using the Pages Router.

Alternatively see the [App Router](/quickstart/nextjs.mdx) version of this
quickstart.

<StepByStep>
  <Step title="Create a React app">
    Create a Next.js app using the `npx create-next-app` command.

    Choose the default option for every prompt (hit Enter).


    ```sh
    npx create-next-app@latest my-app --no-app --js
    ```

  </Step>
  <Step title="Install the Convex client and server library">
    To get started, install the `convex`
    package which provides a convenient interface for working
    with Convex from a React app.

    Navigate to your app and install `convex`.


    ```sh
    cd my-app && npm install convex
    ```

  </Step>
  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file `tasks.js` in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasksJs}
      title="convex/tasks.js"
    />

  </Step>

  <Step title="Connect the app to your backend">
    In `pages/_app.js`, create a `ConvexReactClient` and pass it to a `ConvexProvider`
    wrapping your app.

    <Snippet
      source={app}
      title="pages/_app.js"
      highlightPatterns={[ "Convex", ]}
    />

  </Step>

  <Step title="Display the data in your app">
    In `pages/index.js`, use the `useQuery` hook to fetch from your `api.tasks.get`
    API function.

    <Snippet
      source={index}
      title="pages/index.js"
      highlightPatterns={[ "useQuery", "tasks", "text", "\\)\\)\\}" ]}
    />

  </Step>

  <Step title="Start the app">
    Start the app, open [http://localhost:3000](http://localhost:3000) in a browser,
    and see the list of tasks.

    ```sh
    npm run dev
    ```

  </Step>

</StepByStep>



================================================
FILE: npm-packages/docs/docs/client/react/optimistic-updates.mdx
================================================
---
title: "Optimistic Updates"
slug: "optimistic-updates"
hidden: false
sidebar_position: 90
description: "Make your React app more responsive with optimistic UI updates"
---

import Simple from "!!raw-loader!@site/../private-demos/snippets/src/optimisticUpdatesSimple.tsx";
import ComplexTS from "!!raw-loader!@site/../private-demos/snippets/src/optimisticUpdatesComplex.tsx";
import ComplexJS from "!!raw-loader!@site/../private-demos/snippets/src/optimisticUpdatesComplexJS.jsx";

Even though Convex queries are completely reactive, sometimes you'll want to
update your UI before the mutation changes propagate back to the client. To
accomplish this, you can configure an _optimistic update_ to execute as part of
your mutation.

Optimistic updates are temporary, local changes to your query results which are
used to make your app more responsive. These updates are made by functions
registered on a mutation invocation with the
[`.withOptimisticUpdate`](/api/interfaces/react.ReactMutation#withoptimisticupdate)
configuration option.

Optimistic updates are run when a mutation is initiated, rerun if the local
query results change, and rolled back when a mutation completes.

## Simple example

Here is how an optimistic update could be added to an `increment` mutation in a
simple counter app:

<TSAndJSSnippet
  title="src/IncrementCounter.tsx"
  sourceTS={Simple}
  sourceJS={Simple}
/>

Optimistic updates receive a
[`localStore`](/api/interfaces/browser.OptimisticLocalStore), a view of the
Convex client's internal state, followed by the arguments to the mutation.

This optimistic update updates the `api.counter.get` query to be `increment`
higher if it's loaded.

## Complex example

If we want to add an optimistic update to a multi-channel chat app, that might
look like:

<TSAndJSSnippet
  title="src/MessageSender.tsx"
  sourceTS={ComplexTS}
  sourceJS={ComplexJS}
/>

This optimistic update changes the `api.messages.list` query for the current
channel to include a new message. The newly created message object should match
the structure of the real messages generated by the `api.messages.list` query on
the server.

Because this message includes the client's current time (not the server's), it
will inevitably not match the `api.messages.list` query after the mutation runs.
That's okay! The Convex client will handle rolling back this update after the
mutation completes and the queries are updated. If there are small mistakes in
optimistic updates, the UI will always eventually render the correct values.

Similarly, the update creates a temporary `Id` with
`new Id("messages", crypto.randomUUID())`. This will also be rolled back and
replaced with the true ID once the server assigns it.

Lastly, note that this update creates a new array of messages instead of using
`existingMessages.push(newMessage)`. This is important! Mutating objects inside
of optimistic updates will corrupt the client's internal state and lead to
surprising results. Always create new objects inside of optimistic updates.

## Learning more

To learn more, check out our API documentation:

- [`.withOptimisticUpdate`](/api/interfaces/react.ReactMutation#withoptimisticupdate)
- [`OptimisticUpdate`](/api/modules/browser#optimisticupdate)
- [`OptimisticLocalStore`](/api/interfaces/browser.OptimisticLocalStore)

If you'd like some hands on experience, try adding optimistic updates to the
[tutorial app](https://github.com/get-convex/convex-tutorial)! If you do, you
should notice the app feels snappier — just a little, Convex is pretty fast
already! — but otherwise works the same.

To explore even further, try inserting a mistake into this update! You should
see a flicker as the optimistic update is applied and then rolled back.



================================================
FILE: npm-packages/docs/docs/client/react/project-setup.md
================================================
---
title: "Configuring Deployment URL"
slug: "deployment-urls"
sidebar_label: "Deployment URLs"
hidden: false
sidebar_position: 5
description: "Configuring your project to run with Convex"
---

When [connecting to your backend](/client/react.mdx#connecting-to-a-backend)
it's important to correctly configure the deployment URL.

### Create a Convex project

The first time you run

```sh
npx convex dev
```

in your project directory you will create a new Convex project.

Your new project includes two deployments: _production_ and _development_. The
_development_ deployment's URL will be saved in `.env.local` or `.env` file,
depending on the frontend framework or bundler you're using.

You can find the URLs of all deployments in a project by visiting the
[deployment settings](/dashboard/deployments/settings.md) on your Convex
[dashboard](https://dashboard.convex.dev).

### Configure the client

Construct a Convex React client by passing in the URL of the Convex deployment.
There should generally be a single Convex client in a frontend application.

```jsx title="src/index.js"
import { ConvexProvider, ConvexReactClient } from "convex/react";

const deploymentURL = import.meta.env.VITE_CONVEX_URL;

const convex = new ConvexReactClient(deploymentURL);
```

While this URL can be hardcoded, it's convenient to use an environment variable
to determine which deployment the client should connect to.

Use an environment variable name accessible from your client code according to
the frontend framework or bundler you're using.

### Choosing environment variable names

To avoid unintentionally exposing secret environment variables in frontend code,
many bundlers require environment variables referenced in frontend code to use a
specific prefix.

[Vite](https://vitejs.dev/guide/env-and-mode.html) requires environment
variables used in frontend code start with `VITE_`, so `VITE_CONVEX_URL` is a
good name.

[Create React App](https://create-react-app.dev/docs/adding-custom-environment-variables/)
requires environment variables used in frontend code to begin with `REACT_APP_`,
so the code above uses `REACT_APP_CONVEX_URL`.

[Next.js](https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser)
requires them to begin with `NEXT_PUBLIC_`, so `NEXT_PUBLIC_CONVEX_URL` is a
good name.

Bundlers provide different ways to access these variables too: while
[Vite uses `import.meta.env.VARIABLE_NAME`](https://vitejs.dev/guide/env-and-mode.html),
many other tools like Next.js use the Node.js-like
[`process.env.VARIABLE_NAME`](https://nextjs.org/docs/basic-features/environment-variables)

```jsx
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL);
```

[`.env` files](https://www.npmjs.com/package/dotenv) are a common way to wire up
different environment variable values in development and production
environments. `npx convex dev` will save the deployment URL to the corresponding
`.env` file, while trying to infer which bundler your project uses.

```shell title=".env.local"
NEXT_PUBLIC_CONVEX_URL=https://guiltless-dog-960.convex.cloud

# examples of other environment variables that might be passed to the frontend
NEXT_PUBLIC_SENTRY_DSN=https://123abc@o123.ingest.sentry.io/1234
NEXT_PUBLIC_LAUNCHDARKLY_SDK_CLIENT_SIDE_ID=01234567890abcdef
```

Your backend functions can use
[environment variables](/production/environment-variables.mdx) configured on
your dashboard. They do not source values from `.env` files.



================================================
FILE: npm-packages/docs/docs/client/swift/data-types.md
================================================
---
title: "Swift and Convex type conversion"
sidebar_label: "Data Types"
hidden: false
sidebar_position: 5
description: "Customizing and converting types between the Swift app and Convex"
---

## Custom data types

Convex lets you easily express your data in the backend as TypeScript objects,
and can return those objects from queries, mutations and actions. To handle
objects on the Swift side, create `struct` definitions that conform to the
`Decodable` protocol. Usually that’s fairly trivial to do, as any `struct` with
all `Decodable` members can automatically conform.

Consider a Convex query function that returns results like this JavaScript
object:

```tsx
{
  name: "Guardians",
  uniformColors: ["blue", "white", "red"],
  wins: 80n,
  losses: 60n
}
```

That can be represented in Swift using:

```swift
struct BaseballTeam: Decodable {
  let name: String
  let uniformColors: [String]
  @ConvexInt
  var wins: Int
  @ConvexInt
  var losses: Int
}
```

Then you can pass that type as the yielding argument in your subscribe call:

```swift
convex.subscribe(to: "mlb:first_place_team",
               with: ["division": "AL Central"],
           yielding: BaseballTeam.self)
```

The data from the remote function will be deserialized to your custom struct.
Often your use of the type can be inferred from the calling context, and you can
skip the yielding argument.

## Numerical types

Numeric types like `Int` and `Double` are encoded in a special format to ensure
proper interoperation with your TypeScript backend functions. To safely use them
on the Swift side, ensure that you use one of the following property wrappers.

| Type                           | Wrapper                |
| ------------------------------ | ---------------------- |
| `Float` or `Double`            | `@ConvexFloat`         |
| `Float?` or `Double?`          | `@OptionalConvexFloat` |
| `Int` or `Int32` or `Int64`    | `@ConvexInt`           |
| `Int?` or `Int32?` or `Int64?` | `@OptionalConvexInt`   |

Note that `struct` properties with wrappers must be declared as `var`.

## Field name conversion

If your code receives objects with names that you need to or want to translate
to different names, you can use a `CodingKeys` `enum` to specify a mapping of
remote names to names on your struct. For example, imagine a backend function or
API that returns log entries like the following representing when someone came
in and went out:

```tsx
{name: "Bob", in: "2024-10-03 08:00:00", out: "2024-10-03 11:00:00"}
```

That data can’t decode directly into a `struct` because `in` is a keyword in
Swift. We can use `CodingKeys` to give it an alternate name while still
ingesting the data from the original name.

```swift
struct Log: Decodable {
  let name: String
  let inTime: String
  let outTime: String

  enum CodingKeys: String, CodingKey {
    case name
    case inTime = "in"
    case outTime = "out"
  }
}
```

## Putting it all together

In the custom data type example above, JavaScript's `BigInt` type is used in the
backend data by adding a trailing `n` to the `wins` and `losses` values which
lets the Swift code use `Int`. If instead the code used regular
JavaScript `number` types, on the Swift side those would be received as floating
point values and deserialization to `Int` would fail.

If you have a situation like that where `number` is used but by convention it
only contains integer values, you can handle that in your `struct` by using
field name conversion and custom properties to hide the floating point
representation.

```swift
struct BaseballTeam: Decodable {
  let name: String
  let uniformColors: [String]
  @ConvexFloat
  private var internalWins: Double
  @ConvexFloat
  private var internalLosses: Double

  enum CodingKeys: String, CodingKey {
    case name
    case uniformColors
    case internalWins = "wins"
    case internalLosses = "losses"
  }

  // Expose the Double values as Ints
  var wins: Int { Int(internalWins) }
  var losses: Int { Int(internalLosses) }
}
```

The pattern is to store the `Double` values privately and with different names
than the value from the backend. Then add custom properties to provide
the `Int` values.



================================================
FILE: npm-packages/docs/docs/client/tanstack/tanstack-query/index.mdx
================================================
---
title: "Convex with TanStack Query"
sidebar_label: "TanStack Query"
description:
  "Integrate Convex with TanStack Query for advanced data fetching patterns"
---

import Setup from "!!raw-loader!@site/../demos/react-query/src/main.tsx";
import App from "!!raw-loader!@site/../demos/react-query/src/App.tsx";

[TanStack Query](https://tanstack.com/query/latest) is an excellent, popular
library for managing requests to a server.

The
[`@convex-dev/react-query`](https://www.npmjs.com/package/@convex-dev/react-query)
library provides
[Query Option](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
functions for use with TanStack Query.

Not all features of the standard [Convex React client](/client/react) are
available through the TanStack Query APIs but you can use the two alongside each
other, dropping into the standard Convex React hooks as necessary.

<BetaAdmonition feature="The TanStack Query adapter" verb="is" />

This makes subscribing to a Convex query function using the TanStack Query
`useQuery` hook look like this:

```ts
const { data, isPending, error } = useQuery(convexQuery(api.messages.list, {}));
```

Instead of the typical polling pattern for API endpoints used with TanStack
Query, the code above receives updates for this `api.messages.list` query from
the Convex server reactively. New results for all relevant subscriptions are
pushed to the client where they update at the same time so data is never stale
and there's no need to manually invalidate queries.

<Admonition type="note" title="Support for other frameworks">
  Currently only [React
  Query](https://tanstack.com/query/latest/docs/framework/react/overview) is
  supported via
  [`@convex-dev/react-query`](https://www.npmjs.com/package/@convex-dev/react-query).
  [Let us know](https://convex.dev/community) if you would find support for
  vue-query, svelte-query, solid-query, or angular-query helpful.
</Admonition>

## Setup

To get live updates in TanStack Query create a `ConvexQueryClient` and connect
it to the TanStack Query
[QueryClient](https://tanstack.com/query/latest/docs/reference/QueryClient).
After installing the adapter library with

```
npm i @convex-dev/react-query
```

wire up Convex to TanStack Query like this:

<Snippet
  title="src/main.tsx"
  source={Setup}
  highlightPatterns={["QueryClient", "convexQuery"]}
/>

Note that when your create your React tree you should both:

- wrap your app in the TanStack Query
  [`QueryClientProvider`](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
  so you can use
  [TanStack Query hooks](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
  and
- wrap your app in the [`ConvexProvider`](/api/modules/react#convexprovider) so
  you can also use normal [Convex React](/client/react) hooks

## Queries

A live-updating subscription to a Convex [query](/functions/query-functions.mdx)
is as simple as calling TanStack
[`useQuery`](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
with `convexQuery`:

```ts
import { useQuery } from "@tanstack/react-query";
import { convexQuery } from "@convex-dev/react-query";
import { api } from "../convex/_generated/api";

export function App() {
  const { data, isPending, error } = useQuery(
    convexQuery(api.functions.myQuery, { id: 123 }),
  );
  return isPending ? "Loading..." : data;
}
```

You can spread the object returned by `convexQuery` into an object specifying
additional
[arguments of `useQuery`](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery).

```ts
const { data, isPending, error } = useQuery({
  ...convexQuery(api.functions.myQuery, { id: 123 }),
  initialData: [], // use an empty list if no data is available yet
  gcTime: 10000, // stay subscribed for 10 seconds after this component unmounts
});
```

## Mutations

Your app can call Convex [mutations](/functions/mutation-functions.mdx) by using
the TanStack
[`useMutation`](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
hook, and setting the `mutationFn` property to the result of calling
`useConvexMutation`:

```ts
import { useMutation } from "@tanstack/react-query";
import { useConvexMutation } from "@convex-dev/react-query";
import { api } from "../convex/_generated/api";

export function App() {
  const { mutate, isPending } = useMutation({
    mutationFn: useConvexMutation(api.functions.doSomething),
  });
  return <button onClick={() => mutate({a: "Hello"})}>Click me</button>;
}
```

`useConvexMutation` is just a re-export of the
[`useMutation`](/client/react#editing-data) hook from
[Convex React](/client/react).

## Differences from using `fetch` with TanStack Query

Convex provides stronger guarantees than other methods of fetching data with
React Query, so some options and return value properties are no longer
necessary.

Subscriptions to Convex queries will remain active after the last component
using `useQuery` for a given function unmounts for `gcTime` milliseconds. This
value is 5 minutes by default; if this results in unwanted function activity use
a smaller value.

Data provided by Convex is never stale, so the `isStale` property of the return
value of `useQuery` will always be false. `retry`-related options are ignored,
since Convex provides its own retry mechanism over its WebSocket protocol.
`refetch`-related options are similarly ignored since Convex queries are always
up to date.



================================================
FILE: npm-packages/docs/docs/client/tanstack/tanstack-start/clerk.mdx
================================================
---
title: "TanStack Start with Clerk"
sidebar_label: With Clerk
description:
  "Learn how to integrate Clerk authentication with Convex in TanStack Start
  applications using ID tokens and ConvexProviderWithClerk."
---

import appRouter from "!!raw-loader!@site/../private-demos/tanstack-start-clerk/app/router.tsx";
import appRoutesRoot from "!!raw-loader!@site/../private-demos/tanstack-start-clerk/app/routes/__root.tsx";

Using Clerk with Convex looks like following the
[Clerk TanStack Quickstart](https://clerk.com/docs/quickstarts/tanstack-start)
and adding Convex like the
[Convex TanStack Quickstart](/quickstart/tanstack-start.mdx) shows. Then to make
Clerk identity tokens available everywhere you might make authenticated calls to
Convex in TanStack Start, you'll want to

1. Get an ID token from Clerk in addition to the `getAuth()` call with
   `const token = await auth.getToken({ template: "convex" })`.
2. Set the token in beforeLoad with
   `ctx.context.convexQueryClient.serverHttpClient?.setAuth(token)` so the token
   will be available in loaders.
3. Add `<ConvexProviderWithClerk>` to the root component to keep refreshing
   Clerk tokens while the app is in use.

Making these changes looks like modifying `app/router.tsx` like this:

<Snippet
  source={appRouter}
  title="app/router.tsx"
  highlightPatterns={["context: "]}
/>

and modifying `app/routes/__root.tsx` like this:

<Snippet
  source={appRoutesRoot}
  title="app/routes/__root.tsx"
  highlightPatterns={[
    "getAuth\\(get",
    "getToken",
    "token,",
    "ConvexReactClient",
    "ConvexQueryClient",
    "userId, token",
    "ConvexProviderWithClerk",
    "if \\(token",
    "ctx.context.convexQuery",
  ]}
/>

Now all queries, mutations and action made with
[TanStack Query](/client/tanstack/tanstack-query/index.mdx) will be
authenticated by a Clerk identity token.



================================================
FILE: npm-packages/docs/docs/client/tanstack/tanstack-start/index.mdx
================================================
---
title: "TanStack Start"
sidebar_label: "TanStack Start"
description: "How Convex works with TanStack Start"
---

[TanStack Start](https://tanstack.com/start/latest) is a new React web framework
with best-in-class typesafe routing.

When used with Convex, TanStack Start provides

- Live-updating queries with React Query (the React client for TanStack Query)
- Subscription session resumption, from SSR to live on the client
- Loader-based preloading and prefetching
- Consistent logical query timestamp during SSR
- Opt-in component-local SSR

and more!

This page describes the recommended way to use Convex with TanStack Start, via
React Query. The standard Convex React hooks work also with TanStack Start
without React Query, as do the
[React Query hooks](/client/tanstack/tanstack-query/index.mdx) without TanStack
Start! But using all three is a sweet spot.

<Admonition type="caution" title="TanStack Start is in Beta">
  TanStack Start is a new React framework currently in beta. You can use it
  today but there may be breaking changes made to it before a stable release.
</Admonition>

## Getting started

Follow the [TanStack Start Quickstart](/quickstart/tanstack-start.mdx) to add
Convex to a new TanStack Start project.

## Using Convex with React Query

You can read more about
[React Query hooks](/client/tanstack/tanstack-query/index.mdx), but a few
highlights relevant to TanStack Start.

### Staying subscribed to queries

Convex queries in React Query continue to receive updates after the last
component subscribed to the query unmounts. The default for this behavior is 5
minutes and this value is configured with
[`gcTime`](https://tanstack.com/query/latest/docs/framework/react/guides/caching).

This is useful to know when debugging why a query result is already loaded: for
client side navigations, whether a subscription is already active can depend on
what pages were previously visited in a session.

### Using Convex React hooks

[Convex React](/client/react.mdx) hooks like
[`usePaginatedQuery`](/api/modules/react#usepaginatedquery) can be used
alongside TanStack hooks. These hooks reference the same Convex Client so
there's still just one set of consistent query results in your app when these
are combined.

## Server-side Rendering

Using TanStack Start and Query with Convex makes it particularly easy to
live-update Convex queries on the client while also
[server-rendering](https://tanstack.com/query/v5/docs/framework/react/guides/ssr)
them.
[`useSuspenseQuery()`](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
is the simplest way to do this:

```ts
const { data } = useSuspenseQuery(convexQuery(api.messages.list, {}));
```

### Consistent client views

In the browser all Convex query subscriptions present a consistent,
at-the-same-logical-timestamp view of the database: if one query result reflects
a given mutation transaction, every other query result will too.

Server-side rendering is usually a special case: instead of a stateful WebSocket
session, on the server it's simpler to fetch query results ad-hoc. This can lead
to inconsistencies analogous to one REST endpoint returning results before a
mutation ran and another endpoint returning results after that change.

In TanStack Start, this issue is avoided by sending in a timestamp along with
each query: Convex uses the same timestamp for all queries.

### Loaders

To make client-side navigations faster you can add a
[loader](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#using-loaders-to-ensure-data-is-loaded)
to a route. By default, loaders will run when mousing over a link to that page.

```ts
export const Route = createFileRoute('/posts')({
  loader: async (opts) => {
    await opts.context.queryClient.ensureQueryData(
      convexQuery(api.messages.list, {}),
    );
  };
  component: () => {
    const { data } = useSuspenseQuery(convexQuery(api.messages.list, {}));
    return (
      <div>
	{data.map((message) => (
	  <Message key={message.id} post={message} />
	))}
      </div>
    );
  },
})
```

## Authentication

Client-side authentication in Start works the way
[client-side authentication with Convex](https://docs.convex.dev/auth) generally
works in React because TanStack Start works well as a client-side framework.

To use Clerk auth to make authenticated Convex calls on the server as well see
the [TanStack Start + Clerk guide](/client/tanstack/tanstack-start/clerk.mdx).

Clerk is an official partner of TanStack, see our setup guide.



================================================
FILE: npm-packages/docs/docs/client/vue/nuxt.md
================================================
---
title: "Nuxt"
sidebar_position: 100
---

[Nuxt](https://nuxt.com/) is a powerful web framework powered by Vue.

The community-maintained
[`convex-nuxt` npm package](https://www.npmjs.com/package/convex-nuxt) provides
deep integration of Convex with the Nuxt 3 ecosystem.

It uses [convex-vue](../vue.md) under the hood.

See the [Nuxt Quickstart](/quickstart/nuxt.mdx) to get started or the
[convex-nuxt GitHub page](https://github.com/chris-visser/convex-nuxt) for more
documentation.

<Admonition type="info">

The
[`convex-nuxt` library](https://github.com/chris-visser/convex-nuxt/tree/main)
is community-maintained. Thank you to the maintainer
[Chris Visser](https://github.com/chris-visser) for his work on this project!

You're welcome to ask questions about the library on the
[Convex Discord](https://convex.dev/community) but opening a
[convex-nuxt GitHub](https://github.com/chris-visser/convex-nuxt) issue is a
better way to request a new feature or report a bug.

</Admonition>



================================================
FILE: npm-packages/docs/docs/components/authoring.mdx
================================================
---
title: "Authoring Components"
slug: "authoring"
sidebar_position: 40
description: "Creating new components"
---

Building a Convex Component lets you package up Convex functions, schemas, and
persistent state into a reusable module that you or other developers can drop
into their projects.

They differ from regular libraries in that they have their own database tables,
sub-transactions, and can define functions that run in an isolated environment.

Trying to decide between writing a library or a component? Building it as a
component allows you to:

- Persist data to tables where you control the schema.
- Isolate access to data behind an API boundary.
- Define queries, mutations, and actions that can run asynchronously to manage
  complex workflows.
- Share functionality between apps in a predictable way.

## Anatomy of a component

Practically speaking, a component is defined in a folder containing a
`convex.config.ts`. The component's folder has the same structure as a normal
`convex/` folder:

```
 component/
 ├── _generated/        # Generated code for the component's API and data model.
 ├── convex.config.ts   # Defines the component and its child components.
 ├── schema.ts          # Defines a schema only accessible by the component
 └-- …folders/files.ts  # Queries, mutations, and actions for the component.
```

The component's `convex.config.ts` file configures the component's default name
and child components.

```ts title="component/convex.config.ts"
import { defineComponent } from "convex/server";
// import workpool from "@convex-dev/workpool/convex.config.js";
// import localComponent from "../localComponent/convex.config.js";
const component = defineComponent("myComponent");
// component.use(workpool);
// component.use(localComponent, { name: "customName" });
export default component;
```

Instances of the component are configured when used by the main app or other
components in their `convex.config.ts` files, forming a tree of components, with
the main app at the root.

## Getting started

The source code for components can be a local folder or bundled into an NPM
package.

### Local components

The easiest way to get started is by creating a new folder for your component
and adding a `convex.config.ts` file to it (like the one above). Then import it
in your app's `convex/convex.config.ts` file:

```ts title="convex/convex.config.ts"
import { defineApp } from "convex/server";
import myComponent from "./components/myComponent/convex.config.js";

const app = defineApp();
app.use(myComponent);
export default app;
```

Once installed, `npx convex dev` will generate code in
`./components/myComponent/_generated/` and re-generate it whenever you make
changes to the component's code.

Tip: The recommended pattern for local components is to organize them in a
`convex/components` folder, but they can be stored anywhere in your project.

### Packaged components

Components can be distributed and installed as NPM packages, enabling you to
share solutions to common problems with the broader developer community via the
[Convex Components directory](https://convex.dev/components).

Get started with a new project using the
[component template](https://github.com/get-convex/templates/tree/main/template-component):

```bash
npx create-convex@latest --component
```

Follow the CLI's instructions to get started and keep the component's generated
code up-to-date.
[See below for more information on building and publishing NPM package components.](#building-and-publishing-npm-package-components)

### Hybrid components

Hybrid components define a local component, but use shared library code for some
of the functionality. This allows you to provide a extra flexibility when users
need to override or extend the schema or functions.

An example of a hybrid component is the
[Better Auth Component](https://convex-better-auth.netlify.app/features/local-install).

Note: in general, components should be composed or designed to be extended
explicitly, as hybrid components introduce a lot of complexity for maintaining
and updating the component in backwards-compatible ways.

## Hello world

To try adding a new function, create a file `helloWorld.ts` in your component's
folder (e.g. `src/component/helloWorld.ts` in the template):

```ts title="./path/to/component/hello.ts"
import { v } from "convex/values";
import { query } from "./_generated/server.js";

export const world = query({
  args: {},
  returns: v.string(),
  handler: async () => {
    return "hello world";
  },
});
```

After it deploys, you can run
`npx convex run --component myComponent hello:world`.

You can now also run it from a function in your app:

```ts title="convex/sayHi.ts"
import { components } from "./_generated/api";
import { query } from "./_generated/server";

export default query({
  handler: async (ctx) => {
    return await ctx.runQuery(components.myComponent.hello.world);
  },
});
```

Try it out: `npx convex run sayHi`.

## Key differences from regular Convex development

Developing a component is similar to developing the rest of your Convex backend.
This section is a guide to the key concepts and differences.

### The Component API

When you access a component reference like `components.foo`, you're working with
the `ComponentApi` type which has some key differences from the regular `api`
object:

- **Only public functions are accessible**: Internal functions are not exposed
  to the parent app.
- **Functions become internal references**: The component's "public" queries,
  mutations, and actions are turned into references with "internal" visibility.
  They can be called with `ctx.runQuery`, `ctx.runMutation`, etc. but **not**
  directly accessible from clients via HTTP or WebSockets. See below for
  patterns to re-export functions from the component.
- **IDs become strings**: Any `Id<"tableName">` arguments or return values
  become plain strings in the `ComponentApi`. See next section for details.

Similar to regular Convex functions, you can call both public and internal
functions via `npx convex run` and the Convex dashboard.

### `Id` types and validation

All `Id<"table_name">` types within a component become simple string types
outside of the component (in the `ComponentApi` type).

In addition, you cannot currently have a `v.id("table_name")` validator that
represents a table in another component / app.

Why?

In Convex, a `v.id("table_name")` validator will check that an ID in an
argument, return value, or database document matches the named table's format.
Under the hood, this is currently encoded as a number assigned to each table in
your schema.

Within a component’s implementation, the same applies to the component's tables.
However, a `v.id("users")` within the component is not the same as
`v.id("users")` in another component or in the main app, as each "users" table
can have a different table number representation.

For this reason, all `Id` types in the `ComponentApi` become simple strings.

### Generated code

Each component has its own `_generated` directory in addition to the
`convex/_generated` directory. They are similar, but its contents are specific
to the component and its schema. In general, code outside of the component
should not import from this directory with the exception of
`_generated/component`.

- `component.ts` is only generated for components, and contains the component's
  `ComponentApi` type.
- `server.ts` contains function builders like `query` and `mutation` to define
  your component's API. It's important that you import these when defining your
  component's functions, and not from `convex/_generated/server`. See below for
  more information on function visibility.
- `api.ts` contains the component's `api` and `internal` objects to reference
  the component's functions. It also includes the `components` object with
  references to its child components, if any. In general, no code outside of the
  component should import from this file. Instead, they should use their own
  `components` object which includes this component keyed by whatever name they
  chose to install it with.
- `dataModel.ts` contains the types for the component's data model. Note that
  the `Id` and `Doc` types here are not useful outside of the component, since
  the API turns all ID types into strings at the boundary.

### Environment variables

The component's functions are isolated from the app's environment variables, so
they cannot access `process.env`. Instead, you can pass environment variables as
arguments to the component's functions.

```ts
return await ctx.runAction(components.sampleComponent.lib.translate, {
  baseUrl: process.env.BASE_URL,
  ...otherArgs,
});
```

See below for other strategies for static configuration.

### HTTP Actions

A component cannot expose HTTP actions itself because the routes could conflict
with the main app's routes. Similar to other functions (queries, mutations, and
actions), a component can define HTTP action handlers which the app can choose
to mount. There’s an example in the
[Twilio component](https://github.com/get-convex/twilio/blob/0bdf7fd4ee7dd46d442be3693280564eea597b68/src/client/index.ts#L71).
All HTTP actions need to be mounted in the main app’s `convex/http.ts` file.

### Authentication via ctx.auth

Within a component, `ctx.auth` is not available. You typically will do
authentication in the app, then pass around identifiers like `userId` or other
identifying information to the component.

This explicit passing makes it clear what data flows between the app and
component, making your component easier to understand and test.

```ts title="convex/myFunctions.ts"
import { getAuthUserId } from "@convex-dev/auth/server";

export const someMutation = mutation({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    await ctx.runMutation(components.myComponent.foo.bar, {
      userId,
      ...otherArgs,
    });
  },
});
```

### Function Handles

Sometimes you want the app to call a component and the component should call
back into the app.

For example, when using the Migrations component, the app defines a function
that modifies a document, and the component runs this function on every
document. As another example, an app using the Twilio component gives it a
function to run whenever the phone number receives a text message.

These features are implemented using function handles.

A function reference is something like api.foo.bar or `internal.foo.bar` or
`components.counter.foo.bar`. Function references are restricted as described
above (a component can only use references to its own functions or the public
functions of its children). If you have a valid function reference, you can turn
it into something that can be called from anywhere:

```ts
const handle = await createFunctionHandle(api.foo.bar);
```

This handle is a string.

Since it’s a string, you can pass it between functions and even store it in a
table. You would use `v.string()` in args/schema validators.

When you want to use it, cast it back to FunctionHandle and use it as you would
use a function reference. Note argument and return value validation still run at
runtime, so don't worry about losing guarantees.

```ts
const handle = handleString as FunctionHandle<"mutation">;

const result = await ctx.runMutation(handle, args);
// or run it asynchronously via the scheduler:
await ctx.scheduler.runAfter(0, handle, args);
```

[Here](https://github.com/get-convex/workpool/blob/aebe2db49fc3ec50ded6892ed27f464450b3d31e/src/component/worker.ts#L26-L28)
is an example of using function handles in the
[Workpool](https://www.convex.dev/components/workpool) component.

### Pagination

The built-in `.paginate()` doesn't work in components, because of how Convex
keeps track of reactive pagination. Therefore we recommend you use `paginator`
from [`convex-helpers`](https://npmjs.com/package/convex-helpers) if you need
pagination within your component.

If you expose a pagination API that wants to be used with `usePaginatedQuery`,
in a React context, use the `usePaginatedQuery` from `convex-helpers` instead of
the default one from `convex/react`. It will have a fixed first page size until
you hit “load more,” at which point the first page will grow if anything before
the second page is added.

[Here](https://github.com/get-convex/rag/blob/23fb22d593682e23d9134304e823f7532cbc7e67/src/component/chunks.ts#L437-L462)
is an example of pagination in the [RAG](https://www.convex.dev/components/rag)
component.

## Tips and best practices

### Validation

All public component functions should have argument and return validators.
Otherwise, the argument and return values will be typed as `any`. Below is an
example of using validators.

```ts
import schema from "./schema";

const messageDoc = schema.tables.messages.validator.extend({
  _id: v.id("messages),
  _creationTime: v.number(),
});

export const getLatestMessage = query({
  args: {},
  returns: v.nullable(messageDoc),
  handler: async (ctx) => {
    return await ctx.db.query("messages").order("desc).first();
  },
});
```

Find out more information about function validation
[here](/functions/validation.mdx).

### Static configuration

A common pattern to track configuration in a component is to have a "globals"
table with a single document that contains the configuration. You can then
define functions to update this document from the CLI or from the app. To read
the values, you can query them with `ctx.db.query("globals").first();`.

## Wrapping the component with client code

When building a component, sometimes you want to provide a simpler API than
directly calling `ctx.runMutation(components.foo.bar, ...)`, add more type
safety, or provide functionality that spans the component's boundary.

You can hide calls to the component's functions behind a more ergonomic client
API that runs within the app's environment and calls into the component.

This section covers conventions and approaches to writing client code. These
aren't hard and fast rules; choose the pattern that best fits your component's
needs.

Note: An important aspect of this pattern is that the code running in the app
has access to `ctx.auth`, `process.env`, and other app-level resources. For many
use-cases, this is important, such as running code to define migrations in the
app, which are then run from the Migrations Component. On the other hand, apps
that want really tight control over what code runs in their app may prefer to
call the component's functions directly.

### Simple Function Wrappers

The simplest approach is to define standalone functions that wrap calls to the
component. This works well for straightforward operations and utilities.

```tsx
import type {
  GenericActionCtx,
  GenericDataModel,
  GenericMutationCtx,
} from "convex/server";
import type { ComponentApi } from "../component/_generated/component.js";

export async function callMyFunction(
  ctx: MutationCtx | ActionCtx,
  component: ComponentApi,
  args: ...
) {
  // You can create function handles, add shared utilities,
  // or do any processing that needs to run in the app's environment.
  const functionHandle = await createFunctionHandle(args.someFn);
  const someArg = process.env.SOME_ARG;
  await ctx.runMutation(component.call.fn, {
    ...args,
    someArg,
    functionHandle,
  });
}

// Useful types for functions that only need certain capabilities.
type MutationCtx = Pick<GenericMutationCtx<GenericDataModel>, "runMutation">;
type ActionCtx = Pick<
  GenericActionCtx<GenericDataModel>,
  "runQuery" | "runMutation" | "runAction"
>;
```

Note: we only use `ctx.runMutation`, so we can use `Pick` to select a type that
only includes that function. This allows users to call it even if their `ctx` is
not exactly the standard MutationCtx. It also means it can be called from an
Action, as ActionCtx also includes `ctx.runMutation`. If your function also
needs auth or storage, you can adjust what you `Pick`.

### Re-exporting component functions

Sometimes you want to provide ready-made functions that apps can directly
re-export to their public API. This is useful when you want to give apps the
ability to expose your component's functionality to React clients or the public
internet.

The most straightforward way to do this is have the user define their own
functions that call into the component.

This allows the app to choose to add auth, rate limiting, etc.

```ts title="convex/counter.ts"
export const add = mutation({
  args: { value: v.number() },
  returns: v.null(),
  handler: async (ctx, args) => {
    // The app can authenticate the user here if needed
    await ctx.runMutation(components.counter.add, args);
  },
});
```

This is the recommended pattern, as it makes it clear to the user how the
request is being authenticated. However, if you need to re-export a lot of
functions, you can use the next pattern.

#### Re-mounting an API

Code in your `src/client/index.ts` can export these functions:

```tsx
import type { Auth } from "convex/server";

// In your component's src/client/index.ts
export function makeCounterAPI(
  component: ComponentApi,
  options: {
    // Important: provide a way for the user to authenticate these requests
    auth: (ctx: { auth: Auth }, operation: "read" | "write") => Promise<string>;
  },
) {
  return {
    add: mutation({
      args: { value: v.number() },
      handler: async (ctx, args) => {
        await options.auth(ctx, "write");
        return await ctx.runMutation(component.public.add, args);
      },
    }),

    get: query({
      args: {},
      handler: async (ctx) => {
        await options.auth(ctx, "read");
        return await ctx.runQuery(component.public.get, {});
      },
    }),
  };
}
```

Then apps can mount these in their own API:

```tsx
// In the app's convex/counter.ts
import { makeCounterAPI } from "@convex-dev/counter";
import { components } from "./_generated/server.js";

export const { add, get } = makeCounterAPI(components.counter, {
  auth: async (ctx, operation) => {
    const userId = await getAuthUserId(ctx);
    // Check if the user has permission to perform the operation
    if (operation === "write" && !userId) {
      throw new Error("User not authenticated");
    }
    return userId;
  },
});
```

This pattern is also useful for components that need to provide functions with
specific signatures for integration purposes.

Here's a real-world
[example](https://github.com/get-convex/prosemirror-sync/blob/91e19d5e5a2a272d44f3a31c9171e111dc98676c/src/client/index.ts#L171C4-L173C6)
from the
[ProseMirror component](https://www.convex.dev/components/prosemirror-sync) that
exports ready-made functions.

### Class-Based Clients

For more complex components, a class-based client provides a stateful interface
that can hold configuration and provide multiple methods.

**Basic class pattern:**

```tsx
import Foo from "@convex-dev/foo";
import { components } from "./_generated/server.js";

const foo = new Foo(components.foo, {
  maxShards: 10,
});
```

**With configuration options:**

Classes typically accept the component reference as their first argument, with
optional configuration as the second:

```tsx
export class Foo {
  private apiKey: string;

  constructor(
    public component: ComponentApi,
    options?: {
      maxShards?: number;
      // Named after the environment variable it overrides, for clarity.
      FOO_AUTH_KEY?: string;
    },
  ) {
    this.apiKey = options?.FOO_AUTH_KEY ?? process.env.FOO_AUTH_KEY!;
  }

  async count(ctx: GenericQueryCtx<GenericDataModel>) {
    return await ctx.runQuery(this.component.public.count, {
      API_KEY: this.apiKey,
    });
  }
}
```

**Dynamic instantiation:** Note that clients don't need to be instantiated
statically. If you need runtime values, you can create instances dynamically:

```tsx
export const myQuery = query({
  handler: async (ctx, args) => {
    const foo = new Foo(components.foo, {
      apiKey: args.customApiKey,
    });
    await foo.count(ctx);
  },
});
```

## Building and publishing NPM package components

### Build process

While developing a component that will be bundled, the example app that installs
and exercises it will import the bundled version of the component. This helps
ensure that the code you are testing matches the code that will be published.

However, that means `npx convex dev` cannot detect where the original source
code is located for the component, and will not automatically generate the code
for the component. When developing a component that will be bundled, you need to
run a separate build process to generate the component's `_generated` directory.

The component authoring template will automatically generate the code for the
component when running `npm run dev`. You can see the setup in the
[template's `package.json` scripts](https://github.com/get-convex/templates/blob/main/template-component/package.json).

If you're setting up your own build process, you'll need to run the following
commands with their own file watchers:

1. **Component codegen**: Generate code for the component itself

   ```bash
   npx convex codegen --component-dir ./path/to/component
   ```

2. **Build the package**: Build the NPM package

   ```bash
   npm run build # Your build command (e.g., tsc, esbuild, etc.)
   ```

3. **Example app codegen & deploy**: Generate code for the example app and
   deploy it app
   ```bash
   npx convex dev --typecheck-components # optionally type-check the components
   ```

**Note on ordering:** The ideal ordering is: component codegen → build the
package → example app `convex dev` runs. This is a recommended convention
followed by the template to avoid builds racing with each other, but the key
requirement is that the component must be built and available before the example
app tries to import it.

### Entry points

When publishing a component on NPM, you will need to expose all the relevant
entry points to be used in your project:

- `@your/package` exports types, classes, and constants used to interact with
  the component from within their app's code. This is optional, but common.
- `@your/package/convex.config.js` exposes the component's config.
- `@your/package/_generated/component.js` exports the `ComponentApi` type, which
  describes the component's types from the point of view of app it's used in.
- `@your/package/test` for utilities to use the component with `convex-test`.

[The template’s package.json](https://github.com/get-convex/templates/blob/main/template-component/package.json)
does this for you, but if you're setting up your own build process, you'll need
to set this up in your package.json.

### Local package resolution for development

When developing a component, you generally want to be importing the component's
code in the same way that apps will import it, e.g.
`import {} from "@your/package"`. To achieve this without having to install the
package from NPM in the example app, follow the template's project structure:

1. In the root of the project, have the `package.json` with the package name
   matching the `@your/package` name. This causes imports for that name to
   resolve to the `package.json`’s `exports`.
2. In the `exports` section of the `package.json`, map the aforementioned entry
   points to the bundled files, generally in the `dist` directory. This means
   imports from the package name will resolve to the bundled files.
3. Have a single package.json file and node_modules directory in the root of the
   project, so the example app will resolve to the package name by default. This
   will also avoid having multiple versions of `convex` referenced by the
   library vs. the example app. To add dependencies used only by the example
   app, add them as `devDependencies` in the `package.json`.

### Publishing to NPM

To publish a component on NPM, check out
[PUBLISHING.md](https://github.com/get-convex/templates/blob/main/template-component/PUBLISHING.md).

## Testing

### Testing implementations

To test components, you can use the
[`convex-test` library](/testing/convex-test.mdx). The main difference is that
you must provide the schema and modules to the test instance.

```ts title="component/some.test.ts"
import { test } from "vitest";
import { convexTest } from "convex-test";
import schema from "./schema.ts";
const modules = import.meta.glob("./**/*.ts");

export function initConvexTest() {
  const t = convexTest(schema, modules);
  return t;
}

test("Test something with a local component", async () => {
  const t = initConvexTest();
  // Test like you would normally.
  await t.run(async (ctx) => {
    await ctx.db.insert("myComponentTable", { name: "test" });
  });
});
```

If your component has child components, see the
[Testing components](/components/using.mdx#testing-components) section in the
Using Components documentation.

### Testing the API and client code

To test the functions that are exported from the component to run in the app's
environment, you can follow the same approach as in
[Using Components](/components/using.mdx#testing-components) and test it from an
app that uses the component.

The template component includes an example app in part for this purpose: to
exercise the component's bundled code as it will be used by apps installing it.

### Exporting test helpers

Most components export testing helpers to make it easy to register the component
with the test instance. Here is an example from the
[template component’s `/test` entrypoint](https://github.com/get-convex/templates/blob/main/template-component/src/test.ts):

```ts
/// <reference types="vite/client" />
import type { TestConvex } from "convex-test";
import type { GenericSchema, SchemaDefinition } from "convex/server";
import schema from "./component/schema.js";
const modules = import.meta.glob("./component/**/*.ts");

/**
 * Register the component with the test convex instance.
 * @param t - The test convex instance, e.g. from calling `convexTest`.
 * @param name - The name of the component, as registered in convex.config.ts.
 */
export function register(
  t: TestConvex<SchemaDefinition<GenericSchema, boolean>>,
  name: string = "sampleComponent",
) {
  t.registerComponent(name, schema, modules);
}
export default { register, schema, modules };
```

For NPM packages, this is exposed as `@your/package/test` in the package's
`package.json`:

```json
{
  ...
  "exports": {
    ...
    "./test": "./src/test.ts",
    ...
  }
}
```



================================================
FILE: npm-packages/docs/docs/components/understanding.mdx
================================================
---
title: "Understanding Components"
slug: "understanding"
sidebar_position: 10
description: "Understanding components"
---

Convex Components are self-contained backend modules that bundle functions,
schemas, and data together. They let you add complex functionality to your
app—like authentication, rate limiting, or document collaboration—without
implementing everything from scratch.

If you've worked with modern web development, you've likely encountered similar
ideas in different forms. Components draw inspiration from frontend components,
third-party APIs, and service-oriented architectures. The key difference is that
Convex Components run within your backend, giving you composability combined
with the persistence and reliability of backend services.

The following diagram shows how data and function access works in the component
ecosystem. Arrows from one element to another represent that an element has
access to the functions or data of the other element.

<p style={{ textAlign: "center" }}>
  <img
    src="/img/components-diagram.png"
    alt="Screenshot of the component dropdown"
    width={600}
  />
</p>

### Data

Similar to frontend components, Convex Components encapsulate state and behavior
and allow exposing a clean interface. However, instead of storing state in
memory, these can have internal state machines that can persist between user
sessions, span users, and change in response to external inputs, such as
webhooks. Components can store data in a few ways:

- Database tables with their own schema validation definitions. Since Convex is
  realtime by default, data reads are automatically reactive, and writes commit
  transactionally.
- File storage, independent of the main app's file storage.
- Durable functions via the built-in function scheduler. Components can schedule
  functions to run in the future and pass along state.

Typically, libraries require configuring a third party service to add stateful
off-the-shelf functionality, which lack the transactional guarantees that come
from storing state in the same database.

### Isolation

Similar to regular npm libraries, Convex Components include functions, type
safety, and are called from your code. However, they also provide extra
guarantees.

- Similar to an external service, code inside a component can't read data that
  is not explicitly provided to it. This includes database tables, file storage,
  environment variables, scheduled functions, etc. Conversely, the component's
  data cannot be directly mutated by the main app, allowing full separation of
  concerns.
- Similar to a service-oriented architecture, functions in components are run in
  an isolated environment, so writes to global variables and patches to system
  behavior are not shared between components.
- Similar to a monolithic architecture, data changes commit transactionally
  across calls to components, without having to reason about complicated
  distributed commit protocols or data inconsistencies. You'll never have a
  component commit data but have the calling code roll back.
- In addition, each mutation call to a component is a sub-transaction isolated
  from other calls, allowing you to safely catch errors thrown by components.
  This also allows component authors to easily reason about state changes
  without races, and trust that a thrown exception will always roll back the
  component's sub-transaction. [Read more](/components/using.mdx#transactions).

### Encapsulation

Being able to reason about your code is essential to scaling a codebase.
Components allow you to reason about API boundaries and abstractions.

- The transactional guarantees discussed above allows authors and users of
  components to reason locally about data changes.
- Components expose an explicit API, not direct database table access. Data
  invariants can be enforced in code, within the abstraction boundary. For
  example, the [aggregate component](https://convex.dev/components/aggregate)
  can internally denormalize data, the
  [rate limiter](https://convex.dev/components/rate-limiter) component can shard
  its data, and the
  [push notification](https://convex.dev/components/push-notifications)
  component can internally batch API requests, while maintaining simple
  interfaces.
- Runtime validation ensures all data that cross a component boundary are
  validated: both arguments and return values. As with normal Convex functions,
  the validators also specify the TypeScript types, providing end-to-end typing
  with runtime guarantees.



================================================
FILE: npm-packages/docs/docs/components/using.mdx
================================================
---
title: "Using Components"
slug: "using"
sidebar_position: 20
hide_table_of_contents: true
description: "Using existing components"
---

Convex Components add new features to your backend in their own sandbox with
their own functions, schema and data, scheduled functions and all other
fundamental Convex features.

You can see the full list of components in the
[directory](https://convex.dev/components).

## Installation

We'll use the [Agent](https://www.npmjs.com/package/@convex-dev/agent) component
as an example.

<StepByStep>
  <Step title="Install from `npm`">

```bash
npm i @convex-dev/agent
```

  </Step>
  <Step title="Add the component to your app">
  Create or update the `convex.config.ts` file in your app's `convex/` folder and install the component by calling `use`. Multiple instances of the same component can be installed by calling `use` multiple times with different names. Each will have their own tables and functions.

```ts title="convex/convex.config.ts"
import { defineApp } from "convex/server";
import agent from "@convex-dev/agent/convex.config.js";

const app = defineApp();

// highlight-next-line
app.use(agent);
app.use(agent, { name: "agent2" });
//... Add other components here

export default app;
```

  </Step>
  <Step title="Run convex dev">
  The `convex dev` CLI command will generate code necessary for using the component.

```bash
npx convex dev
```

  </Step>
  <Step title="Access the component through its API">

Each instance of a component has its API listed under the `components` object by
its name. Some components wrap this API with classes or functions. Check out
each component's documentation for more details on its usage.

```ts
import { components } from "./_generated/api.js";

const agent = new Agent(components.agent, { ... });
```

  </Step>

</StepByStep>

## Using the component's API directly

Though components may expose higher level TypeScript APIs, under the hood they
are called via normal Convex functions over the component sandbox boundary.

Queries, mutations, and action rules still apply - queries can only call
component queries, mutations can also call component mutations, and actions can
also call component actions. As a result, queries into components are reactive
by default, and mutations have the same transaction guarantees.

Component functions can be called from your application using the following
syntax:

```ts
import { internalAction } from "./_generated/server";
import { components } from "./_generated/api";

export const myAction = internalAction({
  args: { threadId: v.string() },
  handler: async (ctx, args) => {
    // Call the component's API to get the thread status.
    const { status } = await ctx.runQuery(components.agent.threads.getThread, {
      threadId: args.threadId,
    });
    //...
  },
});
```

Some components abstract away the component's API. For instance, the `Agent`
class from `@convex-dev/agent` is initialized with `components.agent`, and its
methods take in `ctx` so they can call the component's API internally.
[Learn more about the Agent Component here](/agents.mdx).

## Transactions

Remember that mutation functions in Convex are
[transactions](/functions/mutation-functions.mdx#transactions). Either all the
changes in the mutation get written at once or none are written at all.

All writes for a top-level mutation call, including writes performed by calls
into other components' mutations, are committed at the same time. If the
top-level mutation throws an error, all of the writes are rolled back, and the
mutation doesn't change the database at all.

However, if a component mutation call throws an exception, only its writes are
rolled back. Then, if the caller catches the exception, it can continue, perform
more writes, and return successfully. If the caller doesn't catch the exception,
then it's treated as failed and all the writes associated with the caller
mutation are rolled back. This means your code can choose a different code path
depending on the semantics of your component.

As an example, take the
[Rate Limiter](https://www.npmjs.com/package/@convex-dev/ratelimiter) component.
One API of the Rate Limiter throws an error if a rate limit is hit:

```ts
// Automatically throw an error if the rate limit is hit.
await rateLimiter.limit(ctx, "failedLogins", { key: userId, throws: true });
```

If the call to `rateLimiter.limit` throws an exception, we're over the rate
limit. Then, if the calling mutation doesn't catch this exception, the whole
transaction is rolled back.

The calling mutation, on the other hand, could also decide to ignore the rate
limit by catching the exception and proceeding. For example, an app may want to
ignore rate limits if there is a development environment override. In this case,
only the component mutation will be rolled back, and the rest of the mutation
will continue.

## Dashboard

You can see your component’s data, functions, files, logs, and other info using
the dropdown in the Dashboard. You can also use the dropdown to exclude info
from certain components.

<p style={{ textAlign: "center" }}>
  <img
    src="/screenshots/component_dropdown.png"
    alt="Screenshot of the component dropdown"
    width={414}
  />
</p>

## Testing components

When writing tests with [`convex-test`](/testing/convex-test.mdx), that use
components, you must register the component with the test instance. This tells
it what schema to validate and where to find the component source code. Most
components export convenient helper functions on `/test` to make this easy:

```ts title="convex/some.test.ts"
import agentTest from "@convex-dev/agent/test";
import { expect, test } from "vitest";
import { convexTest } from "convex-test";
import { components } from "./_generated/api";
import { createThread } from "@convex-dev/agent";

// Define this once, often in a shared test helper file.
export function initConvexTest() {
  const t = convexTest();
  // highlight-next-line
  agentTest.register(t);
  return t;
}

test("Agent createThread", async () => {
  const t = initConvexTest();

  const threadId = await t.run(async (ctx) => {
    // Calling functions that use ctx and components.agent
    return await createThread(ctx, components.agent, {
      title: "Hello, world!",
    });
  });
  // Calling functions directly on the component's API
  const thread = await t.query(components.agent.threads.getThread, {
    threadId,
  });
  expect(thread).toMatchObject({
    title: "Hello, world!",
  });
});
```

If you need to register the component yourself, you can do so by passing the
component's schema and modules to the test instance.

```ts title="convex/manual.test.ts"
/// <reference types="vite/client" />
import { test } from "vitest";
import { convexTest } from "convex-test";
import schema from "./path/to/component/schema.ts";
const modules = import.meta.glob("./path/to/component/**/*.ts");

test("Test something with a local component", async () => {
  const t = convexTest();
  t.registerComponent("componentName", schema, modules);

  await t.run(async (ctx) => {
    await ctx.runQuery(components.componentName.someQuery, {
      arg: "value",
    });
  });
});
```

## Log Streams

You can use the `data.function.component_path` field in
[log streams](/production/integrations/log-streams) to separate log lines based
on the component they came from.



================================================
FILE: npm-packages/docs/docs/dashboard/projects.md
================================================
---
title: "Projects"
slug: "projects"
sidebar_position: 10
description: "Create and manage Convex projects, settings, and deployments"
---

![Project settings](/screenshots/projects.png)

A project corresponds to a codebase that uses Convex, which contains a
production deployment and one personal deployment for each team member.

Clicking on a project in the [landing page](https://dashboard.convex.dev) will
redirect you to project details.

## Creating a project

Projects can be created from the dashboard or from the
[CLI](/cli.md#create-a-new-project). To create a project from the dashboard
click on the Create Project button.

## Project Settings

You can access project-level settings by clicking on the triple-dot `⋮` button
on each Project card on the Projects page.

![Project card menu](/screenshots/project_menu.png)

On the [Project Settings page](https://dashboard.convex.dev/project/settings),
you can:

- Update your project's name and slug.
- Manage the project's Admins. See
  [Roles and Permissions](/dashboard/teams.md#roles-and-permissions) for more
  details.
- View the amount of [usage metrics](/dashboard/teams.md#usage) your project has
  consumed.
- Add [custom domains](/production/hosting/custom.mdx#custom-domains) for your
  production deployment
- Generate deploy keys for your production and preview deployments.
- Create and edit
  [default environment variables](/production/environment-variables.mdx#project-environment-variable-defaults).
- View instructions to regain access to your project, should you lose track of
  your `CONVEX_DEPLOYMENT` config.
- Permanently delete the project.

![Project settings](/screenshots/project_settings.png)

## Deleting projects

To delete a project, click on the triple-dot `⋮` button on the Project card and
select "Delete". You may also delete your project from the Project Settings
page.

Once a project is deleted, it cannot be recovered. All deployments and data
associated with the project will be permanently removed. When deleting a project
from the dashboard, you will be asked to confirm the deletion. Projects with
activity in the production deployment will have additional confirmation steps to
prevent accidental deletion.

![Delete project](/screenshots/project_delete.png)



================================================
FILE: npm-packages/docs/docs/dashboard/teams.md
================================================
---
title: "Teams"
slug: "teams"
sidebar_position: 0
description:
  "Manage team settings, members, billing, and access control in Convex"
---

In Convex, your projects are organized by team. Teams are used to share access
to your projects with other people. You may switch between teams or create a new
team by clicking on the name of your team located on the top of the Convex
dashboard. This will open the project selector, where you can switch teams by
clicking on the team name once again.

![Team switcher](/screenshots/team_selector.png)

You may change the name of a team or invite new members to a team by clicking on
the "Team Settings" button located on the top of the project list page.

## General

The [general page](https://dashboard.convex.dev/team/settings) allows changing
the team name and slug.

You may also delete the team from this page. You can only delete a team after
deleting all of it's projects, and removing all other team members from your
team. Deleting your team will automatically cancel your Convex subscription.

![General team settings page](/screenshots/teams_general.png)

## Team Members

Use the
[members settings page](https://dashboard.convex.dev/team/settings/members) to
invite or remove members from your team.

![Team members page](/screenshots/teams_members.png)

### Roles and permissions

Convex has two levels of control for managing access to your team, projects, and
deployments. Team-level roles control what a user can do within the team, while
project-level permissions control what a user can do within a specific project.

#### Team roles

Your team members can have one of the following roles:

- Admin
- Developer

The creator of the team is automatically assigned the Admin role. When inviting
new team members, you may select a role for them. You may also change the role
of a team member at any time.

Developers can:

- Create new projects and deployments. When a new project is created, the
  creator of the project is automatically granted the
  [Project Admin](#project-admins) role for that project.
- View existing projects, and create development and preview deployments for
  these projects. Developers may read data from production deployments, but
  cannot write to them.
- View the team's usage and billing status (such as previous and upcoming
  invoices)

Admins can do everything developers can, as well as:

- Invite new team members
- Remove members from the team
- Change the role of other team members
- Manage the team's Convex subscription and billing details.
- Change the team name and slug
- Team Admins are also implicitly granted project admin access to all projects
  within the team. See [Project Admins](#project-admins) for more information.

#### Project Admins

In addition to team roles, you may also grant admin access to individual
projects by granting team members the "Project Admin" role.

If you are a Project Admin for a given project, you may:

- Update the project name and slug
- Update the project's default environment variables
- Delete the project
- Write to production deployments

You may assign and remove the Project Admin role for multiple projects at the
same time on the member settings page. To assign or remove the Project Admin
role for multiple members at the same time, visit the
[Project Settings](/dashboard/projects.md#project-settings) page instead.

## Billing

Use the [billing page](https://dashboard.convex.dev/team/settings/billing) to
upgrade your Convex subscription to a higher tier, or manage your existing
subscription.

On paid plans, you can also update your billing contact details, payment method,
and view your invoices.

[Learn more about Convex pricing](https://www.convex.dev/pricing).

![Team billing page](/screenshots/teams_billing.png)

### Spending limits

When you have an active Convex subscription, you can set the spending limits for
your team on the
[billing page](https://dashboard.convex.dev/team/settings/billing):

- The **warning threshold** is only a soft limit: if it is exceeded, the team
  will be notified by email, but no other action will be taken.
- The **disable threshold** is a hard limit: if it is exceeded, all projects in
  the team will be disabled. This will cause errors to be thrown when attempting
  to run functions in your projects. You can re-enable projects by increasing or
  removing the limit.

Spending limits only apply to the resources used by your team’s projects beyond
the amounts included in your plan. The seat fees (the amount paid for each
developer in your team) are not counted towards the limits. For instance, if you
send the spending limit to $0/month, you will be billed for the seat fees only
and the projects will be disabled if you exceed the built-in resources included
in your plan.

![The team billing page with some spending limits set.](/screenshots/teams_billing_spending_limits.png)

## Usage

On the [usage page](https://dashboard.convex.dev/team/settings/usage) you can
see all the resources consumed by your team, and how you're tracking against
your plan's limits.

[Learn more about Convex pricing](https://www.convex.dev/pricing).

![Team usage page](/screenshots/teams_usage.png)

All metrics are available in daily breakdowns:

![Team usage page graphs](/screenshots/teams_usage_2.png)

## Audit Log

<Admonition type="info">

The Audit Log is only available on Convex Professional.

</Admonition>

The [audit log page](https://dashboard.convex.dev/team/settings/audit-log) shows
all the actions taken by members within the team. This includes creating and
managing projects and deployments, inviting and removing team members, and more.

![Team audit log page](/screenshots/teams_audit_log.png)

You may also view a history of deployment-related events on the
[deployment history page](/dashboard/deployments/history.md).



================================================
FILE: npm-packages/docs/docs/dashboard/deployments/data.md
================================================
---
title: "Data"
slug: "data"
sidebar_position: 5
description:
  "View, edit, and manage database tables and documents in the dashboard"
---

![Data Dashboard Page](/screenshots/data.png)

The [data page](https://dashboard.convex.dev/deployment/data) allows you to view
and manage all of your tables and documents.

On the left side of the page is a list of your tables. Clicking on a table will
allows you to create, view, update, and delete documents in that table.

You may drag-and-drop the column headers in each table to visually re-order the
data.

A readonly view of the data page is available in the
[command line](/cli.md#display-data-from-tables).

```sh
npx convex data [table]
```

## Filtering documents

You may filters documents on the data page by clicking the "Filter" button on
the top of the page.

![Data filters](/screenshots/data_filters.png)

All fields in a document are filterable by the operations supported in Convex
query syntax. [Equality](/database/reading-data/filters.mdx#equality-conditions)
and [comparisons](/database/reading-data/filters.mdx#comparisons) share the same
rules when filtering in the dashboard as a query using the Convex client. You
may also filter based on the type of the field.

To add a filter, click the `+` next to an existing filter. If you add more than
one condition, they will be evaluated using the `and` operation.

For each filter, you must select a field to filter by, operation, and comparison
value. In the third input box (selecting a value), you may enter a valid Convex
value, such as `"a string"`, `123`, or even a complex object, such as
`{ a: { b: 2 } }`

<Admonition type="note">

When filtering by `_creationTime`, a date picker will be displayed instead of
the normal JavaScript syntax input box. Comparisons for `_creationTime` are made
at the nanosecond granularity, so if you'd like to filter to an exact time, try
adding two filter conditions for `creationTime >= $time` and
`creationTime <= $time + 1 minute`.

</Admonition>

## Writing custom queries

You can write a [query](/database/reading-data/reading-data.mdx) directly in the
dashboard. This allows you to perform arbitrary filtering and transformation of
the data, including sorting, joins, grouping and aggregations.

In the `⋮` overflow menu at the top of the data page click on the “Custom query”
option.

<img
    src="/screenshots/data_custom_query.png"
    alt="Custom query button"
    width={250}
/>

This opens the same UI used for
[running your deployed functions](/dashboard/deployments/functions.md#running-functions),
but with the “Custom test query” option selected, which lets you edit the source
code for the query. This source code will be sent to your deployment and
executed when you click on the “Run Custom Query“ button.

![Running a custom test query](/screenshots/data_custom_query_runner.png)

If you're not on the data page, you can still open this UI via the persistent
_fn_ button shown on the bottom right of all deployment pages. The keyboard
shortcut to open the function runner is Ctrl + ` (backtick).

## Creating tables

You may create a table from the dashboard by clicking the "Create Table" button
and entering a new name for the table.

## Creating documents

You may add individual documents to the table using the “Add Documents” button
located in the data table's toolbar.

Once you click “Add Documents” a side panel will open, allowing you to add new
documents to your table using JavaScript syntax. To add more than one document
add a time, add new objects to the array in the editor.

![Add document](/screenshots/data_add_document.png)

## Quick actions (context menu)

You can right-click on a document or value to open a context menu with quick
actions, like copying values, quickly filtering by the selected value, and
deleting documents.

![Quick actions context menu](/screenshots/data_context_menu.png)

## Editing a cell

To edit a cell's value, double-click on the cell in the data table, or press the
Enter key while it’s selected. You can change the selected cell by using the
arrow keys.

You can change the value by editing inline, and pressing enter to save.

<Admonition type="note">

You can even edit the type of your value here, as long as it satisfies your
[schema](/database/schemas.mdx) — try replacing a string with an object!

</Admonition>

![Inline value editor](/screenshots/data_edit_inline.png)

## Editing a document

To edit multiple fields in a document at the same time, hover over the document
and right-click to open the context menu. From there you can click on "Edit
Document".

![Edit entire document](/screenshots/data_edit_document.png)

## Adding references to other documents

To reference another document, use the string ID of the document you want to
reference.

You can copy the ID by clicking on its cell and pressing CTRL/CMD+C.

## Bulk editing documents

You can edit multiple or all documents at once. To select all documents click on
the checkbox in the table header row. To select individual documents hover over
the left-most cell and click the checkbox that appears. To select multiple
adjacent documents at once, press the Shift key when clicking on the checkbox.

When at least one document is selected, the “(Bulk) Edit Document(s)” button
will be visible in the table toolbar. Click the button and an editor will appear
on the right hand side.

![Bulk edit documents](/screenshots/data_bulk_edit.png)

## Deleting documents

When at least one document is selected (see above), the “Delete Document(s)”
button will be visible in the table toolbar. Click the button to delete
documents. If you're editing data in a production deployment a confirmation
dialog will appear before the documents are deleted.

## Clear a table

You can also delete all documents by clicking on the `⋮` overflow menu at the
top of the data page and clicking "Clear Table". This action will delete all
documents in the table, without deleting the table itself.

In production environments, the Convex dashboard will have you type in the name
of the table before deletion.

## Delete a table

<Admonition type="caution" title="This is a permanent action">

Deleting a table is irreversible. In production environments, the Convex
dashboard will have you type in the name of the table before deletion.

</Admonition>

The "Delete table" button can be found by clicking on the `⋮` overflow menu at
the top of the data page. This action will delete all documents this table, and
remove the table from your list of tables. If this table had indexes, you will
need to redeploy your convex functions (by running `npx convex deploy` or
`npx convex dev` for production or development, respectively) to recreate the
indexes.

## Generating a schema

At the bottom-left of the page is a "Generate Schema" button which you can click
to have Convex generate a [schema](/database/schemas.mdx) of all your documents
within this table.

![Generate Schema button](/screenshots/data_generate_schema.png)

## View the schema of a table

The "Schema" button can be found by clicking on the `⋮` overflow menu at the top
of the data page.

This button will open a panel showing the saved and generated
[schemas](/database/schemas.mdx) associated with the selected table.

## View the indexes of a table

The "Indexes" button can be found by clicking on the `⋮` overflow menu at the
top of the data page.

This button will open a panel showing the
[indexes](/database/reading-data/indexes/indexes.md) associated with the
selected table.

Indexes that have not completed backfilling will be accompanied by a loading
spinner next to their name.



================================================
FILE: npm-packages/docs/docs/dashboard/deployments/deployments.md
================================================
---
title: "Deployments"
id: "deployments"
sidebar_position: 20
description:
  "Understand Convex deployments including production, development, and preview
  deployments, and how to switch between them in the dashboard."
---

Each project in Convex has a main production deployment, and each developer on
your team can also set up their own personal development deployment.
Additionally, there are
[preview deployments](/production/hosting/preview-deployments.mdx) used to test
backend changes before they're deployed to production.

While on a [deployment page](https://dashboard.convex.dev/deployment), you may
switch between production, your development deployment, and any preview
deployments by using the dropdown menu on the top-left of the page.

![Deployment switcher](/screenshots/deployment_menu.png)



================================================
FILE: npm-packages/docs/docs/dashboard/deployments/files.md
================================================
---
title: "File Storage"
sidebar_label: "Files"
slug: "file-storage"
sidebar_position: 20
description:
  "Upload, download, and manage files stored in your Convex deployment"
---

The [file storage page](https://dashboard.convex.dev/deployment/files) displays
[files stored in your deployment](/file-storage.mdx). The page also shows the
files' storage IDs, size, and content type. You can upload new files and
download or delete existing files.

Storage IDs might be referenced by documents in your database.

<Admonition type="tip">

When new files are uploaded, the UI will reference the name of the recently
uploaded file. However, these names are not persisted and will no longer appear
when the page is reloaded.

</Admonition>

![File Storage button](/screenshots/file_storage.png)



================================================
FILE: npm-packages/docs/docs/dashboard/deployments/functions.md
================================================
---
title: "Functions"
slug: "functions"
sidebar_position: 10
description:
  "Run, test, and monitor Convex functions with metrics and performance data"
---

![Functions Dashboard View](/screenshots/functions.png)

The [functions page](https://dashboard.convex.dev/deployment/functions) shows
all currently deployed Convex functions.

For dev deployments, these are updated continuously by
[`npx convex dev`](/cli.md#run-the-convex-dev-server). The functions for
production deployments are registered with
[`npx convex deploy`](/cli.md#deploy-convex-functions-to-production).

## Running functions

To run a Convex function in the dashboard, select a function from the list on
the left-hand side of the page, and click the "Run Function" button that appears
next to the function's name.

If you're not on the functions page, you can still open this UI via the
persistent _fn_ button shown on the bottom right of all deployment pages. The
keyboard shortcut to open the function runner is Ctrl + ` (backtick).

This view allows you to fill out the arguments for your function and run it.

Query results will update automatically as you modify function arguments and
data changes.

Mutation and action results will be visible once you click the "Run" button.

Note that these results will show the logs and value returned from the function.
To see what changed when you ran your function, see the
[data page](/dashboard/deployments/data.md).

![Running a function](/screenshots/run_function.png)

You can also
[write a custom query function](/dashboard/deployments/data.md#writing-custom-queries)
by choosing the “Custom test query“ option instead of one of your deployed
functions.

### Querying a paginated function

When querying a paginated function in the dashboard, the UI will expect the
arguments to include
[`PaginationOptions`](/api/interfaces/server.PaginationOptions) -- i.e. an
object containing the `numItems` field, and optionally the `cursor` field. The
name of this argument should be the same as the name defined in your query
function.

- `numItems` should be the number of items to include in a page
- `cursor` can be left blank to begin pagination. Once you receive results, you
  may set `cursor` to the result's `continueCursor` field to proceed to the next
  page.

### Assuming a user identity

<Admonition type="tip">

Assuming a user identity in the Convex dashboard does not give you access to a
real user identity. Instead, this concept can be thought of as "mocking" a user
identity into your function.

</Admonition>

If you're building an authenticated application, you may want to run a Convex
function while acting as an authenticated user identity.

To do so, check the "Act as a user" box.

From there, you can type in the box that appears to fill out the user identity
object.

![Acting as a user](/screenshots/acting_as_a_user.png)

The valid user attributes are:

| Attribute           | Type                                     |
| ------------------- | ---------------------------------------- |
| subject\*           | string                                   |
| issuer\*            | string                                   |
| name                | string                                   |
| givenName           | string                                   |
| familyName          | string                                   |
| nickname            | string                                   |
| preferredUsername   | string                                   |
| profileUrl          | string                                   |
| email               | string                                   |
| emailVerified       | boolean                                  |
| gender              | string                                   |
| birthday            | string                                   |
| timezone            | string                                   |
| language            | string                                   |
| phoneNumber         | string                                   |
| phoneNumberVerified | boolean                                  |
| address             | string                                   |
| updatedAt           | string (in the form of an RFC 3339 date) |
| customClaims        | object                                   |

\*These attributes are required.

## Metrics

There are four basic charts for each function. For overall team usage metrics,
see [team settings](/dashboard/teams.md#usage).

### Invocations

This chart plots the number of times your function was called per minute. As
your app's usage increases, you should see this chart trend upward as well.

### Errors

A plot of any exceptions that occur while running your function. Want to know
what's going wrong? Check out the logs page, detailed below.

### Cache Hit Rate

<Admonition type="tip">
Cache hit rate only applies to query functions
</Admonition>

A percentage rate of how often this function is simply reusing a cached value
vs. being rerun. Your application will run best and your response times will be
fastest with high cache hit rates.

### Execution Time

How long, in milliseconds, this function is taking to run.

There are four individual lines plotted on this chart, p50, p90, p95, and p99.
Each of these lines represents the response time for that percentile in the
distribution of hits over time. So, only 1% of requests took longer to run than
the time shown by the p99 line. Typically, keeping an eye on these _tail
latencies_ is a good way to make sure your application is getting data services
quickly.

Consider the relationship of the execution time to the cache hit rate. As a
rule, a cache hit takes well under 1 ms, so the higher your cache hit rate, the
better your response times will be.

Clicking on any of the charts will give you a larger, detailed view where you
can customize the time ranges you're inspecting.



================================================
FILE: npm-packages/docs/docs/dashboard/deployments/health.md
================================================
---
title: "Health"
slug: "health"
sidebar_position: 0
description:
  "Monitor your Convex deployment health including failure rates, cache
  performance, scheduler status, and deployment insights for optimization."
---

The [health page](https://dashboard.convex.dev/deployment/) is the landing page
for your deployment. On this page, you can see some important information about
the health of your deployment.

## Failure Rate

![Failure Rate Card](/screenshots/health_failure_rate.png)

The failure rate card shows the percentage of failed request by minute ove the
last hour. The failure rate is calculated as the number of failed requests
divided by the total number of requests.

## Cache Hit Rate

![Cache Hit Rate Card](/screenshots/health_cache_hit_rate.png)

The cache hit rate card shows the percentage of cache hits by minute over the
last hour. The cache hit rate is calculated as the number of cache hits divided
by the total number of requests.

Cache hit rate only applies to query functions.

## Scheduler Status

![Scheduler Status Card](/screenshots/scheduler_overdue.png)

The scheduler status card shows the status of the
[scheduler](/scheduling/scheduled-functions). If the scheduler falls behind due
to too many scheduled tasks, the status will show as "Overdue", displaying the
lag time in minutes.

You may click the button in the top right corner of the card to view a chart
showing the scheduler status over the last hour.

![Scheduler Status Chart](/screenshots/scheduler_status.png)

## Last Deployed

![Last Deployed Card](/screenshots/health_last_deployed.png)

The last deployed card shows the time of the last time your functions were
deployed.

## Integrations

<Admonition type="info">

Integrations are only available on Convex Professional.

</Admonition>

![Last Deployed Card](/screenshots/health_integrations.png)

The integrations card shows the status of your
[Exception Reporting](/production/integrations/exception-reporting) and
[Log Streams](/production/integrations/log-streams) integrations, with quick
links to view and configure your integrations.

## Insights

![Insights Card](/screenshots/insights.png)

The Health page also surfaces insights about your deployment, with suggestions
on how to improve performance and reliability.

Each Insight contains a description of the issue, the impact on your deployment
(via a chart and event log), and a link to learn more about the issue and how to
resolve it.

Clicking on an Insight will open a breakdown of the issue, including a larger
chart and a list of events that triggered the Insight.

![Insight Breakdown](/screenshots/insights_breakdown.png)

Available insights include:

- Functions that are
  [reading too many bytes](/production/state/limits#transactions) in a single
  transaction.
- Functions that are
  [reading too many documents](/production/state/limits#transactions) in a
  single transaction.
- Functions that are experiencing [write conflicts](/error#1).



================================================
FILE: npm-packages/docs/docs/dashboard/deployments/history.md
================================================
---
title: "History"
slug: "history"
sidebar_position: 50
description:
  "View an audit log of configuration-related events in your Convex deployment
  including function deployments, index changes, and environment variable
  updates."
---

![History Dashboard Page](/screenshots/history.png)

<Admonition type="info">

The history page is only available on Convex Professional.

</Admonition>

This [history page](https://dashboard.convex.dev/deployment/history) is an audit
log of configuration-related events that have occurred in the selected
deployment, such as function deployments, changes to indexes, and changes to
environment variables.

You may also view an audit log of team-related events in the
[team audit log](/dashboard/teams.md#audit-log).



================================================
FILE: npm-packages/docs/docs/dashboard/deployments/logs.md
================================================
---
title: "Logs"
slug: "logs"
sidebar_position: 40
description:
  "View real-time function logs and deployment activity in your dashboard"
---

![Logs Dashboard Page](/screenshots/logs.png)

The [logs page](https://dashboard.convex.dev/deployment/logs) is a realtime view
of all activity that occurs within your deployment.

The logs page provides a short history of recent function logs, and will display
new logs as they are generated. To store a longer history of logs, you may
configure a [log stream](/production/integrations/log-streams/log-streams.mdx).

Function activity includes:

- The time of function execution.
- The request ID of the function execution.
- The outcome of the function execution (success or failure).
- The name of the invoked function.
- The output of the function, including any log lines logged by the function (ex
  `console.log`) and exceptions.
- The duration of function execution, in milliseconds (does not include network
  latency).

In addition to function activity,
[deployment events](/dashboard/deployments/history.md) describing configuration
changes will be present here.

Clicking on log will open a view for all logs associated with the same Request
ID as the selected log. This can be useful for debugging errors and
understanding the context of a function execution.

![Request ID Logs](/screenshots/request_logs.png)

You can use controls on the top of this page to filter logs by text, function
name, execution status, and log severity.

### Filter logs

Use the "Filter logs..." text box on the top of the page to filter log text.

You can use the “Functions” drop-down list to include or exclude functions from
the results.

You can also find logs for a particular error using "Filter logs" and the
[Convex request id](/functions/error-handling/error-handling.mdx#debugging-errors).
For example if you see this `Error` in your browser console:

![Browser Error](/screenshots/console_error_requestid.png)

You can view the logs for that function in your dashboard by pasting that
Request ID into the 'Search logs...' search bar on the
[Logs](/dashboard/deployments/logs.md) page of your Convex dashboard. Note that
because this page is not a complete historical view of logs, you may not find
logs for older requests.

Most error reporting services and log sinks should also be searchable by Request
ID.

### Log Types

Logs can also be filtered by type. Types include function outcomes (success or
failure) and severity levels (info, warn, debug, error).

All failed executions will include a reason, which will usually be a JavaScript
exception.



================================================
FILE: npm-packages/docs/docs/dashboard/deployments/schedules.md
================================================
---
title: "Schedules"
slug: "schedules"
sidebar_position: 30
description:
  "Monitor and manage scheduled functions and cron jobs in your deployment"
---

The [schedules page](https://dashboard.convex.dev/deployment/schedules) displays
all [scheduled functions](docs/scheduling/scheduled-functions.mdx) and
[cron jobs](/scheduling/cron-jobs.mdx) in your deployment. Use the tabs at the
top of this page to switch between scheduled functions and cron jobs.

## Scheduled functions UI

The scheduled functions UI shows a list of all upcoming function invocation.
From here, you can filter to scheduled runs for a specific function, and cancel
scheduled functions runs.

![Scheduled functions](/screenshots/scheduled_functions.png)

## Cron jobs UI

The cron jobs UI lists all of your cron jobs, including their run frequency and
scheduled run time.

![Cron jobs](/screenshots/cron_jobs.png)

Expanding a specific cron job will open the execution history for the selected
job.

![Cron job history](/screenshots/cron_job_history.png)



================================================
FILE: npm-packages/docs/docs/dashboard/deployments/settings.md
================================================
---
title: "Settings"
slug: "deployment-settings"
sidebar_position: 60
description:
  "Configure your Convex deployment settings including URLs, environment
  variables, authentication, backups, integrations, and deployment management."
---

The [deployment settings page](https://dashboard.convex.dev/deployment/settings)
gives you access to information and configuration options related to a specific
deployment (**production**, your personal **development** deployment, or a
**preview** deployment).

## URL and Deploy Key

The [URL and deploy key page](https://dashboard.convex.dev/deployment/settings)
shows:

- The URL this deployment is hosted at. Some Convex integrations may require the
  deployment URL for configuration.
- The URL that HTTP Actions for this deployment should be sent to.
- The deployment's deploy key, used to
  [integrate with build tools such as Netlify and Vercel](/production/hosting/hosting.mdx)
  and
  [syncing data with Fivetran and Airbyte](/production/integrations/streaming-import-export.md).

![Deployment Settings Dashboard Page](/screenshots/deployment_settings.png)

## Environment Variables

The
[environment variables page](https://dashboard.convex.dev/deployment/settings/environment-variables)
lets you add, change, remove and copy the deployment's
[environment variables](/production/environment-variables.mdx).

![deployment settings environment variables page](/screenshots/deployment_settings_env_vars.png)

## Authentication

The
[authentication page](https://dashboard.convex.dev/deployment/settings/authentication)
shows the values configured in your `auth.config.js` for user
[authentication](/auth.mdx) implementation.

## Backup & Restore

The
[backup & restore page](https://dashboard.convex.dev/deployment/settings/backups)
lets you [backup](/database/backup-restore.mdx) the data stored in your
deployment's database and file storage. On this page, you can schedule periodic
backups.

![deployment settings export page](/screenshots/backups.png)

## Integrations

The integrations page allows you to configure
[log streaming](/production/integrations/integrations.mdx),
[exception reporting](/production/integrations/integrations.mdx), and
[streaming export](/production/integrations/streaming-import-export.md)
integrations.

## Pause Deployment

On the
[pause deployment page](https://dashboard.convex.dev/deployment/settings/pause-deployment)
you can [pause your deployment](/production/pause-deployment.mdx) with the pause
button.

![deployment settings pause deployment page](/screenshots/deployment_settings_pause.png)



================================================
FILE: npm-packages/docs/docs/database/backup-restore.mdx
================================================
---
title: "Backup & Restore"
sidebar_position: 85
description: "Backup and restore your Convex data and files"
---

Convex supports Backup & Restore of data via the
[dashboard](https://dashboard.convex.dev/deployment/settings/backups).

![Backups Page](/screenshots/backups.png)

# Backups

A backup is a consistent snapshot of your table data made at the time of your
request. Backups can be configured to include file storage.

Take a manual backup by pressing the "Backup Now" button. This may take a few
seconds to a few hours, depending on how much data is in your deployment.

Manual backups are stored for 7 days. You can download or delete backups via
this page.

Deployment configuration and other data (code, environment variables, scheduled
functions, etc.) will not be included.

### Periodic Backups

Schedule a periodic daily or weekly backup by checking the "Backup
automatically" box. You can select what time of day / day of week to have the
backup occur and whether to include file storage or not.

Daily backups are stored for 7 days. Weekly backups are stored for 14 days.

<ProFeatureUpsell feature="Periodic backups" verb="require" />

### Restoring from backup

Restore from a backup by selecting "Restore" from the submenu of an individual
backup. You can restore from backups in the same deployment or from other
deployments on the same team by using the deployment selector on the backups
page. Restores may take a few seconds to a few hours depending on how much data
is in your backup.

Note that restoring is a destructive operation that wipes your existing data and
replaces it with that from the backup. It's recommended that you generate an
additional backup before doing a restore.

Existing files in the deployment will not be deleted when restoring from a
backup, but any files in the backup that do not currently exist in the
deployment will be uploaded to the deployment.

### Restoring in an emergency

If your production deployment ends up in a bad state, you may want to consider
doing a restore to return to a good state. Note that getting your data to a good
state may not be enough. Consider whether you may need each of the following
actions. Depending on the nature of your emergency, these may be required.

- Take an additional backup prior to restore, since restores are destructive
- Do a restore from a good backup - to restore data
- Use `npx convex dev` to push a known version of good code.
- Use `npx convex env` or the dashboard to restore to a good set of env vars
- Use the dashboard to make any manual fixes to the database for your app.
- Write mutations to make required (more programmatic) manual fixes to the
  database for your app.

# Downloading a backup

You can download your manual and periodic backups from the dashboard via the
download button in the menu.

Alternatively, you can generate an export in the same format with the
[command line](/cli.md#export-data-to-a-file):

```sh
npx convex export --path ~/Downloads
```

The backup comes as a generated a ZIP file with all documents in all Convex
tables in your deployment.

The ZIP file's name has the format `snapshot_{ts}.zip` where `ts` is a UNIX
timestamp of the snapshot in nanoseconds. The export ZIP file contains documents
for each table at `<table_name>/documents.jsonl`, with one document per line.

Exported ZIP files that include [file storage](/file-storage) will contain
storage data in a `_storage` folder, with metadata like IDs and checksums in
`_storage/documents.jsonl` and each file as `_storage/<id>`.

### Using the downloaded backup.

Downloaded ZIP files can be imported into the same deployment or a different
deployment
[with the CLI](/database/import-export/import.mdx#restore-data-from-a-backup-zip-file).

## FAQ

### Are there any limitations?

Each backup is accessible for up to 7 days.

On the Free/Starter plan, up to two backups can stored per deployment at a time.
Deployments on Convex Professional plan can have many backups with standard
usage based pricing.

### How are they priced?

Backups uses database bandwidth to read all documents, and file bandwidth to
include user files. The generation and storage of the backup itself is billed
with the same bandwidth and storage pricing as user file storage. You can
observe this bandwidth and storage cost in the
[usage dashboard](https://dashboard.convex.dev/team/settings/usage). Check the
[limits docs](/production/state/limits#database) for pricing details.

### What does the backup not contain?

The backup only contains the documents for your tables and files in file
storage. In particular it lacks:

1. Your deployment's code and configuration. Convex functions, crons.ts,
   auth.config.js, schema.ts, etc. are configured in your source code.
2. Pending scheduled functions. You can access pending scheduled functions in
   the [`_scheduled_functions`](/database/advanced/system-tables.mdx) system
   table.
3. Environment variables. Environment variables can be copied from Settings in
   the Convex dashboard.



================================================
FILE: npm-packages/docs/docs/database/document-ids.mdx
================================================
---
title: "Document IDs"
sidebar_position: 10
description: "Create complex, relational data models using IDs"
---

import SerializeExample from "!!raw-loader!@site/../private-demos/snippets/convex/tasks.ts";
import SerializeCall from "!!raw-loader!@site/../private-demos/snippets/src/documentIdsSerializeCall.tsx";

**Example:**
[Relational Data Modeling](https://github.com/get-convex/convex-demos/tree/main/relational-data-modeling)

Every document in convex has a globally unique string _document ID_ that is
automatically generated by the system.

```ts
const userId = await ctx.db.insert("users", { name: "Michael Jordan" });
```

You can use this ID to efficiently read a single document using the `get`
method:

```ts
const retrievedUser = await ctx.db.get("users", userId);
```

You can access the ID of a document in the
[`_id` field](/database/types.md#system-fields):

```ts
const userId = retrievedUser._id;
```

Also, this same ID can be used to update that document in place:

```ts
await ctx.db.patch("users", userId, { name: "Steph Curry" });
```

Convex generates an [`Id`](/generated-api/data-model#id) TypeScript type based
on your [schema](/database/schemas.mdx) that is parameterized over your table
names:

```typescript
import { Id } from "./_generated/dataModel";

const userId: Id<"users"> = user._id;
```

IDs are strings at runtime, but the [`Id`](/generated-api/data-model#id) type
can be used to distinguish IDs from other strings at compile time.

## References and relationships

In Convex, you can reference a document simply by embedding its `Id` in another
document:

```ts
await ctx.db.insert("books", {
  title,
  ownerId: user._id,
});
```

You can follow references with `ctx.db.get`:

```ts
const user = await ctx.db.get("users", book.ownerId);
```

And [query for documents](/database/reading-data/reading-data.mdx) with a
reference:

```ts
const myBooks = await ctx.db
  .query("books")
  .filter((q) => q.eq(q.field("ownerId"), user._id))
  .collect();
```

Using `Id`s as references can allow you to build a complex data model.

## Trading off deeply nested documents vs. relationships

While it's useful that Convex supports nested objects and arrays, you should
keep documents relatively small in size. In practice, we recommend limiting
Arrays to no more than 5-10 elements and avoiding deeply nested Objects.

Instead, leverage separate tables, documents, and references to structure your
data. This will lead to better maintainability and performance as your project
grows.

## Serializing IDs

IDs are strings, which can be easily inserted into URLs or stored outside of
Convex.

You can pass an ID string from an external source (like a URL) into a Convex
function and get the corresponding object. If you're using TypeScript on the
client you can cast a string to the `Id` type:

<Snippet
  title="src/App.tsx"
  source={SerializeCall}
  highlightPatterns={[" as "]}
/>

Since this ID is coming from an external source, use an argument validator or
[`ctx.db.normalizeId`](/api/interfaces/server.GenericDatabaseReader#normalizeid)
to confirm that the ID belongs to the expected table before returning the
object.

<TSAndJSSnippet
  title="convex/tasks.ts"
  sourceTS={SerializeExample}
  sourceJS={SerializeExample}
  highlightPatterns={["v.id"]}
/>

<StackPosts query="document IDs" />



================================================
FILE: npm-packages/docs/docs/database/pagination.mdx
================================================
---
title: "Paginated Queries"
slug: "pagination"
sidebar_position: 60
description: "Load paginated queries"
---

import Messages from "!!raw-loader!@site/../demos/pagination/convex/messages.ts";
import Download from "!!raw-loader!@site/../demos/pagination/src/download.ts";
import SimpleCall from "!!raw-loader!@site/../demos/pagination/src/_simpleListing.tsx";
import CallWithArgs from "!!raw-loader!@site/../demos/pagination/src/_listingWithArgument.tsx";

Paginated queries are [queries](/functions/query-functions.mdx) that return a
list of results in incremental pages.

This can be used to build components with "Load More" buttons or "infinite
scroll" UIs where more results are loaded as the user scrolls.

**Example:**
[Paginated Messaging App](https://github.com/get-convex/convex-demos/tree/main/pagination)

Using pagination in Convex is as simple as:

1. Writing a paginated query function that calls
   [`.paginate(paginationOpts)`](/api/interfaces/server.OrderedQuery#paginate).
2. Using the [`usePaginatedQuery`](/api/modules/react#usepaginatedquery) React
   hook.

Like other Convex queries, paginated queries are completely reactive.

## Writing paginated query functions

Convex uses cursor-based pagination. This means that paginated queries return a
string called a [`Cursor`](/api/modules/server#cursor) that represents the point
in the results that the current page ended. To load more results, you simply
call the query function again, passing in the cursor.

To build this in Convex, define a query function that:

1. Takes in a single arguments object with a `paginationOpts` property of type
   [`PaginationOptions`](/api/interfaces/server.PaginationOptions).
   - `PaginationOptions` is an object with `numItems` and `cursor` fields.
   - Use `paginationOptsValidator` exported from `"convex/server"` to
     [validate](/functions/validation.mdx) this argument
   - The arguments object may include properties as well.
2. Calls
   [`.paginate(paginationOpts)`](/api/interfaces/server.OrderedQuery#paginate)
   on a [database query](/database/reading-data/reading-data.mdx), passing in
   the `PaginationOptions` and returning its result.
   - The returned `page` in the
     [`PaginationResult`](/api/interfaces/server.PaginationResult) is an array
     of documents. You may
     [`map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
     or
     [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
     it before returning it.

<TSAndJSSnippet
  sourceTS={Messages}
  sourceJS={Messages}
  title="convex/messages.ts"
  highlightPatterns={["paginationOpts"]}
  snippet="list"
/>

### Additional arguments

You can define paginated query functions that take arguments in addition to
`paginationOpts`:

<TSAndJSSnippet
  sourceTS={Messages}
  sourceJS={Messages}
  snippet="listWithExtraArg"
  title="convex/messages.ts"
/>

### Transforming results

You can apply arbitrary
[transformations](/database/reading-data/reading-data.mdx#more-complex-queries)
to the `page` property of the object returned by `paginate`, which contains the
array of documents:

<TSAndJSSnippet
  sourceTS={Messages}
  sourceJS={Messages}
  snippet="listWithTransformation"
  title="convex/messages.ts"
/>

## Paginating within React Components

To paginate within a React component, use the
[`usePaginatedQuery`](/api/modules/react#usepaginatedquery) hook. This hook
gives you a simple interface for rendering the current items and requesting
more. Internally, this hook manages the continuation cursors.

The arguments to this hook are:

- The name of the paginated query function.
- The arguments object to pass to the query function, excluding the
  `paginationOpts` (that's injected by the hook).
- An options object with the `initialNumItems` to load on the first page.

The hook returns an object with:

- `results`: An array of the currently loaded results.
- `isLoading` - Whether the hook is currently loading results.
- `status`: The status of the pagination. The possible statuses are:
  - `"LoadingFirstPage"`: The hook is loading the first page of results.
  - `"CanLoadMore"`: This query may have more items to fetch. Call `loadMore` to
    fetch another page.
  - `"LoadingMore"`: We're currently loading another page of results.
  - `"Exhausted"`: We've paginated to the end of the list.
- `loadMore(n)`: A callback to fetch more results. This will only fetch more
  results if the status is `"CanLoadMore"`.

<TSAndJSSnippet
  sourceTS={SimpleCall}
  sourceJS={SimpleCall}
  snippet="example"
  title="src/App.tsx"
  highlightPatterns={["usePaginatedQuery\\(", "api.", "{}", "initialNumItems"]}
/>

You can also pass additional arguments in the arguments object if your function
expects them:

<TSAndJSSnippet
  sourceTS={CallWithArgs}
  sourceJS={CallWithArgs}
  snippet="example"
  title="src/App.tsx"
  highlightPatterns={["author:"]}
/>

### Reactivity

Like any other Convex query functions, paginated queries are **completely
reactive**. Your React components will automatically rerender if items in your
paginated list are added, removed or changed.

One consequence of this is that **page sizes in Convex may change!** If you
request a page of 10 items and then one item is removed, this page may "shrink"
to only have 9 items. Similarly if new items are added, a page may "grow" beyond
its initial size.

## Paginating manually

If you're paginating outside of React, you can manually call your paginated
function multiple times to collect the items:

<TSAndJSSnippet title="download.ts" sourceTS={Download} sourceJS={Download} />



================================================
FILE: npm-packages/docs/docs/database/schemas.mdx
================================================
---
title: "Schemas"
sidebar_position: 5
description:
  "Schema validation keeps your Convex data neat and tidy. It also gives you
  end-to-end TypeScript type safety!"
toc_max_heading_level: 4
---

import SchemaTS from "!!raw-loader!@site/../demos/users-and-auth/convex/schema.ts";
import circularExample from "!!raw-loader!@site/../private-demos/snippets/convex/schemasCircular.ts";

A schema is a description of

1. the tables in your Convex project
2. the type of documents within your tables

While it is possible to use Convex _without_ defining a schema, adding a
`schema.ts` file will ensure that the documents in your tables are the correct
type. If you're using
[TypeScript](/understanding/best-practices/typescript.mdx), adding a schema will
also give you end-to-end type safety throughout your app.

We recommend beginning your project without a schema for rapid prototyping and
then adding a schema once you've solidified your plan. To learn more see our
[Schema Philosophy](/database/advanced/schema-philosophy.md).

**Example:**
[TypeScript and Schemas](https://github.com/get-convex/convex-demos/tree/main/typescript)

## Writing schemas

Schemas are defined in a `schema.ts` file in your `convex/` directory and look
like:

<Snippet source={SchemaTS} title="convex/schema.ts" />

This schema (which is based on our
[users and auth example](https://github.com/get-convex/convex-demos/tree/main/users-and-auth)),
has 2 tables: messages and users. Each table is defined using the
[`defineTable`](/api/modules/server#definetable) function. Within each table,
the document type is defined using the validator builder,
[`v`](/api/modules/values#v). In addition to the fields listed, Convex will also
automatically add `_id` and `_creationTime` fields. To learn more, see
[System Fields](/database/types.md#system-fields).

<Admonition type="tip" title="Generating a Schema">

While writing your schema, it can be helpful to consult the
[Convex Dashboard](/dashboard/deployments/data.md#generating-a-schema). The
"Generate Schema" button in the "Data" view suggests a schema declaration based
on the data in your tables.

</Admonition>

### Validators

The validator builder, [`v`](/api/modules/values#v) is used to define the type
of documents in each table. It has methods for each of
[Convex's types](/database/types):

```ts noDialect title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  documents: defineTable({
    id: v.id("documents"),
    string: v.string(),
    number: v.number(),
    boolean: v.boolean(),
    nestedObject: v.object({
      property: v.string(),
    }),
  }),
});
```

It additionally allows you to define unions, optional property, string literals,
and more. [Argument validation](/functions/validation.mdx) and schemas both use
the same validator builder, `v`.

#### Optional fields

You can describe optional fields by wrapping their type with `v.optional(...)`:

```typescript
defineTable({
  optionalString: v.optional(v.string()),
  optionalNumber: v.optional(v.number()),
});
```

This corresponds to marking fields as optional with `?` in TypeScript.

#### Unions

You can describe fields that could be one of multiple types using `v.union`:

```typescript
defineTable({
  stringOrNumber: v.union(v.string(), v.number()),
});
```

If your table stores multiple different types of documents, you can use
`v.union` at the top level:

```typescript
defineTable(
  v.union(
    v.object({
      kind: v.literal("StringDocument"),
      value: v.string(),
    }),
    v.object({
      kind: v.literal("NumberDocument"),
      value: v.number(),
    }),
  ),
);
```

In this schema, documents either have a `kind` of `"StringDocument"` and a
string for their `value`:

```json
{
  "kind": "StringDocument",
  "value": "abc"
}
```

or they have a `kind` of `"NumberDocument"` and a number for their `value`:

```json
{
  "kind": "NumberDocument",
  "value": 123
}
```

#### Literals

Fields that are a constant can be expressed with `v.literal`:

```typescript
defineTable({
  oneTwoOrThree: v.union(
    v.literal("one"),
    v.literal("two"),
    v.literal("three"),
  ),
});
```

#### Record objects

You can describe objects that map arbitrary keys to values with `v.record`:

```typescript
defineTable({
  simpleMapping: v.record(v.string(), v.boolean()),
});
```

You can use other types of string validators for the keys:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    userIdToValue: v.record(v.id("users"), v.boolean()),
  },
  handler: async ({ db }, { userIdToValue }) => {
    //...
  },
});
```

Notes:

- This type corresponds to the
  [Record\<K,V\>](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
  type in TypeScript
- You cannot use string literals as a `record` key
- Using `v.string()` as a `record` key validator will only allow ASCII
  characters

#### Any

Fields or documents that could take on any value can be represented with
`v.any()`:

```typescript
defineTable({
  anyValue: v.any(),
});
```

This corresponds to the `any` type in TypeScript.

### Options

These options are passed as part of the
[options](/api/interfaces/server.DefineSchemaOptions) argument to
[`defineSchema`](/api/modules/server#defineschema).

#### `schemaValidation: boolean`

Whether Convex should validate at runtime that your documents match your schema.

By default, Convex will enforce that all new and existing documents match your
schema.

You can disable `schemaValidation` by passing in `schemaValidation: false`:

```typescript
defineSchema(
  {
    // Define tables here.
  },
  {
    schemaValidation: false,
  },
);
```

When `schemaValidation` is disabled, Convex will not validate that new or
existing documents match your schema. You'll still get schema-specific
TypeScript types, but there will be no validation at runtime that your documents
match those types.

#### `strictTableNameTypes: boolean`

Whether the TypeScript types should allow accessing tables not in the schema.

By default, the TypeScript table name types produced by your schema are strict.
That means that they will be a union of strings (ex. `"messages" | "users"`) and
only support accessing tables explicitly listed in your schema.

Sometimes it's useful to only define part of your schema. For example, if you
are rapidly prototyping, it could be useful to try out a new table before adding
it your `schema.ts` file.

You can disable `strictTableNameTypes` by passing in
`strictTableNameTypes: false`:

```typescript
defineSchema(
  {
    // Define tables here.
  },
  {
    strictTableNameTypes: false,
  },
);
```

When `strictTableNameTypes` is disabled, the TypeScript types will allow access
to tables not listed in the schema and their document type will be `any`.

Regardless of the value of `strictTableNameTypes`, your schema will only
validate documents in the tables listed in the schema. You can still create and
modify documents in other tables in JavaScript or on the dashboard (they just
won't be validated).

## Schema validation

Schemas are pushed automatically in
[`npx convex dev`](/cli.md#run-the-convex-dev-server) and
[`npx convex deploy`](/cli.md#deploy-convex-functions-to-production).

The first push after a schema is added or modified will validate that all
existing documents match the schema. If there are documents that fail
validation, the push will fail.

After the schema is pushed, Convex will validate that all future document
inserts and updates match the schema.

Schema validation is skipped if [`schemaValidation`](#schemavalidation-boolean)
is set to `false`.

Note that schemas only validate documents in the tables listed in the schema.
You can still create and modify documents in other tables (they just won't be
validated).

### Circular references

You might want to define a schema with circular ID references like:

```typescript title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  users: defineTable({
    preferencesId: v.id("preferences"),
  }),
  preferences: defineTable({
    userId: v.id("users"),
  }),
});
```

In this schema, documents in the `users` table contain a reference to documents
in `preferences` and vice versa.

Because schema validation enforces your schema on every `db.insert`,
`db.replace`, and `db.patch` call, creating circular references like this is not
possible.

The easiest way around this is to make one of the references nullable:

```typescript title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  users: defineTable({
    preferencesId: v.id("preferences"),
  }),
  preferences: defineTable({
    userId: v.union(v.id("users"), v.null()),
  }),
});
```

This way you can create a preferences document first, then create a user
document, then set the reference on the preferences document:

<TSAndJSSnippet
  title="convex/users.ts"
  sourceTS={circularExample}
  sourceJS={circularExample}
/>

[Let us know](/production/contact.md) if you need better support for circular
references.

## TypeScript types

Once you've defined a schema,
[`npx convex dev`](/cli.md#run-the-convex-dev-server) will produce new versions
of [`dataModel.d.ts`](/generated-api/data-model) and
[`server.d.ts`](/generated-api/server) with types based on your schema.

### `Doc<TableName>`

The [`Doc`](/generated-api/data-model#doc) TypeScript type from
[`dataModel.d.ts`](/generated-api/data-model) provides document types for all of
your tables. You can use these both when writing Convex functions and in your
React components:

```tsx noDialect title="MessageView.tsx"
import { Doc } from "../convex/_generated/dataModel";

function MessageView(props: { message: Doc<"messages"> }) {
  ...
}
```

If you need the type for a portion of a document, use the
[`Infer` type helper](/functions/validation#extracting-typescript-types).

### `query` and `mutation`

The [`query`](/generated-api/server#query) and
[`mutation`](/generated-api/server#mutation) functions in
[`server.js`](/generated-api/server) have the same API as before but now provide
a `db` with more precise types. Functions like
[`db.insert(table, document)`](/api/interfaces/server.GenericDatabaseWriter#insert)
now understand your schema. Additionally
[database queries](/database/reading-data/reading-data.mdx) will now return the
correct document type (not `any`).

<StackPosts query="schemas" />



================================================
FILE: npm-packages/docs/docs/database/types.md
================================================
---
title: "Data Types"
sidebar_position: 40
description: "Supported data types in Convex documents"
---

import ConvexValues from "@site/docs/\_convexValues.mdx";

All Convex documents are defined as JavaScript objects. These objects can have
field values of any of the types below.

You can codify the shape of documents within your tables by
[defining a schema](/database/schemas.mdx).

## Convex values

<ConvexValues />

## System fields

Every document in Convex has two automatically-generated system fields:

- `_id`: The [document ID](/database/document-ids.mdx) of the document.
- `_creationTime`: The time this document was created, in milliseconds since the
  Unix epoch.

## Limits

Convex values must be less than 1MB in total size. This is an approximate limit
for now, but if you're running into these limits and would like a more precise
method to calculate a document's size,
[reach out to us](https://convex.dev/community). Documents can have nested
values, either objects or arrays that contain other Convex types. Convex types
can have at most 16 levels of nesting, and the cumulative size of a nested tree
of values must be under the 1MB limit.

Table names may contain alphanumeric characters ("a" to "z", "A" to "Z", and "0"
to "9") and underscores ("\_"), and they cannot start with an underscore.

For information on other limits, see [here](/production/state/limits.mdx).

If any of these limits don't work for you,
[let us know](https://convex.dev/community)!

## Working with `undefined`

The TypeScript value `undefined` is not a valid Convex value, so it cannot be
used in Convex function arguments or return values, or in stored documents.

1. Objects/records with `undefined` values are the same as if the field were
   missing: `{a: undefined}` is transformed into `{}` when passed to a function
   or stored in the database. You can think of Convex function calls and the
   Convex database as serializing the data with `JSON.stringify`, which
   similarly removes `undefined` values.
2. Validators for object fields can use `v.optional(...)` to indicate that the
   field might not be present.
   - If an object's field "a" is missing, i.e. `const obj = {};`, then
     `obj.a === undefined`. This is a property of TypeScript/JavaScript, not
     specific to Convex.
3. You can use `undefined` in filters and index queries, and it will match
   documents that do not have the field. i.e.
   `.withIndex("by_a", q=>q.eq("a", undefined))` matches document `{}` and
   `{b: 1}`, but not `{a: 1}` or `{a: null, b: 1}`.
   - In Convex's ordering scheme, `undefined < null < all other values`, so you
     can match documents that _have_ a field via `q.gte("a", null as any)` or
     `q.gt("a", undefined)`.
4. There is exactly one case where `{a: undefined}` is different from `{}`: when
   passed to `ctx.db.patch`. Passing `{a: undefined}` removes the field "a" from
   the document, while passing `{}` does not change the field "a". See
   [Updating existing documents](/database/writing-data.mdx#updating-existing-documents).
5. Since `undefined` gets stripped from function arguments but has meaning in
   `ctx.db.patch`, there are some tricks to pass patch's argument from the
   client.
   - If the client passing `args={}` (or `args={a: undefined}` which is
     equivalent) should leave the field "a" unchanged, use
     `ctx.db.patch(id, args)`.
   - If the client passing `args={}` should remove the field "a", use
     `ctx.db.patch(id, {a: undefined, ...args})`.
   - If the client passing `args={}` should leave the field "a" unchanged and
     `args={a: null}` should remove it, you could do
     ```ts
     if (args.a === null) {
       args.a = undefined;
     }
     await ctx.db.patch(tableName, id, args);
     ```
6. Functions that return a plain `undefined`/`void` are treated as if they
   returned `null`.
7. Arrays containing `undefined` values, like `[undefined]`, throw an error when
   used as Convex values.

If you would prefer to avoid the special behaviors of `undefined`, you can use
`null` instead, which _is_ a valid Convex value.

## Working with dates and times

Convex does not have a special data type for working with dates and times. How
you store dates depends on the needs of your application:

1. If you only care about a point in time, you can store a
   [UTC timestamp](https://en.wikipedia.org/wiki/Unix_time). We recommend
   following the `_creationTime` field example, which stores the timestamp as a
   `number` in milliseconds. In your functions and on the client you can create
   a JavaScript `Date` by passing the timestamp to its constructor:
   `new Date(timeInMsSinceEpoch)`. You can then print the date and time in the
   desired time zone (such as your user's machine's configured time zone).
   - To get the current UTC timestamp in your function and store it in the
     database, use `Date.now()`
2. If you care about a calendar date or a specific clock time, such as when
   implementing a booking app, you should store the actual date and/or time as a
   string. If your app supports multiple timezones you should store the timezone
   as well. [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) is a common format
   for storing dates and times together in a single string like
   `"2024-03-21T14:37:15Z"`. If your users can choose a specific time zone you
   should probably store it in a separate `string` field, usually using the
   [IANA time zone name](https://en.wikipedia.org/wiki/Tz_database#Names_of_time_zones)
   (although you could concatenate the two fields with unique character like
   `"|"`).

For more sophisticated printing (formatting) and manipulation of dates and times
use one of the popular JavaScript libraries: [date-fns](https://date-fns.org/),
[Day.js](https://day.js.org/), [Luxon](https://moment.github.io/luxon/) or
[Moment.js](https://momentjs.com/).



================================================
FILE: npm-packages/docs/docs/database/writing-data.mdx
================================================
---
title: "Writing Data"
sidebar_position: 4
description: "Insert, update, and delete data in Convex database tables"
---

import insertExample from "!!raw-loader!@site/../private-demos/snippets/convex/writingDataInsert.ts";
import patchExample from "!!raw-loader!@site/../private-demos/snippets/convex/writingDataPatch.ts";
import replaceExample from "!!raw-loader!@site/../private-demos/snippets/convex/writingDataReplace.ts";
import deleteExample from "!!raw-loader!@site/../private-demos/snippets/convex/writingDataDelete.ts";
import { ComponentCardList } from "@site/src/components/ComponentCard";

[Mutations](/functions/mutation-functions.mdx) can insert, update, and remove
data from database tables.

## Inserting new documents

You can create new documents in the database with the
[`db.insert`](/api/interfaces/server.GenericDatabaseWriter#insert) method:

<TSAndJSSnippet
  title="convex/tasks.ts"
  sourceTS={insertExample}
  sourceJS={insertExample}
  highlightPatterns={["db.insert"]}
/>

The second argument to `db.insert` is a JavaScript object with data for the new
document.

The same types of values that can be passed into and returned from
[queries](/functions/query-functions.mdx) and
[mutations](/functions/mutation-functions.mdx) can be written into the database.
See [Data Types](/database/types.md) for the full list of supported types.

The `insert` method returns a globally unique ID for the newly inserted
document.

## Updating existing documents

Given an existing document ID the document can be updated using the following
methods:

1. The [`db.patch`](/api/interfaces/server.GenericDatabaseWriter#patch) method
   will patch an existing document, shallow merging it with the given partial
   document. New fields are added. Existing fields are overwritten. Fields set
   to `undefined` are removed.

<TSAndJSSnippet
  title="convex/tasks.ts"
  sourceTS={patchExample}
  sourceJS={patchExample}
  highlightPatterns={["db.patch"]}
/>

2. The [`db.replace`](/api/interfaces/server.GenericDatabaseWriter#replace)
   method will replace the existing document entirely, potentially removing
   existing fields:

<TSAndJSSnippet
  title="convex/tasks.ts"
  sourceTS={replaceExample}
  sourceJS={replaceExample}
  highlightPatterns={["db.replace"]}
/>

## Deleting documents

Given an existing document ID the document can be removed from the table with
the [`db.delete`](/api/interfaces/server.GenericDatabaseWriter#delete) method.

<TSAndJSSnippet
  title="convex/tasks.ts"
  sourceTS={deleteExample}
  sourceJS={deleteExample}
  highlightPatterns={["db.delete"]}
/>

## Bulk inserts or updates

If you are used to SQL you might be looking for some sort of bulk insert or bulk
update statement. In Convex the entire `mutation` function is automatically a
single transaction.

You can just insert or update in a loop in the mutation function. Convex queues
up all database changes in the function and executes them all in a single
transaction when the function ends, leading to a single efficient change to the
database.

````typescript
/**
 * Bulk insert multiple products into the database.
 *
 * Equivalent to the SQL:
 * ```sql
 * INSERT INTO products (product_id, product_name, category, price, in_stock)
 * VALUES
 *     ('Laptop Pro', 'Electronics', 1299.99, true),
 *     ('Wireless Mouse', 'Electronics', 24.95, true),
 *     ('Ergonomic Keyboard', 'Electronics', 89.50, true),
 *     ('Ultra HD Monitor', 'Electronics', 349.99, false),
 *     ('Wireless Headphones', 'Audio', 179.99, true);
 * ```
 */
export const bulkInsertProducts = mutation({
  args: {
    products: v.array(
      v.object({
        product_name: v.string(),
        category: v.string(),
        price: v.number(),
        in_stock: v.boolean(),
      }),
    ),
  },
  handler: async (ctx, args) => {
    const { products } = args;

    // Insert in a loop. This is efficient because Convex queues all the changes
    // to be executed in a single transaction when the mutation ends.
    for (const product of products) {
      const id = await ctx.db.insert("products", {
        product_name: product.product_name,
        category: product.category,
        price: product.price,
        in_stock: product.in_stock,
      });
    }
  },
});
````

## Migrations

Database migrations are done through the migration component. The component is
designed to run online migrations to safely evolve your database schema over
time. It allows you to resume from failures, and validate changes with dry runs.

<ComponentCardList
  items={[
    {
      title: "Migrations",
      description: "Framework for long running data migrations of live data.",
      href: "https://www.convex.dev/components/migrations",
    },
  ]}
/>

## Write performance and limits

To prevent accidental writes of large amounts of records, queries and mutations
enforce limits detailed [here](/production/state/limits.mdx#transactions).



================================================
FILE: npm-packages/docs/docs/database/advanced/occ.md
================================================
---
title: "OCC and Atomicity"
slug: "occ"
hidden: false
sidebar_position: 500
todo: Push under mutations, or inline, or kill (move to Stack)
description:
  "Optimistic concurrency control and transaction atomicity in Convex"
---

In [Queries](/functions/query-functions.mdx), we mentioned that determinism was
important in the way optimistic concurrency control (OCC) was used within
Convex. In this section, we'll dive much deeper into _why_.

## Convex Financial, Inc.

Imagine that you're building a banking app, and therefore your databases stores
accounts with balances. You want your users to be able to give each other money,
so you write a mutation function that transfers funds from one user's account to
another.

One run of that transaction might read Alice's account balance, and then Bob's.
You then propose to deduct $5 from Alice's account and increase Bob's balance by
the same $5.

Here's our pseudocode:

```
$14 <- READ Alice
$11 <- READ Bob
WRITE Alice $9
WRITE Bob $16
```

This ledger balance transfer is a classic database scenario that requires a
guarantee that these write operations will only apply together. It is a really
bad thing if only one operation succeeds!

```
$14 <- READ Alice
$11 <- READ Bob
WRITE Alice $9
*crash* // $5 lost from your bank
```

You need a guarantee that this can never happen. You require transaction
atomicity, and Convex provides it.

The problem of data correctness is much deeper. Concurrent transactions that
read and edit the same records can create _data races_.

In the case of our app it's entirely possible that someone deducts Alice's
balance right after we read it. Maybe she bought a Coke Zero at the airport with
her debit card for $3.

```
$5 Transfer                           $3 Debit Card Charge
----------------------------------------------------------
$14 <- READ Alice
$11 <- READ Bob
                                        $14 <- READ Alice
                                        WRITE Alice $11
WRITE Alice $9 // Free coke!
WRITE Bob $16
```

Clearly, we need to prevent these types of data races from happening. We need a
way to handle these concurrent conflicts. Generally, there are two common
approaches.

Most traditional databases choose a _pessimistic locking_ strategy. (Pessimism
in this case means the strategy assumes conflict will happen ahead of time so
seeks to prevent it.) With pessimistic locking, you first need to acquire a lock
on Alice's record, and then acquire a lock on Bob's record. Then you can proceed
to conduct your transaction, knowing that any other transaction that needed to
touch those records will wait until you are done and all your writes are
committed.

After decades of experience, the drawbacks of pessimistic locking are well
understood and undeniable. The biggest limitation arises from real-life networks
and computers being inherently unreliable. If the lock holder goes missing for
whatever reason half way through its transaction, everyone else that wants to
modify any of those records is waiting indefinitely. Not good!

Optimistic concurrency control is, as the name states, optimistic. It assumes
the transaction will succeed and doesn't worry about locking anything ahead of
time. Very brash! How can it be so sure?

It does this by treating the transaction as a _declarative proposal_ to write
records on the basis of any read record versions (the "read set"). At the end of
the transaction, the writes all commit if every version in the read set is still
the latest version of that record. This means no concurrent conflict occurred.

Now using our version read set, let's see how OCC would have prevented the
soda-catastrophe above:

```
$5 Transfer                           $3 Debit Card Charge
----------------------------------------------------------
(v1, $14) <- READ Alice
(v7, $11) <- READ Bob
                                        (v1, $14) <- READ Alice
                                        WRITE Alice $11
                                        IF Alice.v = v1

WRITE Alice = $9, Bob = $16
    IF Alice.v = v1, Bob.v = v7 // Fails! Alice is = v2
```

This is akin to being unable to push your Git repository because you're not at
HEAD. We all know in that circumstance, we need to pull, and rebase or merge,
etc.

## When OCC loses, determinism wins

A naive optimistic concurrency control solution would be to solve this the same
way that Git does: require the user/application to resolve the conflict and
determine if it is safe to retry.

In Convex, however, we don't need to do that. We know the transaction is
deterministic. It didn't charge money to Stripe, it didn't write a permanent
value out to the filesystem. It had no effect at all other than proposing some
atomic changes to Convex tables that were not applied.

The determinism means that we can simply re-run the transaction; you never need
to worry about temporary data races. We can run several retries if necessary
until we succeed to execute the transaction without any conflicts.

<Admonition type="tip">

In fact, the Git analogy stays very apt. An OCC conflict means we cannot push
because our HEAD is out of date, so we need to rebase our changes and try again.
And determinism is what guarantees there is never a "merge conflict", so (unlike
with Git) this rebase operation will always eventually succeed without developer
intervention.

</Admonition>

## Snapshot Isolation vs Serializability

It is common for optimistic multi-version concurrency control databases to
provide a guarantee of
[snapshot isolation](https://en.wikipedia.org/wiki/Snapshot_isolation). This
[isolation level](<https://en.wikipedia.org/wiki/Isolation_(database_systems)>)
provides the illusion that all transactions execute on an atomic snapshot of the
data but it is vulnerable to
[anomalies](https://en.wikipedia.org/wiki/Snapshot_isolation#Definition) where
certain combinations of concurrent transactions can yield incorrect results. The
implementation of optimistic concurrency control in Convex instead provides true
[serializability](https://en.wikipedia.org/wiki/Serializability) and will yield
correct results regardless of what transactions are issued concurrently.

## No need to think about this

The beauty of this approach is that you can simply write your mutation functions
as if they will _always succeed_, and always be guaranteed to be atomic.

Aside from sheer curiosity about how Convex works, day to day there's no need to
worry about conflicts, locking, or atomicity when you make changes to your
tables and documents. The "obvious way" to write your mutation functions will
just work.



================================================
FILE: npm-packages/docs/docs/database/advanced/schema-philosophy.md
================================================
---
title: Schema Philosophy
sidebar_position: 450
description: "Convex schema design philosophy and best practices"
---

With Convex there is no need to write any `CREATE TABLE` statements, or think
through your stored table structure ahead of time so you can name your field and
types. You simply put your objects into Convex and keep building your app!

However, moving fast early can be problematic later. "Was that field a number or
a string? I think I changed it when I fixed that one bug?"

Storage systems which are too permissive can sometimes become liabilities as
your system matures and you want to be able to reason assuredly about exactly
what data is in your system.

The good news is Convex is always typed. It's just implicitly typed! When you
submit a document to Convex, tracks all the types of all the fields in your
document. You can go to your [dashboard](/dashboard.md) and view the inferred
schema of any table to understand what you've ended up with.

"What about that field I changed from a string to a number?" Convex can handle
this too. Convex will track those changes, in this case the field is a union
like `v.union(v.number(), v.string())`. That way even when you change your mind
about your documents fields and types, Convex has your back.

Once you are ready to formalize your schema, you can define it using our
[schema builder](/database/schemas.mdx) to enable schema validation and generate
types based on it.



================================================
FILE: npm-packages/docs/docs/database/advanced/system-tables.mdx
================================================
---
title: "System Tables"
sidebar_position: 1
description:
  "Access metadata for Convex built-in features through system tables including
  scheduled functions and file storage information."
---

System tables enable read-only access to metadata for built-in Convex features.
Currently there are two system tables exposed:

- `"_scheduled_functions"` table contains metadata for
  [scheduled functions](/scheduling/scheduled-functions.mdx#retrieving-scheduled-function-status)
- `"_storage"` table contains metadata for
  [stored files](/file-storage/file-metadata.mdx)

You can read data from system tables using the `db.system.get` and
`db.system.query` methods, which work the same as the standard `db.get` and
`db.query` methods. Queries reading from system tables are reactive and realtime
just like queries reading from all other tables, and pagination can be used to
enumerate all documents even when there are too many to read in a single query.



================================================
FILE: npm-packages/docs/docs/database/import-export/export.mdx
================================================
---
title: "Data Export"
sidebar_label: "Data Export"
description: "Export your data out of Convex"
sidebar_position: 168
---

You can export your data from Convex by
[taking a backup](/database/backup-restore) and downloading it as a zip file.

Alternatively, you can export the same data with the
[command line](/cli.md#export-data-to-a-file):

```sh
npx convex export --path ~/Downloads
```



================================================
FILE: npm-packages/docs/docs/database/import-export/import-export.mdx
================================================
---
title: "Data Import & Export"
sidebar_position: 90
description:
  "Import data from existing sources and export data to external systems"
---

If you're bootstrapping your app from existing data, Convex provides three ways
to get the data in:

- Import from csv/json into a single table via the
  [CLI](/database/import-export/import.mdx#single-table-import).
- Restore from a backup via the [dashboard](/database/backup-restore) or
  [CLI](/database/import-export/import.mdx#restore-data-from-a-backup-zip-file).
- [Streaming import](/production/integrations/streaming-import-export.md) from
  any existing database via Airbyte destination connector.

You can export data from Convex in two ways.

- Download a backup as a zip from the [dashboard](/database/backup-restore).
- Set up [streaming export](/production/integrations/streaming-import-export.md)
  to any external database via Fivetran or Airbyte. Great for connecting to a
  custom BI setup (eg [Snowflake](https://www.snowflake.com/),
  [Databricks](https://www.databricks.com), or
  [BigQuery](https://cloud.google.com/bigquery)):

<BetaAdmonition feature="Data Import & Export" verb="is" />



================================================
FILE: npm-packages/docs/docs/database/import-export/import.mdx
================================================
---
title: "Data Import"
sidebar_label: "Data Import"
description: "Import data into Convex"
sidebar_position: 169
---

You can import data into Convex from a local file using the command line.

```sh
npx convex import
```

<BetaAdmonition feature="Data import" verb="is" />

Use `--help` to see all options. The most common flows are described here.

## Single table import

```sh
npx convex import --table <tableName> <path>
```

Import a CSV, JSON, or JSONLines file into a Convex table.

- `.csv` files must have a header, and each row's entries are interpreted either
  as a (floating point) number or a string.
- `.jsonl` files must have a JSON object per line.
- `.json` files must be an array of JSON objects.
  - JSON arrays have a size limit of 8MiB. To import more data, use CSV or
    JSONLines. You can convert json to jsonl with a command like
    `jq -c '.[]' data.json > data.jsonl`

Imports into a table with existing data will fail by default, but you can
specify `--append` to append the imported rows to the table or `--replace` to
replace existing data in the table with your import.

The default is to import into your dev deployment. Use `--prod` to import to
your production deployment or `--preview-name` to import into a preview
deployment.

## Restore data from a backup ZIP file

```sh
npx convex import <path>.zip
```

Import from a [Backup](/database/backup-restore) into a Convex deployment, where
the backup is a ZIP file that has been downloaded on the dashboard. Documents
will retain their `_id` and `_creationTime` fields so references between tables
are maintained.

Imports where tables have existing data will fail by default, but you can
specify `--replace` to replace existing data in tables mentioned in the ZIP
file.

## Use cases

1. Seed dev deployments with sample data.

```sh
# full backup - exported from prod or another dev deployment.
npx convex import seed_data.zip

# Import single table from jsonl/csv
npx convex import --table <table name> data.jsonl
```

2. Restore a deployment from a [backup](/database/backup-restore)
   programmatically. Download a backup, and restore from this backup if needed.

```sh
npx convex import --prod --replace backup.zip
```

3. Seed preview deployments with sample data, exported from prod, dev, or
   another preview deployment. Example for Vercel, seeding data from
   `seed_data.zip` committed in the root of the repo.

```sh
npx convex deploy --cmd 'npm run build' &&
if [ "$VERCEL_ENV" == "preview" ]; then
npx convex import --preview-name "$VERCEL_GIT_COMMIT_REF" seed_data.zip;
fi
```

4. Clear a table efficiently with an empty import.

```sh
touch empty_file.jsonl
npx convex import --replace --table <tableNameToClear> empty_file.jsonl
```

## Features

- Data import is the only way to create documents with pre-existing `_id` and
  `_creationTime` fields.
  - The `_id` field must match Convex's ID format.
  - If `_id` or `_creationTime` are not provided, new values are chosen during
    import.
- Data import creates and replaces tables atomically (except when using
  `--append`).
  - Queries and mutations will not view intermediate states where partial data
    is imported.
  - Indexes and schemas will work on the new data without needing time for
    re-backfilling or re-validating.
- Data import only affects tables that are mentioned in the import, either by
  `--table` or as entries in the ZIP file.
- While JSON and JSONLines can import arbitrary JSON values, ZIP imports can
  additionally import other Convex values: Int64, Bytes, etc. Types are
  preserved in the ZIP file through the `generated_schema.jsonl` file.
- Data import of ZIP files that include [file storage](/file-storage) import the
  files and preserve [`_storage`](/database/advanced/system-tables.mdx)
  documents, including their `_id`, `_creationTime`, and `contentType` fields.

## Warnings

- [Streaming Export](/production/integrations/streaming-import-export.md)
  (Fivetran or Airbyte) does not handle data imports or backup restorations,
  similar to table deletion and creation and some schema changes. We recommend
  resetting streaming export sync after a restore or a data import.
- Avoid changing the ZIP file between downloading it from Data Export and
  importing it with `npx convex import`. Some manual changes of the ZIP file may
  be possible, but remain undocumented. Please share your use case and check
  with the Convex team in [Discord](https://convex.dev/community).
- Data import is not always supported when importing into a deployment that was
  created before Convex version 1.7.
  - The import may work, especially when importing a ZIP backup from a
    deployment created around the same time as the target deployment. As a
    special case, you can always restore from backups from its own deployment.
  - Reach out in [Discord](https://convex.dev/community) if you encounter
    issues, as there may be a workaround.

Data import uses database bandwidth to write all documents, and file bandwidth
if the export includes file storage. You can observe this bandwidth in the
[usage dashboard](https://dashboard.convex.dev/team/settings/usage) as function
name `_cli/import` and associated cost in the
[limits docs](/production/state/limits#database).



================================================
FILE: npm-packages/docs/docs/database/reading-data/filters.mdx
================================================
---
title: "Filters"
sidebar_position: 200
description: "Filter documents in Convex queries"
---

# Filtering

The [`filter`](/api/interfaces/server.Query#filter) method allows you to
restrict the documents that your document query returns. This method takes a
filter constructed by [`FilterBuilder`](/api/interfaces/server.FilterBuilder)
and will only select documents that match.

The examples below demonstrate some of the common uses of `filter`. You can see
the full list of available filtering methods
[in the reference docs](/api/interfaces/server.FilterBuilder).

If you need to filter to documents containing some keywords, use a
[search query](/search/text-search.mdx).

<Admonition type="caution" title="Use indexes instead">
  Filters effectively loop over your table looking for documents that match.
  This can be slow or cause your function to hit a
  [limit](/production/state/limits.mdx) when your table has thousands of rows.
  For faster more database efficient queries use [indexes
  instead](/database/reading-data/indexes/indexes.md).
</Admonition>

### Equality conditions

This document query finds documents in the `users` table where
`doc.name === "Alex"`:

```ts
// Get all users named "Alex".
const usersNamedAlex = await ctx.db
  .query("users")
  .filter((q) => q.eq(q.field("name"), "Alex"))
  .collect();
```

Here `q` is the [`FilterBuilder`](/api/interfaces/server.FilterBuilder) utility
object. It contains methods for all of our supported filter operators.

This filter will run on all documents in the table. For each document,
`q.field("name")` evaluates to the `name` property. Then `q.eq` checks if this
property is equal to `"Alex"`.

If your query references a field that is missing from a given document then that
field will be considered to have the value `undefined`.

### Comparisons

Filters can also be used to compare fields against values. This document query
finds documents where `doc.age >= 18`:

```ts
// Get all users with an age of 18 or higher.
const adults = await ctx.db
  .query("users")
  .filter((q) => q.gte(q.field("age"), 18))
  .collect();
```

Here the `q.gte` operator checks if the first argument (`doc.age`) is greater
than or equal to the second (`18`).

Here's the full list of comparisons:

| Operator      | Equivalent TypeScript |
| ------------- | --------------------- |
| `q.eq(l, r)`  | `l === r`             |
| `q.neq(l, r)` | `l !== r`             |
| `q.lt(l, r)`  | `l < r`               |
| `q.lte(l, r)` | `l <= r`              |
| `q.gt(l, r)`  | `l > r`               |
| `q.gte(l, r)` | `l >= r`              |

### Arithmetic

You can also include basic arithmetic in your queries. This document query finds
documents in the `carpets` table where `doc.height * doc.width > 100`:

```ts
// Get all carpets that have an area of over 100.
const largeCarpets = await ctx.db
  .query("carpets")
  .filter((q) => q.gt(q.mul(q.field("height"), q.field("width")), 100))
  .collect();
```

Here's the full list of arithmetic operators:

| Operator      | Equivalent TypeScript |
| ------------- | --------------------- |
| `q.add(l, r)` | `l + r`               |
| `q.sub(l, r)` | `l - r`               |
| `q.mul(l, r)` | `l * r`               |
| `q.div(l, r)` | `l / r`               |
| `q.mod(l, r)` | `l % r`               |
| `q.neg(x)`    | `-x`                  |

### Combining operators

You can construct more complex filters using methods like `q.and`, `q.or`, and
`q.not`. This document query finds documents where
`doc.name === "Alex" && doc.age >= 18`:

```ts
// Get all users named "Alex" whose age is at least 18.
const adultAlexes = await ctx.db
  .query("users")
  .filter((q) =>
    q.and(q.eq(q.field("name"), "Alex"), q.gte(q.field("age"), 18)),
  )
  .collect();
```

Here is a query that finds all users where
`doc.name === "Alex" || doc.name === "Emma"`:

```ts
// Get all users named "Alex" or "Emma".
const usersNamedAlexOrEmma = await ctx.db
  .query("users")
  .filter((q) =>
    q.or(q.eq(q.field("name"), "Alex"), q.eq(q.field("name"), "Emma")),
  )
  .collect();
```

## Advanced filtering techniques

Sometimes the filter syntax is is not expressive enough. For example you may
want to collect all posts that have a tag. Your schema for the posts looks like
this:

```ts
export default defineSchema({
  posts: defineTable({
    body: v.string(),
    tags: v.array(v.string()),
  }),
});
```

One way to solve is by applying the filter on the result of the `collect()`
call. This is just filtering a JavaScript array:

```ts
export const postsWithTag = query({
  args: { tag: v.string() },
  handler: async (ctx, args) => {
    const allPosts = await ctx.db.query("posts").collect();
    return allPosts.filter((post) => post.tags.includes(args.tag));
  },
});
```

But this requires reading the whole table first. If you want to just get the
first result that matches, reading the whole table could be very inefficient.
Instead you may want to use the JavaScript
[`for await...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)
syntax to loop through the table one document at a time:

```ts
export const firstPostWithTag = query({
  args: { tag: v.string() },
  handler: (ctx, args) => {
    for await (const post of db.query("posts")) {
      if (post.tags.includes(args.tag)) {
        return post;
      }
    }
  },
});
```

This works because Convex queries are
[JavaScript iterables](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).

Even with this optimization you are still just looping over the table to find
the first post that matches and may hit your function limits. Using indexes is
still the way to go. You can read a
[detailed discussion of how to handle tags with indexes](https://stack.convex.dev/complex-filters-in-convex#optimize-with-indexes).

## Querying performance and limits

Most of the example document queries above can lead to a _full table scan_. That
is, for the document query to return the requested results, it might need to
walk over every single document in the table.

Take this simple example:

```ts
const tasks = await ctx.db.query("tasks").take(5);
```

This document query will not scan more than 5 documents.

On the other hand, this document query:

```ts
const tasks = await ctx.db
  .query("tasks")
  .filter((q) => q.eq(q.field("isCompleted"), true))
  .first();
```

might need to walk over every single document in the `"tasks"` table just to
find the first one with `isCompleted: true`.

If a table has more than a few thousand documents, you should use
[indexes](/database/reading-data/indexes/indexes.md) to improve your document
query performance. Otherwise, you may run into our enforced limits, detailed in
[Read/write limit errors](/functions/error-handling/error-handling.mdx#readwrite-limit-errors).

For information on other limits, see [Limits](/production/state/limits.mdx).



================================================
FILE: npm-packages/docs/docs/database/reading-data/reading-data.mdx
================================================
---
title: "Reading Data"
sidebar_position: 3
description: "Query and read data from Convex database tables"
---

import getExample from "!!raw-loader!@site/../private-demos/snippets/convex/readingDataDbGet.ts";
import queryExample from "!!raw-loader!@site/../private-demos/snippets/convex/readingDataDbQuery.ts";
import averageExample from "!!raw-loader!@site/../private-demos/snippets/convex/readingDataAverage.ts";
import groupByExampleTS from "!!raw-loader!@site/../private-demos/snippets/convex/readingDataGroupByTS.ts";
import groupByExampleJS from "!!raw-loader!@site/../private-demos/snippets/convex/readingDataGroupByJS.js";
import joinExample from "!!raw-loader!@site/../private-demos/snippets/convex/readingDataJoin.ts";

[Query](/functions/query-functions.mdx) and
[mutation](/functions/mutation-functions.mdx) functions can read data from
database tables using _document ids_ and _document queries_.

## Reading a single document

Given a single document's id you can read its data with the
[`db.get`](/api/interfaces/server.GenericDatabaseReader#get) method:

<TSAndJSSnippet
  title="convex/tasks.ts"
  sourceTS={getExample}
  sourceJS={getExample}
  highlightPatterns={["db.get"]}
/>

**Note**: You should use the `v.id` validator like in the example above to make
sure you are not exposing data from tables other than the ones you intended.

## Querying documents

Document queries always begin by choosing the table to query with the
[`db.query`](/api/interfaces/server.GenericDatabaseReader#query) method:

<TSAndJSSnippet
  title="convex/tasks.ts"
  sourceTS={queryExample}
  sourceJS={queryExample}
  highlightPatterns={["db.query"]}
/>

Then you can:

1. filter
2. order
3. and `await` the results

We'll see how this works in the examples below.

## Filtering your query

The best way to filter in Convex is to use indexes. Indexes build a special
internal structure in your database to speed up lookups.

There are two steps to using indexes:

1. Define the index in your `convex/schema.ts` file.
2. Query via the `withIndex()` syntax.

### 1. Define the index

If you aren't familiar with how to create a Convex schema, read the
[schema doc](/database/schemas.mdx).

Let’s assume you’re building a chat app and want to get all messages in a
particular channel. You can define a new index called `by_channel` on the
`messages` table by using the `.index()` method in your schema.

```ts noDialect title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

// Define a messages table with an index.
export default defineSchema({
  messages: defineTable({
    channel: v.id("channels"),
    body: v.string(),
    user: v.id("users"),
    // highlight-next-line
  }).index("by_channel", ["channel"]),
});
```

### 2. Filter a query with an index

In your query function, you can now filter your `messages` table by using the
`by_channel` index.

```ts
const messages = await ctx.db
  .query("messages")
  // highlight-next-line
  .withIndex("by_channel", (q) => q.eq("channel", channel))
  .collect();
```

In Convex, you must explicitly use the `withIndex()` syntax to ensure your
database uses the index. This differs from a more traditional SQL database,
where the database implicitly chooses to use an index based on heuristics. The
Convex approach leads to fewer surprises in the long run.

You can create an index across multiple fields at once, query a specific range
of data, and change the order of your query result.
[Read the complete index documentation](/database/reading-data/indexes/indexes.md)
to learn more.

Convex also supports a slower filtering mechanism that effectively loops through
the table to match the filter. This can be useful if you know your table will be
small (low thousands of rows), you're prototyping, or you want to filter an
index query further. You can read more about filters
[here](/database/reading-data/filters.mdx).

## Ordering

By default Convex always returns documents ordered by
[`_creationTime`](/database/types.md#system-fields).

You can use [`.order("asc" | "desc")`](/api/interfaces/server.Query#order) to
pick whether the order is ascending or descending. If the order isn't specified,
it defaults to ascending.

```ts
// Get all messages, oldest to newest.
const messages = await ctx.db.query("messages").order("asc").collect();
```

```ts
// Get all messages, newest to oldest.
const messages = await ctx.db.query("messages").order("desc").collect();
```

If you need to sort on a field other than `_creationTime` and your document
query returns a small number of documents (on the order of hundreds rather than
thousands of documents), consider sorting in JavaScript:

```ts
// Get top 10 most liked messages, assuming messages is a fairly small table:
const messages = await ctx.db.query("messages").collect();
const topTenMostLikedMessages = recentMessages
  .sort((a, b) => b.likes - a.likes)
  .slice(0, 10);
```

For document queries that return larger numbers of documents, you'll want to use
an [index](/database/reading-data/indexes/indexes.md) to improve the
performance. Document queries that use indexes will be
[ordered based on the columns in the index](/database/reading-data/indexes/indexes.md#sorting-with-indexes)
and can avoid slow table scans.

```ts
// Get the top 20 most liked messages of all time, using the "by_likes" index.
const messages = await ctx.db
  .query("messages")
  .withIndex("by_likes")
  .order("desc")
  .take(20);
```

See [Limits](/database/reading-data/indexes/indexes.md#limits) for details.

### Ordering of different types of values

A single field can have values of any [Convex type](/database/types.md). When
there are values of different types in an indexed field, their ascending order
is as follows:

No value set&nbsp;(`undefined`) < Null&nbsp;(`null`) < Int64&nbsp;(`bigint`) <
Float64 (`number`) < Boolean&nbsp;(`boolean`) < String&nbsp;(`string`) <
Bytes&nbsp;(`ArrayBuffer`) < Array&nbsp;(`Array`) < Object&nbsp;(`Object`)

The same ordering is used by the filtering comparison operators `q.lt()`,
`q.lte()`, `q.gt()` and `q.gte()`.

## Retrieving results

Most of our previous examples have ended the document query with the
[`.collect()`](/api/interfaces/server.Query#collect) method, which returns all
the documents that match your filters. Here are the other options for retrieving
results.

### Taking `n` results

[`.take(n)`](/api/interfaces/server.Query#take) selects only the first `n`
results that match your query.

```ts
const users = await ctx.db.query("users").take(5);
```

### Finding the first result

[`.first()`](/api/interfaces/server.Query#first) selects the first document that
matches your query and returns `null` if no documents were found.

```ts
// We expect only one user with that email address.
const userOrNull = await ctx.db
  .query("users")
  .withIndex("by_email", (q) => q.eq("email", "test@example.com"))
  .first();
```

### Using a unique result

[`.unique()`](/api/interfaces/server.Query#unique) selects the single document
from your query or returns `null` if no documents were found. If there are
multiple results it will throw an exception.

```ts
// Our counter table only has one document.
const counterOrNull = await ctx.db.query("counter").unique();
```

### Loading a page of results

[`.paginate(opts)`](/api/interfaces/server.OrderedQuery#paginate) loads a page
of results and returns a [`Cursor`](/api/modules/server#cursor) for loading
additional results.

See [Paginated Queries](/database/pagination.mdx) to learn more.

## More complex queries

Convex prefers to have a few, simple ways to walk through and select documents
from tables. In Convex, there is no specific query language for complex logic
like a join, an aggregation, or a group by.

Instead, you can write the complex logic in JavaScript! Convex guarantees that
the results will be consistent.

### Join

Table join might look like:

<TSAndJSSnippet
  title="convex/events.ts"
  sourceTS={joinExample}
  sourceJS={joinExample}
/>

### Aggregation

Here's an example of computing an average:

<TSAndJSSnippet
  title="convex/purchases.ts"
  sourceTS={averageExample}
  sourceJS={averageExample}
/>

> If you need more scalable aggregate options (for example to handle frequent
> updates or large tables), consider using the
> [Sharded Counter](https://www.convex.dev/components/sharded-counter) or
> [Aggregate](https://www.convex.dev/components/aggregate) components. These
> components can help you handle high-throughput counters, sums, or computations
> without looping through the whole table.

### Group by

Here's an example of grouping and counting:

<TSAndJSSnippet
  title="convex/purchases.ts"
  sourceTS={groupByExampleTS}
  sourceJS={groupByExampleJS}
/>

## Explore the syntax on the dashboard

You can try out the syntax described above directly from the dashboard by
[writing a custom test query](/dashboard/deployments/data.md#writing-custom-queries).



================================================
FILE: npm-packages/docs/docs/database/reading-data/indexes/indexes-and-query-perf.md
================================================
---
sidebar_label: "Indexes and Query Performance"
title: "Introduction to Indexes and Query Performance"
sidebar_position: 100
description: "Learn the effects of indexes on query performance"
---

How do I ensure my Convex
[database queries](/database/reading-data/reading-data.mdx) are fast and
efficient? When should I define an
[index](/database/reading-data/indexes/indexes.md)? What is an index?

This document explains how you should think about query performance in Convex by
describing a simplified model of how queries and indexes function.

If you already have a strong understanding of database queries and indexes you
can jump straight to the reference documentation instead:

- [Reading Data](/database/reading-data/reading-data.mdx)
- [Indexes](/database/reading-data/indexes/indexes.md)

## A Library of Documents

You can imagine that Convex is a physical library storing documents as physical
books. In this world, every time you add a document to Convex with
[`db.insert("books", {...})`](/api/interfaces/server.GenericDatabaseWriter#insert)
a librarian places the book on a shelf.

By default, Convex organizes your documents in the order they were inserted. You
can imagine the librarian inserting documents left to right on a shelf.

If you run a query to find the first book like:

```ts
const firstBook = await ctx.db.query("books").first();
```

then the librarian could start at the left edge of the shelf and find the first
book. This is an extremely fast query because the librarian only has to look at
a single book to get the result.

Similarly, if we want to retrieve the last book that was inserted we could
instead do:

```ts
const lastBook = await ctx.db.query("books").order("desc").first();
```

This is the same query but we've swapped the order to descending. In the
library, this means that the librarian will start on the right edge of the shelf
and scan right-to-left. The librarian still only needs to look at a single book
to determine the result so this query is also extremely fast.

## Full Table Scans

Now imagine that someone shows up at the library and asks "what books do you
have by Jane Austen?"

This could be expressed as:

```ts
const books = await ctx.db
  .query("books")
  .filter((q) => q.eq(q.field("author"), "Jane Austen"))
  .collect();
```

This query is saying "look through all of the books, left-to-right, and collect
the ones where the `author` field is Jane Austen." To do this the librarian will
need to look through the entire shelf and check the author of every book.

This query is a _full table scan_ because it requires Convex to look at every
document in the table. The performance of this query is based on the number of
books in the library.

If your Convex table has a small number of documents, this is fine! Full table
scans should still be fast if there are a few hundred documents, but if the
table has many thousands of documents these queries will become slow.

In the library analogy, this kind of query is fine if the library has a single
shelf. As the library expands into a bookcase with many shelves or many
bookcases, this approach becomes infeasible.

## Card Catalogs

How can we more efficiently find books given an author?

One option is to re-sort the entire library by `author`. This will solve our
immediate problem but now our original queries for `firstBook` and `lastBook`
would become full table scans because we'd need to examine every book to see
which was inserted first/last.

Another option is to duplicate the entire library. We could purchase 2 copies of
every book and put them on 2 separate shelves: one shelf sorted by insertion
time and another sorted by author. This would work, but it's expensive. We now
need twice as much space for our library.

A better option is to build an _index_ on `author`. In the library, we could use
an old-school [card catalog](https://en.wikipedia.org/wiki/Library_catalog) to
organize the books by author. The idea here is that the librarian will write an
index card for each book that contains:

- The book's author
- The location of the book on the shelves

These index cards will be sorted by author and live in a separate organizer from
the shelves that hold the books. The card catalog should stay small because it
only has an index card per book (not the entire text of the book).

![Card Catalog](/img/card-catalog.jpg)

When a patron asks for "books by Jane Austen", the librarian can now:

1. Go to the card catalog and quickly find all of the cards for "Jane Austen".
2. For each card, go and find the book on the shelf.

This is quite fast because the librarian can quickly find the index cards for
Jane Austen. It's still a little bit of work to find the book for each card but
the number of index cards is small so this is quite fast.

## Indexes

Database indexes work based on the same concept! With Convex you can define an
_index_ with:

```ts noDialect title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  books: defineTable({
    author: v.string(),
    title: v.string(),
    text: v.string(),
  }).index("by_author", ["author"]),
});
```

then Convex will create a new index called `by_author` on `author`. This means
that your `books` table will now have an additional data structure that is
sorted by the `author` field.

You can query this index with:

```ts
const austenBooks = await ctx.db
  .query("books")
  .withIndex("by_author", (q) => q.eq("author", "Jane Austen"))
  .collect();
```

This query instructs Convex to go to the `by_author` index and find all the
entries where `doc.author === "Jane Austen"`. Because the index is sorted by
`author`, this is a very efficient operation. This means that Convex can execute
this query in the same manner that the librarian can:

1. Find the range of the index with entries for Jane Austen.
2. For each entry in that range, get the corresponding document.

The performance of this query is based on the number of documents where
`doc.author === "Jane Austen"` which should be quite small. We've dramatically
sped up the query!

## Backfilling and Maintaining Indexes

One interesting detail to think about is the work needed to create this new
structure. In the library, the librarian must go through every book on the shelf
and put a new index card for each one in the card catalog sorted by author. Only
after that can the librarian trust that the card catalog will give it correct
results.

The same is true for Convex indexes! When you define a new index, the first time
you run `npx convex deploy` Convex will need to loop through all of your
documents and index each one. This is why the first deploy after the creation of
a new index will be slightly slower than normal; Convex has to do a bit of work
for each document in your table. If the table is particularly large, consider
using a [staged index](/database/reading-data/indexes#staged-indexes) to
complete the backfill asynchronously from the deploy.

Similarly, even after an index is defined, Convex will have to do a bit of extra
work to keep this index up to date as the data changes. Every time a document is
inserted, updated, or deleted in an indexed table, Convex will also update its
index entry. This is analogous to a librarian creating new index cards for new
books as they add them to the library.

If you are defining a few indexes there is no need to worry about the
maintenance cost. As you define more indexes, the cost to maintain them grows
because every `insert` needs to update every index. This is why Convex has a
limit of 32 indexes per table. In practice most applications define a handful of
indexes per table to make their important queries efficient.

## Indexing Multiple Fields

Now imagine that a patron shows up at the library and would like to check out
_Foundation_ by Isaac Asimov. Given our index on `author`, we can write a query
that uses the index to find all the books by Isaac Asimov and then examines the
title of each book to see if it's _Foundation_.

```ts
const foundation = await ctx.db
  .query("books")
  .withIndex("by_author", (q) => q.eq("author", "Isaac Asimov"))
  .filter((q) => q.eq(q.field("title"), "Foundation"))
  .unique();
```

This query describes how a librarian might execute the query. The librarian will
use the card catalog to find all of the index cards for Isaac Asimov's books.
The cards themselves don't have the title of the book so the librarian will need
to find every Asimov book on the shelves and look at its title to find the one
named _Foundation_. Lastly, this query ends with
[`.unique`](/api/interfaces/server.Query#unique) because we expect there to be
at most one result.

This query demonstrates the difference between filtering using
[`withIndex`](/api/interfaces/server.QueryInitializer#withindex) and
[`filter`](/api/interfaces/server.Query#filter). `withIndex` only allows you to
restrict your query based on the index. You can only do operations that the
index can do efficiently like finding all documents with a given author.

`filter` on the other hand allows you to write arbitrary, complex expressions
but it won't be run using the index. Instead, `filter` expressions will be
evaluated on every document in the range.

Given all of this, we can conclude that **the performance of indexed queries is
based on how many documents are in the index range**. In this case, the
performance is based on the number of Isaac Asimov books because the librarian
will need to look at each one to examine its title.

Unfortunately, Isaac Asimov wrote
[a lot of books](<https://en.wikipedia.org/wiki/Isaac_Asimov_bibliography_(alphabetical)>).
Realistically even with 500+ books, this will be fast enough on Convex with the
existing index, but let's consider how we could improve it anyway.

One approach is to build a separate `by_title` index on `title`. This could let
us swap the work we do in `.filter` and `.withIndex` to instead be:

```ts
const foundation = await ctx.db
  .query("books")
  .withIndex("by_title", (q) => q.eq("title", "Foundation"))
  .filter((q) => q.eq(q.field("author"), "Isaac Asimov"))
  .unique();
```

In this query, we're efficiently using the index to find all the books called
_Foundation_ and then filtering through to find the one by Isaac Asimov.

This is okay, but we're still at risk of having a slow query because too many
books have a title of _Foundation_. An even better approach could be to build a
_compound_ index that indexes both `author` and `title`. Compound indexes are
indexes on an ordered list of fields.

```ts noDialect title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  books: defineTable({
    author: v.string(),
    title: v.string(),
    text: v.string(),
  }).index("by_author_title", ["author", "title"]),
});
```

In this index, books are sorted first by the author and then within each author
by title. This means that a librarian can use the index to jump to the Isaac
Asimov section and quickly find _Foundation_ within it.

Expressing this as a Convex query this looks like:

```ts
const foundation = await ctx.db
  .query("books")
  .withIndex("by_author_title", (q) =>
    q.eq("author", "Isaac Asimov").eq("title", "Foundation"),
  )
  .unique();
```

Here the index range expression tells Convex to only consider documents where
the author is Isaac Asimov and the title is _Foundation_. This is only a single
document so this query will be quite fast!

Because this index sorts by `author` and then by `title`, it also efficiently
supports queries like "All books by Isaac Asimov that start with F." We could
express this as:

```ts
const asimovBooksStartingWithF = await ctx.db
  .query("books")
  .withIndex("by_author_title", (q) =>
    q.eq("author", "Isaac Asimov").gte("title", "F").lt("title", "G"),
  )
  .collect();
```

This query uses the index to find books where
`author === "Isaac Asimov" && "F" <= title < "G"`. Once again, the performance
of this query is based on how many documents are in the index range. In this
case, that's just the Asimov books that begin with "F" which is quite small.

Also note that this index also supports our original query for "books by Jane
Austen." It's okay to only use the `author` field in an index range expression
and not restrict by title at all.

Lastly, imagine that a library patron asks for the book _The Three-Body Problem_
but they don't know the author's name. Our `by_author_title` index won't help us
here because it's sorted first by `author`, and then by `title`. The title, _The
Three-Body Problem_, could appear anywhere in the index!

The Convex TypeScript types in the `withIndex` make this clear because they
require that you compare index fields in order. Because the index is defined on
`["author", "title"]`, you must first compare the `author` with `.eq` before the
`title`.

In this case, the best option is probably to create the separate `by_title`
index to facilitate this query.

## Conclusions

Congrats! You now understand how queries and indexes work within Convex!

Here are the main points we've covered:

1. By default Convex queries are _full table scans_. This is appropriate for
   prototyping and querying small tables.
2. As your tables grow larger, you can improve your query performance by adding
   _indexes_. Indexes are separate data structures that order your documents for
   fast querying.
3. In Convex, queries use the _`withIndex`_ method to express the portion of the
   query that uses the index. The performance of a query is based on how many
   documents are in the index range expression.
4. Convex also supports _compound indexes_ that index multiple fields.

To learn more about queries and indexes, check out our reference documentation:

- [Reading Data](/database/reading-data/reading-data.mdx)
- [Indexes](/database/reading-data/indexes/indexes.md)



================================================
FILE: npm-packages/docs/docs/database/reading-data/indexes/indexes.md
================================================
---
title: "Indexes"
sidebar_position: 100
description: "Speed up queries with database indexes"
---

Indexes are a data structure that allow you to speed up your
[document queries](/database/reading-data/reading-data.mdx#querying-documents)
by telling Convex how to organize your documents. Indexes also allow you to
change the order of documents in query results.

For a more in-depth introduction to indexing see
[Indexes and Query Performance](/database/reading-data/indexes/indexes-and-query-perf.md).

## Defining indexes

Indexes are defined as part of your Convex [schema](/database/schemas.mdx). Each
index consists of:

1. A name.
   - Must be unique per table.
2. An ordered list of fields to index.
   - To specify a field on a nested document, use a dot-separated path like
     `properties.name`.

To add an index onto a table, use the
[`index`](/api/classes/server.TableDefinition#index) method on your table's
schema:

```ts noDialect title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

// Define a messages table with two indexes.
export default defineSchema({
  messages: defineTable({
    channel: v.id("channels"),
    body: v.string(),
    user: v.id("users"),
  })
    .index("by_channel", ["channel"])
    .index("by_channel_user", ["channel", "user"]),
});
```

The `by_channel` index is ordered by the `channel` field defined in the schema.
For messages in the same channel, they are ordered by the
[system-generated `_creationTime` field](/database/types.md#system-fields) which
is added to all indexes automatically.

By contrast, the `by_channel_user` index orders messages in the same `channel`
by the `user` who sent them, and only then by `_creationTime`.

Indexes are created in [`npx convex dev`](/cli.md#run-the-convex-dev-server) and
[`npx convex deploy`](/cli.md#deploy-convex-functions-to-production).

You may notice that the first deploy that defines an index is a bit slower than
normal. This is because Convex needs to _backfill_ your index. The more data in
your table, the longer it will take Convex to organize it in index order. If you
need to add indexes to large tables, use a [staged index](#staged-indexes).

You can feel free to query an index in the same deploy that defines it. Convex
will ensure that the index is backfilled before the new query and mutation
functions are registered.

<Admonition type="caution" title="Be careful when removing indexes">

In addition to adding new indexes, `npx convex deploy` will delete indexes that
are no longer present in your schema. Make sure that your indexes are completely
unused before removing them from your schema!

</Admonition>

## Querying documents using indexes

A query for "messages in `channel` created 1-2 minutes ago" over the
`by_channel` index would look like:

```ts
const messages = await ctx.db
  .query("messages")
  .withIndex("by_channel", (q) =>
    q
      .eq("channel", channel)
      .gt("_creationTime", Date.now() - 2 * 60000)
      .lt("_creationTime", Date.now() - 60000),
  )
  .collect();
```

The [`.withIndex`](/api/interfaces/server.QueryInitializer#withindex) method
defines which index to query and how Convex will use that index to select
documents. The first argument is the name of the index and the second is an
_index range expression_. An index range expression is a description of which
documents Convex should consider when running the query.

The choice of index both affects how you write the index range expression and
what order the results are returned in. For instance, by making both a
`by_channel` and `by_channel_user` index, we can get results within a channel
ordered by `_creationTime` or by `user`, respectively. If you were to use the
`by_channel_user` index like this:

```ts
const messages = await ctx.db
  .query("messages")
  .withIndex("by_channel_user", (q) => q.eq("channel", channel))
  .collect();
```

The results would be all of the messages in a `channel` ordered by `user`, then
by `_creationTime`. If you were to use `by_channel_user` like this:

```ts
const messages = await ctx.db
  .query("messages")
  .withIndex("by_channel_user", (q) =>
    q.eq("channel", channel).eq("user", user),
  )
  .collect();
```

The results would be the messages in the given `channel` sent by `user`, ordered
by `_creationTime`.

An index range expression is always a chained list of:

1. 0 or more equality expressions defined with
   [`.eq`](/api/interfaces/server.IndexRangeBuilder#eq).
2. [Optionally] A lower bound expression defined with
   [`.gt`](/api/interfaces/server.IndexRangeBuilder#gt) or
   [`.gte`](/api/interfaces/server.IndexRangeBuilder#gte).
3. [Optionally] An upper bound expression defined with
   [`.lt`](/api/interfaces/server.IndexRangeBuilder#lt) or
   [`.lte`](/api/interfaces/server.IndexRangeBuilder#lte).

**You must step through fields in index order.**

Each equality expression must compare a different index field, starting from the
beginning and in order. The upper and lower bounds must follow the equality
expressions and compare the next field.

For example, it is not possible to write a query like:

```ts
// DOES NOT COMPILE!
const messages = await ctx.db
  .query("messages")
  .withIndex("by_channel", (q) =>
    q
      .gt("_creationTime", Date.now() - 2 * 60000)
      .lt("_creationTime", Date.now() - 60000),
  )
  .collect();
```

This query is invalid because the `by_channel` index is ordered by
`(channel, _creationTime)` and this query range has a comparison on
`_creationTime` without first restricting the range to a single `channel`.
Because the index is sorted first by `channel` and then by `_creationTime`, it
isn't a useful index for finding messages in all channels created 1-2 minutes
ago. The TypeScript types within `withIndex` will guide you through this.

To better understand what queries can be run over which indexes, see
[Introduction to Indexes and Query Performance](/database/reading-data/indexes/indexes-and-query-perf.md).

**The performance of your query is based on the specificity of the range.**

For example, if the query is

```ts
const messages = await ctx.db
  .query("messages")
  .withIndex("by_channel", (q) =>
    q
      .eq("channel", channel)
      .gt("_creationTime", Date.now() - 2 * 60000)
      .lt("_creationTime", Date.now() - 60000),
  )
  .collect();
```

then query's performance would be based on the number of messages in `channel`
created 1-2 minutes ago.

If the index range is not specified, all documents in the index will be
considered in the query.

<Admonition type="tip" title="Picking a good index range">

For performance, define index ranges that are as specific as possible! If you
are querying a large table and you're unable to add any equality conditions with
`.eq`, you should consider defining a new index.

</Admonition>

`.withIndex` is designed to only allow you to specify ranges that Convex can
efficiently use your index to find. For all other filtering you can use the
[`.filter`](/api/interfaces/server.Query#filter) method.

For example to query for "messages in `channel` **not** created by me" you could
do:

```ts
const messages = await ctx.db
  .query("messages")
  .withIndex("by_channel", (q) => q.eq("channel", channel))
  .filter((q) => q.neq(q.field("user"), myUserId))
  .collect();
```

In this case the performance of this query will be based on how many messages
are in the channel. Convex will consider each message in the channel and only
return the messages where the `user` field doesn't match `myUserId`.

## Sorting with indexes

Queries that use `withIndex` are ordered by the columns specified in the index.

The order of the columns in the index dictates the priority for sorting. The
values of the columns listed first in the index are compared first. Subsequent
columns are only compared as tie breakers only if all earlier columns match.

Since Convex automatically includes `_creationTime` as the last column in all
indexes, `_creationTime` will always be the final tie breaker if all other
columns in the index are equal.

For example, `by_channel_user` includes `channel`, `user`, and `_creationTime`.
So queries on `messages` that use `.withIndex("by_channel_user")` will be sorted
first by channel, then by user within each channel, and finally by the creation
time.

Sorting with indexes allows you to satisfy use cases like displaying the top `N`
scoring users, the most recent `N` transactions, or the most `N` liked messages.

For example, to get the top 10 highest scoring players in your game, you might
define an index on the player's highest score:

```ts
export default defineSchema({
  players: defineTable({
    username: v.string(),
    highestScore: v.number(),
  }).index("by_highest_score", ["highestScore"]),
});
```

You can then efficiently find the top 10 highest scoring players using your
index and [`take(10)`](/api/interfaces/server.Query#take):

```ts
const topScoringPlayers = await ctx.db
  .query("users")
  .withIndex("by_highest_score")
  .order("desc")
  .take(10);
```

In this example, the range expression is omitted because we're looking for the
highest scoring players of all time. This particular query is reasonably
efficient for large data sets only because we're using `take()`.

If you use an index without a range expression, you should always use one of the
following in conjunction with `withIndex`:

1. [`.first()`](/api/interfaces/server.Query#first)
2. [`.unique()`](/api/interfaces/server.Query#unique)
3. [`.take(n)`](/api/interfaces/server.Query#take)
4. [`.paginate(ops)`](/database/pagination.mdx)

These APIs allow you to efficiently limit your query to a reasonable size
without performing a full table scan.

<Admonition type="caution" title="Full Table Scans">

When your query fetches documents from the database, it will scan the rows in
the range you specify. If you are using `.collect()`, for instance, it will scan
all of the rows in the range. So if you use `withIndex` without a range
expression, you will be
[scanning the whole table](https://docs.convex.dev/database/indexes/indexes-and-query-perf#full-table-scans),
which can be slow when your table has thousands of rows. `.filter()` doesn't
affect which documents are scanned. Using `.first()` or `.unique()` or
`.take(n)` will only scan rows until it has enough documents.

</Admonition>

You can include a range expression to satisfy more targeted queries. For
example, to get the top scoring players in Canada, you might use both `take()`
and a range expression:

```ts
// query the top 10 highest scoring players in Canada.
const topScoringPlayers = await ctx.db
  .query("users")
  .withIndex("by_country_highest_score", (q) => q.eq("country", "CA"))
  .order("desc")
  .take(10);
```

## Staged indexes

By default, index creation happens synchronously when you deploy code. For large
tables, the process of
[backfilling the index](indexes-and-query-perf#backfilling-and-maintaining-indexes)
for the existing table can be slow. Staged indexes are a way to create an index
on a large table asynchronously without blocking deploy. This can be useful if
you are working on multiple features at once.

To create a staged index, use the following syntax in your `schema.ts`.

```ts
export default defineSchema({
  messages: defineTable({
    channel: v.id("channels"),
  }).index("by_channel", { fields: ["channel"], staged: true }),
});
```

<Admonition type="caution" title="Staged indexes cannot be used until enabled">

Staged indexes cannot be used in queries until you enable them. To enable them,
they must first finish backfilling.

</Admonition>

You can check the backfill progress via the
[_Indexes_ pane](/dashboard/deployments/data/#view-the-indexes-of-a-table) on
the dashboard data page. Once it is complete, you can enable the index and use
it by removing the `staged` option.

```ts
export default defineSchema({
  messages: defineTable({
    channel: v.id("channels"),
  }).index("by_channel", { fields: ["channel"] }),
});
```

## Limits

Convex supports indexes containing up to 16 fields. You can define 32 indexes on
each table. Indexes can't contain duplicate fields.

No reserved fields (starting with `_`) are allowed in indexes. The
`_creationTime` field is automatically added to the end of every index to ensure
a stable ordering. It should not be added explicitly in the index definition,
and it's counted towards the index fields limit.

The `by_creation_time` index is created automatically (and is what is used in
database queries that don't specify an index). The `by_id` index is reserved.



================================================
FILE: npm-packages/docs/docs/file-storage/delete-files.mdx
================================================
---
title: "Deleting Files"
sidebar_label: "Delete"
sidebar_position: 4
description: "Delete files stored in Convex"
---

import DeleteImage from "!!raw-loader!@site/../private-demos/snippets/convex/deletingFiles.ts";

Files stored in Convex can be deleted from
[mutations](/functions/mutation-functions.mdx),
[actions](/functions/actions.mdx), and
[HTTP actions](/functions/http-actions.mdx) via the
[`storage.delete()`](/api/interfaces/server.StorageWriter#delete) function,
which accepts a storage ID.

Storage IDs correspond to documents in the `"_storage"` system table (see
[Metadata](/file-storage/file-metadata.mdx)), so they can be validated using the
`v.id("_storage")`.

<TSAndJSSnippet
  title="convex/images.ts"
  sourceTS={DeleteImage}
  sourceJS={DeleteImage}
  highlightPatterns={["delete\\("]}
/>



================================================
FILE: npm-packages/docs/docs/file-storage/file-metadata.mdx
================================================
---
title: "Accessing File Metadata"
sidebar_label: "Metadata"
sidebar_position: 5
description: "Access file metadata stored in Convex"
---

import FileMetadata from "!!raw-loader!@site/../private-demos/snippets/convex/imagesMetadata.ts";
import FileMetadataDeprecated from "!!raw-loader!@site/../private-demos/snippets/convex/fileMetadata.ts";

Every stored file is reflected as a document in the `"_storage"` system table.
File metadata of a file can be accessed from
[queries](/functions/query-functions.mdx) and
[mutations](/functions/mutation-functions.mdx) via `db.system.get` and
`db.system.query`:

<TSAndJSSnippet
  title="convex/images.ts"
  sourceTS={FileMetadata}
  sourceJS={FileMetadata}
  highlightPatterns={["db.system.get\\(", "db.system.query\\("]}
/>

This is an example of the returned document:

```json
{
  "_creationTime": 1700697415295.742,
  "_id": "3k7ty84apk2zy00ay4st1n5p9kh7tf8",
  "contentType": "image/jpeg",
  "sha256": "cb58f529b2ed5a1b8b6681d91126265e919ac61fff6a367b8341c0f46b06a5bd",
  "size": 125338
}
```

The returned document has the following fields:

- `sha256`: a base16 encoded sha256 checksum of the file contents
- `size`: the size of the file in bytes
- `contentType`: the `ContentType` of the file if it was provided on upload

You can check the metadata manually on your
[dashboard](/dashboard/deployments/files.md).

## Accessing metadata from actions (deprecated)

Alternatively, a
[`storage.getMetadata()`](/api/interfaces/server.StorageReader#getmetadata)
function is available to access individual file metadata from
[actions](/functions/actions.mdx) and
[HTTP actions](/functions/http-actions.mdx):

<TSAndJSSnippet
  title="convex/images.ts"
  sourceTS={FileMetadataDeprecated}
  sourceJS={FileMetadataDeprecated}
  highlightPatterns={["getMetadata\\("]}
/>

Note that
[`storage.getMetadata()`](/api/interfaces/server.StorageReader#getmetadata)
returns a [`FileMetadata`](/api/modules/server#filemetadata), which has a
slightly different shape than the result from `db.system.get`.



================================================
FILE: npm-packages/docs/docs/file-storage/serve-files.mdx
================================================
---
title: "Serving Files"
sidebar_label: "Serve"
sidebar_position: 3
description: "Serve files stored in Convex to users"
---

import Messages from "!!raw-loader!@site/../demos/file-storage/convex/messages.ts";
import AppTS from "!!raw-loader!@site/../demos/file-storage/src/App.tsx";
import AppJS from "!!raw-loader!@site/../private-demos/snippets/src/fileStorageApp.jsx";
import Http from "!!raw-loader!@site/../demos/file-storage-with-http/convex/http.ts";
import HttpAppTS from "!!raw-loader!@site/../demos/file-storage-with-http/src/App.tsx";
import HttpAppJS from "!!raw-loader!@site/../private-demos/snippets/src/fileStorageWithHttpImage.jsx";

Files stored in Convex can be served to your users by generating a URL pointing
to a given file.

## Generating file URLs in queries

The simplest way to serve files is to return URLs along with other data required
by your app from [queries](/functions/query-functions.mdx) and
[mutations](/functions/mutation-functions.mdx).

A file URL can be generated from a storage ID by the
[`storage.getUrl`](/api/interfaces/server.StorageReader#geturl) function of the
[`QueryCtx`](/api/interfaces/server.GenericQueryCtx),
[`MutationCtx`](/api/interfaces/server.GenericMutationCtx), or
[`ActionCtx`](/api/interfaces/server.GenericActionCtx) object:

<TSAndJSSnippet
  title="convex/listMessages.ts"
  sourceTS={Messages}
  sourceJS={Messages}
  snippet="query"
  highlightPatterns={["storage.getUrl"]}
/>

File URLs can be used in `img` elements to render images:

<TSAndJSSnippet
  title="src/App.tsx"
  sourceTS={AppTS}
  sourceJS={AppJS}
  snippet="imageComponent"
/>

In your query you can control who gets access to a file when the URL is
generated. If you need to control access when the file is _served_, you can
define your own file serving HTTP actions instead.

## Serving files from HTTP actions

You can serve files directly from [HTTP actions](/functions/http-actions.mdx).
An HTTP action will need to take some parameter(s) that can be mapped to a
storage ID, or a storage ID itself.

This enables access control at the time the file is served, such as when an
image is displayed on a website. But note that the HTTP actions response size is
[currently limited](/functions/http-actions.mdx#limits) to 20MB. For larger
files you need to use file URLs as described
[above](#generating-file-urls-in-queries).

A file [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object
can be generated from a storage ID by the
[`storage.get`](/api/interfaces/server.StorageActionWriter#get) function of the
[`ActionCtx`](/api/interfaces/server.GenericActionCtx) object, which can be
returned in a `Response`:

<TSAndJSSnippet title="convex/http.ts" sourceTS={Http} sourceJS={Http} snippet="getImage"
highlightPatterns={["storage.get"]} prefix={
    `import { httpRouter } from "convex/server";
import { httpAction } from "./\_generated/server";
import { Id } from "./\_generated/dataModel";

const http = httpRouter();\

`} suffix={"\nexport default http;"} />

The URL of such an action can be used directly in `img` elements to render
images:

<TSAndJSSnippet
  title="src/App.tsx"
  sourceTS={HttpAppTS}
  sourceJS={HttpAppJS}
  snippet="getImage"
/>



================================================
FILE: npm-packages/docs/docs/file-storage/store-files.mdx
================================================
---
title: "Storing Generated Files"
sidebar_label: "Store"
sidebar_position: 2
description: "Store files generated in Convex actions"
---

import StoreImageTS from "!!raw-loader!@site/../private-demos/snippets/convex/images.ts";
import StoreImageJS from "!!raw-loader!@site/../private-demos/snippets/convex/imagesJS.js";

Files can be uploaded to Convex from a client and stored directly, see
[Upload](/file-storage/upload-files.mdx).

Alternatively files can also be stored after they've been fetched or generated
in [actions](/functions/actions.mdx) and
[HTTP actions](/functions/http-actions.mdx). For example you might call a
third-party API to generate an image based on a user prompt and then store that
image in Convex.

**Example:**
[Dall-E Storage & Action](https://github.com/get-convex/convex-demos/tree/main/dall-e-storage-action)

## Storing files in actions

Storing files in actions is similar to
[uploading a file via an HTTP action](/file-storage/upload-files.mdx#uploading-files-via-an-http-action).

The action takes these steps:

1. Fetch or generate an image.
2. Store the image using
   [`storage.store()`](/api/interfaces/server.StorageActionWriter#store) and
   receive a storage ID.
3. Save the storage ID into your data model via a mutation.

Storage IDs correspond to documents in the `"_storage"` system table (see
[Metadata](/file-storage/file-metadata.mdx)), so they can be validated using the
`v.id("_storage")` validator and typed as `Id<"_storage">` in TypeScript.

<TSAndJSSnippet
  title="convex/images.ts"
  sourceTS={StoreImageTS}
  sourceJS={StoreImageJS}
  highlightPatterns={["fetch", "storage.store", "runMutation\\("]}
/>



================================================
FILE: npm-packages/docs/docs/file-storage/upload-files.mdx
================================================
---
title: "Uploading and Storing Files"
sidebar_label: "Upload"
sidebar_position: 1
description: "Upload files to Convex storage"
---

import Messages from "!!raw-loader!@site/../demos/file-storage/convex/messages.ts";
import URLUploadTS from "!!raw-loader!@site/../demos/file-storage/src/_simpleApp.tsx";
import URLUploadJS from "!!raw-loader!@site/../private-demos/snippets/src/fileStorageApp.jsx";
import HttpAction from "!!raw-loader!@site/../demos/file-storage-with-http/convex/http.ts";
import HttpUploadTS from "!!raw-loader!@site/../demos/file-storage-with-http/src/_simpleApp.tsx";
import HttpUploadJS from "!!raw-loader!@site/../private-demos/snippets/src/fileStorageWithHttpApp.jsx";

Upload files to Convex by
[generated upload urls](#uploading-files-via-upload-urls), or via an
[custom HTTP Action](#uploading-files-via-an-http-action).

## Uploading files via upload URLs

Arbitrarily large files can be uploaded directly to your backend using a
generated upload URL. This requires the client to make 3 requests:

1. Generate an upload URL using a mutation that calls
   [`storage.generateUploadUrl()`](/api/interfaces/server.StorageWriter#generateuploadurl).
2. Send a POST request with the file contents to the upload URL and receive a
   storage ID.
3. Save the storage ID into your data model via another mutation.

In the first mutation that generates the upload URL you can control who can
upload files to your Convex storage.

**Example**:
[File Storage with Queries and Mutations](https://github.com/get-convex/convex-demos/tree/main/file-storage)

### Calling the upload APIs from a web page

Here's an example of uploading an image via a form submission handler to an
upload URL generated by a mutation:

<TSAndJSSnippet
  title="src/App.jsx"
  sourceTS={URLUploadTS}
  sourceJS={URLUploadJS}
  snippet="fileUpload"
  highlightPatterns={[
    "generateUploadUrl\\(",
    "sendImage\\(",
    "await fetch",
    "method:",
    "headers:",
    "body:",
    "}\\);",
  ]}
/>

### Generating the upload URL

An upload URL can be generated by the
[`storage.generateUploadUrl`](/api/interfaces/server.StorageWriter#generateuploadurl)
function of the [`MutationCtx`](/api/interfaces/server.GenericMutationCtx)
object:

<TSAndJSSnippet
  title="convex/messages.js"
  sourceTS={Messages}
  sourceJS={Messages}
  snippet="generateUploadUrl"
  highlightPatterns={["storage.generateUploadUrl"]}
/>

This mutation can control who is allowed to upload files.

The upload URL expires in 1 hour and so should be fetched shortly before the
upload is made.

### Writing the new storage ID to the database

Since the storage ID is returned to the client it is likely you will want to
persist it in the database via another mutation:

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={Messages}
  sourceJS={Messages}
  prefix={`import { mutation } from "./_generated/server";\n`}
  snippet="saveStorageId"
  highlightPatterns={["storage.generateUploadUrl"]}
/>

### Limits

The file size is not limited, but upload POST request has a 2 minute timeout.

## Uploading files via an HTTP action

The file upload process can be more tightly controlled by leveraging
[HTTP action](/functions/http-actions.mdx)s, performing the whole upload flow
using a single request, but requiring correct CORS headers configuration.

The custom upload HTTP action can control who can upload files to your Convex
storage. But note that the HTTP action request size is
[currently limited](/functions/http-actions.mdx#limits) to 20MB. For larger
files you need to use upload URLs as described
[above](#uploading-files-via-upload-urls).

**Example:**
[File Storage with HTTP Actions](https://github.com/get-convex/convex-demos/tree/main/file-storage-with-http)

### Calling the upload HTTP action from a web page

Here's an example of uploading an image via a form submission handler to the
`sendImage` HTTP action defined next.

The highlighted lines make the actual request to the HTTP action:

<TSAndJSSnippet
  title="src/App.tsx"
  sourceTS={HttpUploadTS}
  sourceJS={HttpUploadJS}
  snippet="httpFileUpload"
  highlightPatterns={["fetch", "method:", "headers:", "body:", "}\\);"]}
/>

### Defining the upload HTTP action

A file sent in the HTTP request body can be stored using the
[`storage.store`](/api/interfaces/server.StorageActionWriter#store) function of
the [`ActionCtx`](/api/interfaces/server.GenericActionCtx) object. This function
returns an `Id<"_storage">` of the stored file.

From the HTTP action you can call a mutation to write the storage ID to a
document in your database.

To confirm success back to your hosted website, you will need to set the right
[CORS headers](/functions/http-actions.mdx#cors):

<TSAndJSSnippet
  title="convex/http.js"
  sourceTS={HttpAction}
  sourceJS={HttpAction}
  snippet="sendImageStore"
  highlightPatterns={["storage.store"]}
/>

You also need to handle the pre-flight `OPTIONS` request:

<TSAndJSSnippet
  title="convex/http.js"
  sourceTS={HttpAction}
  sourceJS={HttpAction}
  snippet="preflight"
  highlightPatterns={["storage.store"]}
/>



================================================
FILE: npm-packages/docs/docs/functions/actions.mdx
================================================
---
title: Actions
sidebar_position: 30
description: "Call third-party services and external APIs from Convex"
---

import { ComponentCardList } from "@site/src/components/ComponentCard";
import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/actionsConstructor.ts";
import ArgsWithValidation from "!!raw-loader!@site/../private-demos/snippets/convex/actionsArgsWithValidation.ts";
import Context from "!!raw-loader!@site/../private-demos/snippets/convex/actionsContext.ts";
import ContextRunQuery from "!!raw-loader!@site/../private-demos/snippets/convex/myFunctions.ts";
import ContextRunMutation from "!!raw-loader!@site/../private-demos/snippets/convex/actionsContextRunMutation.ts";
import CircularError from "!!raw-loader!@site/../private-demos/snippets/convex/actionsCircularError.ts";
import CircularErrorFixedResults from "!!raw-loader!@site/../private-demos/snippets/convex/actionsCircularErrorFixedResults.ts";
import CircularErrorFixedReturn from "!!raw-loader!@site/../private-demos/snippets/convex/actionsCircularErrorFixedReturn.ts";
import NPM from "!!raw-loader!@site/../private-demos/snippets/convex/actionsNPM.ts";
import Node from "!!raw-loader!@site/../private-demos/snippets/convex/actionsNode.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/src/actionsCall.tsx";
import ScheduleFromMutation from "!!raw-loader!@site/../private-demos/snippets/convex/actionsScheduleFromMutation.ts";

Actions can call third party services to do things such as processing a payment
with [Stripe](https://stripe.com). They can be run in Convex's JavaScript
environment or in Node.js. They can interact with the database indirectly by
calling [queries](/functions/query-functions.mdx) and
[mutations](/functions/mutation-functions.mdx).

**Example:**
[GIPHY Action](https://github.com/get-convex/convex-demos/tree/main/giphy-action)

## Action names

Actions follow the same naming rules as queries, see
[Query names](/functions/query-functions.mdx#query-names).

## The `action` constructor

To declare an action in Convex you use the action constructor function. Pass it
an object with a `handler` function, which performs the action:

<TSAndJSSnippet
  sourceTS={Constructor}
  sourceJS={Constructor}
  title="convex/myFunctions.ts"
/>

Unlike a query, an action can but does not have to return a value.

### Action arguments and responses

Action arguments and responses follow the same rules as
[mutations](/functions/mutation-functions.mdx#mutation-arguments):

<TSAndJSSnippet
  sourceTS={ArgsWithValidation}
  sourceJS={ArgsWithValidation}
  title="convex/myFunctions.ts"
/>

The first argument to the handler function is reserved for the action context.

### Action context

The `action` constructor enables interacting with the database, and other Convex
features by passing an [ActionCtx](/api/interfaces/server.GenericActionCtx)
object to the handler function as the first argument:

<TSAndJSSnippet
  sourceTS={Context}
  sourceJS={Context}
  title="convex/myFunctions.ts"
/>

Which part of that action context is used depends on what your action needs to
do:

- To read data from the database use the `runQuery` field, and call a query that
  performs the read:

  <TSAndJSSnippet
    sourceTS={ContextRunQuery}
    sourceJS={ContextRunQuery}
    snippet="action"
    title="convex/myFunctions.ts"
  />

  Here `readData` is an [internal query](/functions/internal-functions.mdx)
  because we don't want to expose it to the client directly. Actions, mutations
  and queries can be defined in the same file.

- To write data to the database use the `runMutation` field, and call a mutation
  that performs the write:

  <TSAndJSSnippet
    sourceTS={ContextRunMutation}
    sourceJS={ContextRunMutation}
    title="convex/myFunctions.ts"
  />

  Use an [internal mutation](/functions/internal-functions.mdx) when you want to
  prevent users from calling the mutation directly.

  As with queries, it's often convenient to define actions and mutations in the
  same file.

- To generate upload URLs for storing files use the `storage` field. Read on
  about [File Storage](/file-storage.mdx).
- To check user authentication use the `auth` field. Auth is propagated
  automatically when calling queries and mutations from the action. Read on
  about [Authentication](/auth.mdx).
- To schedule functions to run in the future, use the `scheduler` field. Read on
  about [Scheduled Functions](/scheduling/scheduled-functions.mdx).
- To search a vector index, use the `vectorSearch` field. Read on about
  [Vector Search](/search/vector-search.mdx).

### Dealing with circular type inference

<Details summary={<>
Working around the TypeScript error: some action <code>implicitly has
type 'any' because it does not have a type annotation and is
referenced directly or indirectly in its own initializer.</code>
</>}>

When the return value of an action depends on the result of calling
`ctx.runQuery` or `ctx.runMutation`, TypeScript will complain that it cannot
infer the return type of the action. This is a minimal example of the issue:

<Snippet
  title="convex/myFunctions.ts"
  source={CircularError}
  snippet="tsError"
/>

To work around this, there are two options:

1. Type the return value of the handler function explicitly:
   <Snippet
     title="convex/myFunctions.ts"
     source={CircularErrorFixedReturn}
     snippet="fixed"
     highlightPatterns={["null"]}
   />
2. Type the the result of the `ctx.runQuery` or `ctx.runMutation` call
   explicitly:
   <Snippet
     title="convex/myFunctions.ts"
     source={CircularErrorFixedResults}
     snippet="fixed"
     highlightPatterns={["null"]}
   />

TypeScript will check that the type annotation matches what the called query or
mutation returns, so you don't lose any type safety.

In this trivial example the return type of the query was `null`. See the
[TypeScript](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)
page for other types which might be helpful when annotating the result.

</Details>

## Choosing the runtime ("use node")

Actions can run in Convex's custom JavaScript environment or in Node.js.

By default, actions run in Convex's environment. This environment supports
`fetch`, so actions that simply want to call a third-party API using `fetch` can
be run in this environment:

<TSAndJSSnippet sourceTS={NPM} sourceJS={NPM} title="convex/myFunctions.ts" />

Actions running in Convex's environment are faster compared to Node.js, since
they don't require extra time to start up before running your action (cold
starts). They can also be defined in the same file as other Convex functions.
Like queries and mutations they can import NPM packages, but not all are
supported.

Actions needing unsupported NPM packages or Node.js APIs can be configured to
run in Node.js by adding the `"use node"` directive at the top of the file. Note
that other Convex functions cannot be defined in files with the `"use node";`
directive.

<TSAndJSSnippet
  sourceTS={Node}
  sourceJS={Node}
  highlightPatterns={["use node"]}
  title="convex/myAction.ts"
/>

Learn more about the two [Convex Runtimes](/functions/runtimes.mdx).

## Splitting up action code via helpers

<>
  {/* Fragment for Prettier */}
  Just like with [queries](/functions/query-functions.mdx#splitting-up-query-code-via-helpers)
  and [mutations](/functions/mutation-functions.mdx#splitting-up-mutation-code-via-helpers)
  you can define and call helper
  <LanguageSelector verbose /> functions to split up the code in your actions or
  reuse logic across multiple Convex functions.

But note that the [ActionCtx](/api/interfaces/server.GenericActionCtx) only has
the `auth` field in common with [QueryCtx](/generated-api/server.md#queryctx)
and [MutationCtx](/generated-api/server.md#mutationctx).

</>

## Calling actions from clients

To call an action from [React](/client/react.mdx) use the
[`useAction`](/api/modules/react#useaction) hook along with the generated
[`api`](/generated-api/api) object.

<TSAndJSSnippet sourceTS={Call} sourceJS={Call} title="src/myApp.tsx" />

Unlike
[mutations](/functions/mutation-functions.mdx#calling-mutations-from-clients),
actions from a single client are parallelized. Each action will be executed as
soon as it reaches the server (even if other actions and mutations from the same
client are running). If your app relies on actions running after other actions
or mutations, make sure to only trigger the action after the relevant previous
function completes.

**Note:** In most cases calling an action directly from a client **is an
anti-pattern**. Instead, have the client call a
[mutation](/functions/mutation-functions.mdx) which captures the user intent by
writing into the database and then
[schedules](/scheduling/scheduled-functions.mdx) an action:

<TSAndJSSnippet
  sourceTS={ScheduleFromMutation}
  sourceJS={ScheduleFromMutation}
  title="convex/myFunctions.ts"
/>

This way the mutation can enforce invariants, such as preventing the user from
executing the same action twice.

## Limits

Actions time out after 10 minutes.
[Node.js](/functions/runtimes.mdx#nodejs-runtime) and
[Convex runtime](/functions/runtimes.mdx#default-convex-runtime) have 512MB and
64MB memory limit respectively. Please [contact us](/production/contact.md) if
you have a use case that requires configuring higher limits.

Actions can do up to 1000 concurrent operations, such as executing queries,
mutations or performing fetch requests.

For information on other limits, see [here](/production/state/limits.mdx).

## Error handling

Unlike queries and mutations, actions may have side-effects and therefore can't
be automatically retried by Convex when errors occur. For example, say your
action calls Stripe to send a customer invoice. If the HTTP request fails,
Convex has no way of knowing if the invoice was already sent. Like in normal
backend code, it is the responsibility of the caller to handle errors raised by
actions and retry the action call if appropriate.

## Dangling promises

Make sure to await all promises created within an action. Async tasks still
running when the function returns might or might not complete. In addition,
since the Node.js execution environment might be reused between action calls,
dangling promises might result in errors in subsequent action invocations.

## Best practices

### `await ctx.runAction` should only be used for crossing JS runtimes

**Why?** `await ctx.runAction` incurs to overhead of another Convex server
function. It counts as an extra function call, it allocates its own system
resources, and while you're awaiting this call the parent action call is frozen
holding all it's resources. If you pile enough of these calls on top of each
other, your app may slow down significantly.

**Fix:** The reason this api exists is to let you run code in the
[Node.js environment](/functions/runtimes.mdx). If you want to call an action
from another action that's in the same runtime, which is the normal case, the
best way to do this is to pull the code you want to call into a TypeScript
[helper function](/understanding/best-practices/best-practices.mdx#use-helper-functions-to-write-shared-code)
and call the helper instead.

### Avoid `await ctx.runMutation` / `await ctx.runQuery`

```ts
// ❌
const foo = await ctx.runQuery(...)
const bar = await ctx.runQuery(...)

// ✅
const fooAndBar = await ctx.runQuery(...)
```

**Why?** Multiple runQuery / runMutations execute in separate transactions and
aren’t guaranteed to be consistent with each other (e.g. foo and bar could read
the same document and return two different results), while a single runQuery /
runMutation will always be consistent. Additionally, you’re paying for multiple
function calls when you don’t have to.

**Fix:** Make a new internal query / mutation that does both things. Refactoring
the code for the two functions into helpers will make it easy to create a new
internal function that does both things while still keeping around the original
functions. Potentially try and refactor your action code to “batch” all the
database access.

Caveats: Separate runQuery / runMutation calls are valid when intentionally
trying to process more data than fits in a single transaction (e.g. running a
migration, doing a live aggregate).

## Related Components

<ComponentCardList
  items={[
    {
      title: "Action Cache",
      description:
        "Cache expensive or frequently run actions. Allows configurable cache duration and forcing updates.",
      href: "https://www.convex.dev/components/action-cache",
    },
    {
      title: "Workpool",
      description:
        "Workpool give critical tasks priority by organizing async operations into separate, customizable queues. Supports retries and parallelism limits.",
      href: "https://www.convex.dev/components/workpool",
    },
    {
      title: "Workflow",
      description:
        "Similar to Actions, Workflows can call queries, mutations, and actions. However, they are durable functions that can suspend, survive server crashes, specify retries for action calls, and more.",
      href: "https://www.convex.dev/components/workflow",
    },
  ]}
/>



================================================
FILE: npm-packages/docs/docs/functions/bundling.mdx
================================================
---
title: "Bundling"
sidebar_position: 90
description: "How Convex bundles and optimizes your function code"
---

Bundling is the process of gathering, optimizing and transpiling the JS/TS
source code of [functions](/functions.mdx) and their dependencies. During
development and when deploying, the code is transformed to a format that Convex
[runtimes](/functions/runtimes.mdx) can directly and efficiently execute.

Convex currently bundles all dependencies automatically, but for the Node.js
runtime you can disable bundling certain packages via the
[external packages](#external-packages) config.

## Bundling for Convex

When you push code either via `npx convex dev` or `npx convex deploy`, the
Convex CLI uses [esbuild](https://esbuild.github.io/) to traverse your `convex/`
folder and bundle your functions and all of their used dependencies into a
source code bundle. This bundle is then sent to the server.

Thanks to bundling you can write your code using both modern ECMAScript Modules
(ESM) or the older CommonJS (CJS) syntax.

<Details summary="ESM vs. CJS">
    ESM
    - Is the standard for browser JavaScript
    - Uses static imports via the `import` and `export` **keywords** (not functions)
    at the global scope
    - Also supports dynamic imports via the asynchronous `import` function

    CJS
    - Was previously the standard module system for Node.js
    - Relies on dynamic imports via the `require` and asynchronous `import`
    functions for fetching external modules
    - Uses the `module.exports` object for exports

</Details>

## Bundling limitations

The nature of bundling comes with a few limitations.

### Code size limits

The total size of your bundled function code in your `convex/` folder is
**limited to 32MiB (~33.55MB)**. Other platform limits can be found
[here](/production/state/limits.mdx).

While this limit in itself is quite high for just source code, certain
dependencies can quickly make your bundle size cross over this limit,
particularly if they are not effectively
[tree-shakeable](https://webpack.js.org/guides/tree-shaking/) (such as
[aws-sdk](https://www.npmjs.com/package/aws-sdk) or
[snowflake-sdk](https://www.npmjs.com/package/snowflake-sdk))

You can follow these steps to debug bundle size:

<StepByStep>
  <Step title="Make sure you're using the most recent version of convex">
    ```sh
    npm install convex@latest
    ```
  </Step>
  <Step title="Generate the bundle">
   Note that this will not push code, and just generated a bundle for debugging purposes.

    ```sh
    npx convex dev --once --debug-bundle-path /tmp/myBundle
    ```

  </Step>
  <Step title="Visualize the bundle">
  Use
   [source-map-explorer](https://github.com/danvk/source-map-explorer/tree/master)
   to visualize your bundle.

    ```sh
    npx source-map-explorer /tmp/myBundle/**/*.js
    ```

  </Step>
</StepByStep>

Code bundled for the Convex runtime will be in the `isolate` directory while
code bundled for node actions will be in the `node` directory.

Large node dependencies can be eliminated from the bundle by marking them as
[external packages](/functions/bundling.mdx#external-packages).

### Dynamic dependencies

Some libraries rely on dynamic imports (via `import`/`require` calls) to avoid
always including their dependencies. These imports are not supported by the
[default Convex runtime](/functions/runtimes.mdx#default-convex-runtime) and
will throw an error at runtime.

Additionally, some libraries rely on local files, which cannot be bundled by
esbuild. If bundling is used, irrespective of the choice of runtime, these
imports will always fail in Convex.

<Details summary="Examples of libraries with dynamic dependencies">

Consider the following examples of packages relying on dynamic dependencies:

- [langchain](https://www.npmjs.com/package/langchain) relying on the presence
  of peer dependencies that it can dynamically import. These dependencies are
  not statically `import`ed so will not be bundled by `esbuild`.
- [sharp](https://www.npmjs.com/package/sharp) relying on the presence of
  `libvips` binaries for image-processing operations
- [pdf-parse](https://www.npmjs.com/package/pdf-parse) relies on being
  dynamically imported with `require()` in order to detect if it is being run in
  test mode. Bundling can eliminate these `require()` calls, making `pdf-parse`
  assume it is running in test mode.
- [tiktoken](https://www.npmjs.com/package/tiktoken) relying on local WASM files

</Details>

## External packages

As a workaround for the bundling limitations above, Convex provides an escape
hatch: **external packages**. This feature is currently exclusive to Convex's
[Node.js runtime](/functions/runtimes.mdx#nodejs-runtime).

External packages use
[`esbuild`'s facility for marking a dependency as external](https://esbuild.github.io/api/#external).
This tells `esbuild` to not bundle the external dependency at all and to leave
the import as a dynamic runtime import using `require()` or `import()`. Thus,
your Convex modules will rely on the underlying system having that dependency
made available at execution-time.

### Package installation on the server

Packages marked as external are installed from [npm](https://www.npmjs.com/) the
first time you push code that uses them. The version installed matches the
version installed in the `node_modules` folder on your local machine.

While this comes with a latency penalty the first time you push external
packages, your packages are cached and this install step only ever needs to
rerun if your external packages change. Once cached, pushes can actually be
faster due to smaller source code bundles being sent to the server during
pushes!

### Specifying external packages

Create a [`convex.json`](/production/project-configuration.mdx#convexjson) file
in the same directory as your `package.json` if it does not exist already. Set
the `node.externalPackages` field to `["*"]` to mark all dependencies used
within your Node actions as external:

```json title="convex.json"
{
  "$schema": "./node_modules/convex/schemas/convex.schema.json",
  "node": {
    "externalPackages": ["*"]
  }
}
```

Alternatively, you can explicitly specify which packages to mark as external:

```json title="convex.json"
{
  "$schema": "./node_modules/convex/schemas/convex.schema.json",
  "node": {
    "externalPackages": ["aws-sdk", "sharp"]
  }
}
```

The package identifiers should match the string used in `import`/`require` in
your [Node.js action](/functions/actions.mdx#choosing-the-runtime-use-node).

### Troubleshooting external packages

#### Incorrect package versions

The Convex CLI searches for external packages within your local `node_modules`
directory. Thus, changing version of a package in the `package.json` will not
affect the version used on the server until you've updated the package version
installed in your local `node_modules` folder (e.g. running `npm install`).

#### Import errors

Marking a dependency as external may result in errors like this:

> The requested module "some-module" is a CommonJs module, which may not support
> all module.exports as named exports. CommonJs modules can always be imported
> via the default export

This requires rewriting any imports for this module as follows:

```ts
// ❌ old
import { Foo } from "some-module";

// ✅ new
import SomeModule from "some-module";
const { Foo } = SomeModule;
```

### Limitations

The total size of your source code bundle and external packages cannot exceed
the following:

- 45MB zipped
- 240MB unzipped

Packages that are known not to work at this time:

- [Puppeteer](https://www.npmjs.com/package/puppeteer) - browser binary
  installation exceeds the size limit
- [@ffmpeg.wasm](https://www.npmjs.com/package/@ffmpeg/ffmpeg) - since 0.12.0,
  [no longer supports Node environments](https://ffmpegwasm.netlify.app/docs/faq#why-ffmpegwasm-doesnt-support-nodejs)

If there is a package that you would like working in your Convex functions,
[let us know](https://convex.dev/community).



================================================
FILE: npm-packages/docs/docs/functions/debugging.mdx
================================================
---
title: Debugging
sidebar_position: 100
description: "Debug Convex functions during development and production"
---

Debugging is the process of figuring out why your code isn't behaving as you
expect.

## Debugging during development

During development the built-in `console` API allows you to understand what's
going on inside your functions:

```ts title="convex/myFunctions.ts"
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const mutateSomething = mutation({
  args: { a: v.number(), b: v.number() },
  handler: (_, args) => {
    console.log("Received args", args);
    // ...
  },
});
```

The following methods are available in the
[default Convex runtime](/functions/runtimes.mdx#default-convex-runtime):

- Logging values, with a specified severity level:
  - `console.log`
  - `console.info`
  - `console.warn`
  - `console.error`
  - `console.debug`
- Logging with a stack trace:
  - [`console.trace`](https://developer.mozilla.org/en-US/docs/Web/API/console/trace_static)
- Measuring execution time:
  - [`console.time`](https://developer.mozilla.org/en-US/docs/Web/API/console/time_static)
  - [`console.timeLog`](https://developer.mozilla.org/en-US/docs/Web/API/console/timelog_static)
  - [`console.timeEnd`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeend_static)

The Convex backend also automatically logs all successful function executions
and all errors thrown by your functions.

You can view these logs:

1. When using the [`ConvexReactClient`](/client/react.mdx), in your browser
   developer tools console pane. The logs are sent from your dev deployment to
   your client, and the client logs them to the browser. Production deployments
   [**do not** send logs to the client](/functions/error-handling/error-handling.mdx#differences-in-error-reporting-between-dev-and-prod).
2. In your Convex dashboard on the [Logs page](/dashboard/deployments/logs.md).
3. In your terminal with [`npx convex dev`](/cli.md#tail-deployment-logs) during
   development or [`npx convex logs`](/cli.md#tail-deployment-logs), which only
   prints logs.

### Using a debugger

You can exercise your functions from tests, in which case you can add
`debugger;` statements and step through your code. See
[Testing](/testing/convex-test.mdx#debugging-tests).

## Debugging in production

When debugging an issue in production your options are:

1. Leverage existing logging
2. Add more logging and deploy a new version of your backend to production

Convex backend currently only preserves a limited number of logs, and logs can
be erased at any time when the Convex team performs internal maintenance and
upgrades. You should therefore set up
[log streaming and error reporting](/production/integrations/integrations.mdx)
integrations to enable your team easy access to historical logs and additional
information logged by your client.

## Finding relevant logs by Request ID

To find the appropriate logs for an error you or your users experience, Convex
includes a Request ID in all exception messages in both dev and prod in this
format: `[Request ID: <request_id>]`.

You can copy and paste a Request ID into your Convex dashboard to view the logs
for functions started by that request. See the
[Dashboard logs page](/dashboard/deployments/logs.md#filter-logs) for details.

{/* TODO: Document how to filter by Request ID in Datadog/Axiom */}



================================================
FILE: npm-packages/docs/docs/functions/http-actions.mdx
================================================
---
title: HTTP Actions
sidebar_position: 35
description: "Build HTTP APIs directly in Convex"
---

import http from "!!raw-loader!@site/../demos/http/convex/http.ts";
import httpFunction from "!!raw-loader!@site/../private-demos/snippets/convex/httpActionExample.ts";
import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/httpActionConstructor.ts";
import httpStorage from "!!raw-loader!@site/../demos/file-storage-with-http/convex/http.ts";
import Fetch from "!!raw-loader!@site/../private-demos/snippets/src/httpAuthCall.ts";

HTTP actions allow you to build an HTTP API right in Convex!

```ts title="convex/http.ts"
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";

const http = httpRouter();

http.route({
  path: "/",
  method: "GET",
  handler: httpAction(async (ctx, request) => {
    return new Response(`Hello from ${request.url}`);
  }),
});
export default http;
```

HTTP actions take in a
[Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) and return a
[Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) following
the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
HTTP actions can manipulate the request and response directly, and interact with
data in Convex indirectly by running [queries](/functions/query-functions.mdx),
[mutations](/functions/mutation-functions.mdx), and
[actions](/functions/actions.mdx). HTTP actions might be used for receiving
webhooks from external applications or defining a public HTTP API.

HTTP actions are exposed at `https://<your deployment name>.convex.site` (e.g.
`https://happy-animal-123.convex.site`).

**Example:**
[HTTP Actions](https://github.com/get-convex/convex-demos/tree/main/http)

## Defining HTTP actions

HTTP action handlers are defined using the
[`httpAction`](/generated-api/server#httpaction) constructor, similar to the
`action` constructor for normal actions:

<TSAndJSSnippet
  title="convex/myHttpActions.ts"
  sourceTS={Constructor}
  sourceJS={Constructor}
/>

The first argument to the `handler` is an
[`ActionCtx`](/api/interfaces/server.GenericActionCtx) object, which provides
[`auth`](/api/interfaces/server.Auth),
[`storage`](/api/interfaces/server.StorageActionWriter), and
[`scheduler`](/api/interfaces/server.Scheduler), as well as `runQuery`,
`runMutation`, `runAction`.

The second argument contains the
[`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) data. HTTP
actions do not support argument validation, as the parsing of arguments from the
incoming Request is left entirely to you.

Here's an example:

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={httpFunction}
  sourceJS={httpFunction}
/>

<>
  {/* Wrapped in fragment because Prettier pushes the JSDialectFileName on new line */}
  To expose the HTTP Action, export an instance of
  [`HttpRouter`](/api/classes/server.HttpRouter) from the
  <JSDialectFileName name="convex/http.ts" /> file. To create the instance call
  the `httpRouter` function. On the `HttpRouter` you can expose routes using the
  `route` method:
</>

<TSAndJSSnippet
  title="convex/http.ts"
  sourceTS={http}
  sourceJS={http}
  snippet="router"
  highlightPatterns={["handler: postMessage"]}
/>

You can now call this action via HTTP and interact with data stored in the
Convex Database. HTTP actions are exposed on
`https://<your deployment name>.convex.site`.

```bash
export DEPLOYMENT_NAME=... # example: "happy-animal-123"
curl -d '{ "author": "User 123", "body": "Hello world" }' \
    -H 'content-type: application/json' "https://$DEPLOYMENT_NAME.convex.site/postMessage"
```

Like other Convex functions, you can view your HTTP actions in the
[Functions view](/dashboard/deployments/functions.md) of
[your dashboard](https://dashboard.convex.dev/) and view logs produced by them
in the [Logs view](/dashboard/deployments/logs.md).

## Limits

HTTP actions run in the same environment as queries and mutations so also do not
have access to Node.js-specific JavaScript APIs. HTTP actions can call
[actions](/functions/actions.mdx), which can run in Node.js.

Like [actions](/functions/actions.mdx#error-handling), HTTP actions may have
side-effects and will not be automatically retried by Convex when errors occur.
It is a responsibility of the caller to handle errors and retry the request if
appropriate.

Request and response size is limited to 20MB.

HTTP actions support request and response body types of `.text()`, `.json()`,
`.blob()`, and `.arrayBuffer()`.

Note that you don't need to define an HTTP action to call your queries,
mutations and actions over HTTP if you control the caller, since you can use use
the JavaScript [`ConvexHttpClient`](/api/classes/browser.ConvexHttpClient) or
the [Python client](/client/python.md) to call these functions directly.

## Debugging

### Step 1: Check that your HTTP actions were deployed.

Check the [functions page](https://dashboard.convex.dev/deployment/functions) in
the dashboard and make sure there's an entry called `http`.

If not, double check that you've defined your HTTP actions with the `httpRouter`
in a file called `http.js` or `http.ts` (the name of the file must match
exactly), and that `npx convex dev` has no errors.

### Step 2: Check that you can access your endpoint using curl

Get your URL from the dashboard under
[Settings](https://dashboard.convex.dev/deployment/settings) > URL and Deploy
Key.

Make sure this is the URL that ends in **`.convex.site`**, and not
`.convex.cloud`. E.g. `https://happy-animal-123.convex.site`

Run a `curl` command to hit one of your defined endpoints, potentially defining
a new endpoint specifically for testing

```
curl -X GET https://<deployment name>.convex.site/myEndpoint
```

Check the [logs page](https://dashboard.convex.dev/deployment/logs) in the
dashboard to confirm that there's an entry for your HTTP action.

### Step 3: Check the request being made by your browser

If you've determined that your HTTP actions have been deployed and are
accessible via curl, but there are still issues requesting them from your app,
check the exact requests being made by your browser.

Open the _Network_ tab in your browser's developer tools, and trigger your HTTP
requests.

Check that this URL matches what you tested earlier with curl -- it ends in
`.convex.site` and has the right deployment name.

You should be able to see these requests in the dashboard
[logs page](https://dashboard.convex.dev/deployment/logs).

If you see "CORS error" or messages in the browser console like
`Access to fetch at '...' from origin '...' has been blocked by CORS policy`,
you likely need to configure CORS headers and potentially add a handler for the
pre-flight `OPTIONS` request. See
[this section](/functions/http-actions.mdx#cors) below.

## Common patterns

### File Storage

HTTP actions can be used to handle uploading and fetching stored files, see:

- [Uploading files via an HTTP action](/file-storage/upload-files.mdx#uploading-files-via-an-http-action)
- [Serving files from HTTP actions](/file-storage/serve-files.mdx#serving-files-from-http-actions)

### CORS

To make requests to HTTP actions from a website you need to add
[Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
headers to your HTTP actions.

There are existing resources for exactly which CORS headers are required based
on the use case. [This site](https://httptoolkit.com/will-it-cors/) provides an
interactive walkthrough for what CORS headers to add. Here's an example of
adding CORS headers to a Convex HTTP action:

<TSAndJSSnippet
  title="convex/http.ts"
  sourceTS={httpStorage}
  sourceJS={httpStorage}
  snippet={["sendImageStore"]}
  highlightPatterns={["headers: new Headers", "        ", "     \\}\\)"]}
/>

Here's an example of handling a pre-flight `OPTIONS` request:

<TSAndJSSnippet
  title="convex/http.ts"
  sourceTS={httpStorage}
  sourceJS={httpStorage}
  snippet="preflight"
  highlightPatterns={["headers: new Headers", "          ", "       \\}\\)"]}
/>

### Authentication

You can leverage Convex's built-in [authentication](/auth.mdx) integration and
access a user identity from
[`ctx.auth.getUserIdentity()`](/api/interfaces/server.Auth#getuseridentity). To
do this call your endpoint with an `Authorization` header including a JWT token:

<TSAndJSSnippet sourceTS={Fetch} sourceJS={Fetch} title="myPage.ts" />



================================================
FILE: npm-packages/docs/docs/functions/internal-functions.mdx
================================================
---
title: Internal Functions
sidebar_position: 40
description: "Functions that can only be called by other Convex functions"
---

import Definition from "!!raw-loader!@site/../private-demos/snippets/convex/plans.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/convex/internalFunctionsCall.ts";
import DefinitionWithoutValidationTS from "!!raw-loader!@site/../private-demos/snippets/convex/internalFunctionsDefinitionWithoutValidation.ts";
import DefinitionWithoutValidationJS from "!!raw-loader!@site/../private-demos/snippets/convex/internalFunctionsDefinitionWithoutValidationJS.js";

Internal functions can only be called by other [functions](/functions.mdx) and
cannot be called directly from a [Convex client](/client/react.mdx).

By default your Convex functions are public and accessible to clients. Public
functions may be called by malicious users in ways that cause surprising
results. Internal functions help you mitigate this risk. We recommend using
internal functions any time you're writing logic that should not be called from
a client.

While internal functions help mitigate risk by reducing the public surface area
of your application, you can still validate internal invariants using
[argument validation](/functions/validation.mdx) and/or
[authentication](/auth/functions-auth.mdx).

## Use cases for internal functions

Leverage internal functions by:

- Calling them from [actions](/functions/actions.mdx#action-context) via
  `runQuery` and `runMutation`
- Calling them from [HTTP actions](/functions/http-actions.mdx) via `runQuery`,
  `runMutation`, and `runAction`
- [Scheduling](/scheduling/scheduled-functions.mdx) them from other functions to
  run in the future
- Scheduling them to run periodically from
  [cron jobs](/scheduling/cron-jobs.mdx)
- Running them using the
  [Dashboard](/dashboard/deployments/functions.md#running-functions)
- Running them from the [CLI](/cli.md#run-convex-functions)

## Defining internal functions

An internal function is defined using `internalQuery`, `internalMutation`, or
`internalAction`. For example:

<TSAndJSSnippet
  title="convex/plans.ts"
  sourceTS={Definition}
  sourceJS={Definition}
  highlightPatterns={["internalMutation"]}
/>

If you need to pass complicated objects to internal functions you might prefer
to not use argument validation. Note though that if you're using `internalQuery`
or `internalMutation` it's a better idea to pass around document IDs instead of
documents, to ensure the query or mutation is working with the up-to-date state
of the database.

<Details summary="Internal function without argument validation">

<TSAndJSSnippet
  title="convex/plans.ts"
  sourceTS={DefinitionWithoutValidationTS}
  sourceJS={DefinitionWithoutValidationJS}
  highlightPatterns={[": {"]}
/>

</Details>

## Calling internal functions

Internal functions can be called from actions and scheduled from actions and
mutation using the [`internal`](/generated-api/api#internal) object.

For example, consider this public `upgrade` action that calls the internal
`plans.markPlanAsProfessional` mutation we defined above:

<TSAndJSSnippet title="convex/changes.ts" sourceTS={Call} sourceJS={Call} />

In this example a user should not be able to directly call
`internal.plans.markPlanAsProfessional` without going through the `upgrade`
action — if they did, then they would get a free upgrade.

You can define public and internal functions in the same file.



================================================
FILE: npm-packages/docs/docs/functions/mutation-functions.mdx
================================================
---
title: Mutations
sidebar_position: 20
description: "Insert, update, and remove data from the database"
---

import Example from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsExample.ts";
import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsConstructor.ts";
import ArgsWithoutValidationTS from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsArgsWithoutValidation.ts";
import ArgsWithoutValidationJS from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsArgsWithoutValidationJS.js";
import ArgsWithValidation from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsArgsWithValidation.ts";
import Context from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsContext.ts";
import ContextDB from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsContextDB.ts";
import Helper from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsHelper.ts";
import HelperJS from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsHelperJS.js";
import NPM from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsNPM.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/src/mutationsCall.tsx";

Mutations insert, update and remove data from the database, check authentication
or perform other business logic, and optionally return a response to the client
application.

This is an example mutation, taking in named arguments, writing data to the
database and returning a result:

<TSAndJSSnippet
  sourceTS={Example}
  sourceJS={Example}
  title="convex/myFunctions.ts"
/>

Read on to understand how to build mutations yourself.

## Mutation names

Mutations follow the same naming rules as queries, see
[Query names](/functions/query-functions.mdx#query-names).

Queries and mutations can be defined in the same file when using named exports.

## The `mutation` constructor

To declare a mutation in Convex use the `mutation` constructor function. Pass it
an object with a `handler` function, which performs the mutation:

<TSAndJSSnippet
  sourceTS={Constructor}
  sourceJS={Constructor}
  title="convex/myFunctions.ts"
/>

Unlike a query, a mutation can but does not have to return a value.

### Mutation arguments

Just like queries, mutations accept named arguments, and the argument values are
accessible as fields of the second parameter of the `handler` function:

<TSAndJSSnippet
  sourceTS={ArgsWithoutValidationTS}
  sourceJS={ArgsWithoutValidationJS}
  title="convex/myFunctions.ts"
/>

Arguments and responses are automatically serialized and deserialized, and you
can pass and return most value-like JavaScript data to and from your mutation.

To both declare the types of arguments and to validate them, add an `args`
object using `v` validators:

<TSAndJSSnippet
  sourceTS={ArgsWithValidation}
  sourceJS={ArgsWithValidation}
  title="convex/myFunctions.ts"
/>

See [argument validation](/functions/validation.mdx) for the full list of
supported types and validators.

The first parameter to the handler function is reserved for the mutation
context.

### Mutation responses

Queries can return values of any supported
[Convex type](/functions/validation.mdx) which will be automatically serialized
and deserialized.

Mutations can also return `undefined`, which is not a valid Convex value. When a
mutation returns `undefined` **it is translated to `null`** on the client.

### Mutation context

The `mutation` constructor enables writing data to the database, and other
Convex features by passing a [MutationCtx](/generated-api/server.md#mutationctx)
object to the handler function as the first parameter:

<TSAndJSSnippet
  sourceTS={Context}
  sourceJS={Context}
  title="convex/myFunctions.ts"
/>

Which part of the mutation context is used depends on what your mutation needs
to do:

- To read from and write to the database use the `db` field. Note that we make
  the handler function an `async` function so we can `await` the promise
  returned by `db.insert()`:

  <TSAndJSSnippet
    sourceTS={ContextDB}
    sourceJS={ContextDB}
    title="convex/myFunctions.ts"
  />

  Read on about [Writing Data](/database/writing-data.mdx).

- To generate upload URLs for storing files use the `storage` field. Read on
  about [File Storage](/file-storage.mdx).
- To check user authentication use the `auth` field. Read on about
  [Authentication](/auth.mdx).
- To schedule functions to run in the future, use the `scheduler` field. Read on
  about [Scheduled Functions](/scheduling/scheduled-functions.mdx).

## Splitting up mutation code via helpers

<>
  {/* Fragment for Prettier */}
  When you want to split up the code in your mutation or reuse logic across
  multiple Convex functions you can define and call helper
  <LanguageSelector verbose /> functions:
</>

<TSAndJSSnippet
  sourceTS={Helper}
  sourceJS={HelperJS}
  title="convex/myFunctions.ts"
/>

Mutations can call helpers that take a
[QueryCtx](/generated-api/server.md#queryctx) as argument, since the mutation
context can do everything query context can.

You can `export` helpers to use them across multiple files. They will not be
callable from outside of your Convex functions.

See
[Type annotating server side helpers](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)
for more guidance on TypeScript types.

## Using NPM packages

Mutations can import NPM packages installed in `node_modules`. Not all NPM
packages are supported, see
[Runtimes](/functions/runtimes.mdx#default-convex-runtime) for more details.

```sh
npm install @faker-js/faker
```

<TSAndJSSnippet sourceTS={NPM} sourceJS={NPM} title="convex/myFunctions.ts" />

## Calling mutations from clients

To call a mutation from [React](/client/react.mdx) use the
[`useMutation`](/client/react.mdx#editing-data) hook along with the generated
[`api`](/generated-api/api) object.

<TSAndJSSnippet sourceTS={Call} sourceJS={Call} title="src/myApp.tsx" />

See the [React](/client/react.mdx) client documentation for all the ways queries
can be called.

When mutations are called from the [React](/client/react.mdx) or
[Rust](/client/rust.md) clients, they are executed one at a time in a single,
ordered queue. You don't have to worry about mutations editing the database in a
different order than they were triggered.

## Transactions

Mutations run **transactionally**. This means that:

1. All database reads inside the transaction get a consistent view of the data
   in the database. You don't have to worry about a concurrent update changing
   the data in the middle of the execution.
2. All database writes get committed together. If the mutation writes some data
   to the database, but later throws an error, no data is actually written to
   the database.

For this to work, similarly to queries, mutations must be deterministic, and
cannot call third party APIs. To call third party APIs, use
[actions](/functions/actions.mdx).

## Limits

Mutations have a limit to the amount of data they can read and write at once to
guarantee good performance. Learn more in
[Read/write limit errors](/functions/error-handling/error-handling.mdx#readwrite-limit-errors).

For information on other limits, see [Limits](/production/state/limits.mdx).



================================================
FILE: npm-packages/docs/docs/functions/query-functions.mdx
================================================
---
title: Queries
sidebar_position: 10
description: "Fetch data from the database with caching and reactivity"
---

import Example from "!!raw-loader!@site/../private-demos/snippets/convex/queriesExample.ts";
import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/queriesConstructor.ts";
import ArgsWithoutValidationTS from "!!raw-loader!@site/../private-demos/snippets/convex/queriesArgsWithoutValidation.ts";
import ArgsWithoutValidationJS from "!!raw-loader!@site/../private-demos/snippets/convex/queriesArgsWithoutValidationJS.js";
import ArgsWithValidation from "!!raw-loader!@site/../private-demos/snippets/convex/queriesArgsWithValidation.ts";
import Context from "!!raw-loader!@site/../private-demos/snippets/convex/queriesContext.ts";
import ContextDB from "!!raw-loader!@site/../private-demos/snippets/convex/queriesContextDB.ts";
import Helper from "!!raw-loader!@site/../private-demos/snippets/convex/queriesHelper.ts";
import HelperJS from "!!raw-loader!@site/../private-demos/snippets/convex/queriesHelperJS.js";
import NPM from "!!raw-loader!@site/../private-demos/snippets/convex/queriesNPM.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/src/queriesCall.tsx";

Queries are the bread and butter of your backend API. They fetch data from the
database, check authentication or perform other business logic, and return data
back to the client application.

This is an example query, taking in named arguments, reading data from the
database and returning a result:

<TSAndJSSnippet
  sourceTS={Example}
  sourceJS={Example}
  title="convex/myFunctions.ts"
/>

Read on to understand how to build queries yourself.

## Query names

Queries are defined in <LanguageSelector verbose /> files inside your `convex/`
directory.

The path and name of the file, as well as the way the function is exported from
the file, determine the name the client will use to call it:

```ts title="convex/myFunctions.ts"
// This function will be referred to as `api.myFunctions.myQuery`.
export const myQuery = …;

// This function will be referred to as `api.myFunctions.sum`.
export const sum = …;
```

To structure your API you can nest directories inside the `convex/` directory:

```ts title="convex/foo/myQueries.ts"
// This function will be referred to as `api.foo.myQueries.listMessages`.
export const listMessages = …;
```

Default exports receive the name `default`.

```ts title="convex/myFunctions.ts"
// This function will be referred to as `api.myFunctions.default`.
export default …;
```

The same rules apply to [mutations](/functions/mutation-functions.mdx) and
[actions](/functions/actions.mdx), while
[HTTP actions](/functions/http-actions.mdx) use a different routing approach.

Client libraries in languages other than JavaScript and TypeScript use strings
instead of API objects:

- `api.myFunctions.myQuery` is `"myFunctions:myQuery"`
- `api.foo.myQueries.myQuery` is `"foo/myQueries:myQuery"`.
- `api.myFunction.default` is `"myFunction:default"` or `"myFunction"`.

## The `query` constructor

To actually declare a query in Convex you use the `query` constructor function.
Pass it an object with a `handler` function, which returns the query result:

<TSAndJSSnippet
  sourceTS={Constructor}
  sourceJS={Constructor}
  title="convex/myFunctions.ts"
/>

### Query arguments

Queries accept named arguments. The argument values are accessible as fields of
the second parameter of the handler function:

<TSAndJSSnippet
  sourceTS={ArgsWithoutValidationTS}
  sourceJS={ArgsWithoutValidationJS}
  title="convex/myFunctions.ts"
/>

Arguments and responses are automatically serialized and deserialized, and you
can pass and return most value-like JavaScript data to and from your query.

To both declare the types of arguments and to validate them, add an `args`
object using `v` validators:

<TSAndJSSnippet
  sourceTS={ArgsWithValidation}
  sourceJS={ArgsWithValidation}
  highlightPatterns={["args:"]}
  title="convex/myFunctions.ts"
/>

See [argument validation](/functions/validation.mdx) for the full list of
supported types and validators.

The first parameter of the handler function contains the query context.

### Query responses

Queries can return values of any supported
[Convex type](/functions/validation.mdx) which will be automatically serialized
and deserialized.

Queries can also return `undefined`, which is not a valid Convex value. When a
query returns `undefined` **it is translated to `null`** on the client.

### Query context

The `query` constructor enables fetching data, and other Convex features by
passing a [QueryCtx](/generated-api/server.md#queryctx) object to the handler
function as the first parameter:

<TSAndJSSnippet
  sourceTS={Context}
  sourceJS={Context}
  title="convex/myFunctions.ts"
/>

Which part of the query context is used depends on what your query needs to do:

- To fetch from the database use the `db` field. Note that we make the handler
  function an `async` function so we can `await` the promise returned by
  `db.get()`:

  <TSAndJSSnippet
    sourceTS={ContextDB}
    sourceJS={ContextDB}
    highlightPatterns={["db."]}
    title="convex/myFunctions.ts"
  />

  Read more about [Reading Data](/database/reading-data/reading-data.mdx).

- To return URLs to stored files use the `storage` field. Read more about
  [File Storage](/file-storage.mdx).
- To check user authentication use the `auth` field. Read more about
  [Authentication](/auth.mdx).

## Splitting up query code via helpers

When you want to split up the code in your query or reuse logic across multiple
Convex functions you can define and call helper <LanguageSelector verbose />
functions:

<TSAndJSSnippet
  sourceTS={Helper}
  sourceJS={HelperJS}
  title="convex/myFunctions.ts"
/>

You can `export` helpers to use them across multiple files. They will not be
callable from outside of your Convex functions.

See
[Type annotating server side helpers](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)
for more guidance on TypeScript types.

## Using NPM packages

Queries can import NPM packages installed in `node_modules`. Not all NPM
packages are supported, see
[Runtimes](/functions/runtimes.mdx#default-convex-runtime) for more details.

```sh
npm install @faker-js/faker
```

<TSAndJSSnippet sourceTS={NPM} sourceJS={NPM} title="convex/myFunctions.ts" />

## Calling queries from clients

To call a query from [React](/client/react.mdx) use the
[`useQuery`](/client/react.mdx#fetching-data) hook along with the generated
[`api`](/generated-api/api) object.

<TSAndJSSnippet sourceTS={Call} sourceJS={Call} title="src/MyApp.tsx" />

See the [React](/client/react.mdx) client documentation for all the ways queries
can be called.

## Caching & reactivity & consistency

Queries have three awesome attributes:

1. **Caching**: Convex caches query results automatically. If many clients
   request the same query, with the same arguments, they will receive a cached
   response.
2. **Reactivity**: clients can subscribe to queries to receive new results when
   the underlying data changes.
3. **Consistency**: All database reads inside a single query call are performed
   at the same logical timestamp. Concurrent writes do not affect the query
   results.

To have these attributes the handler function must be _deterministic_, which
means that given the same arguments (including the query context) it will return
the same response.

For this reason queries cannot `fetch` from third party APIs. To call third
party APIs, use [actions](/functions/actions.mdx).

You might wonder whether you can use non-deterministic language functionality
like `Math.random()` or `Date.now()`. The short answer is that Convex takes care
of implementing these in a way that you don't have to think about the
deterministic constraint.

See [Runtimes](/functions/runtimes.mdx#default-convex-runtime) for more details
on the Convex runtime.

## Limits

Queries have a limit to the amount of data they can read at once to guarantee
good performance. Check out these limits in
[Read/write limit errors](/functions/error-handling/error-handling.mdx#readwrite-limit-errors).

For information on other limits, see [Limits](/production/state/limits.mdx).



================================================
FILE: npm-packages/docs/docs/functions/runtimes.mdx
================================================
---
title: Runtimes
sidebar_position: 80
description:
  "Learn the differences between the Convex and Node.js runtimes for functions"
---

# Runtimes

Convex functions can run in two runtimes:

- Default [Convex runtime](#default-convex-runtime)
- Opt-in [Node.js runtime](#nodejs-runtime)

## Default Convex runtime

All Convex backend functions are written in JavaScript or TypeScript. By default
all functions run in a custom JavaScript runtime very similar to the
[Cloudflare Workers runtime](https://blog.cloudflare.com/cloud-computing-without-containers/)
with access to most
[web standard globals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).

The default runtime has many advantages including:

- **No cold starts**. The runtime is always up, and ready to handle any function
  at a moments notice.
- **Latest web JavaScript standards**. The runtime is based on V8 that also
  powers Google Chrome. This ensures it provides an interface very similar to
  your frontend code, allowing further simplification to your code.
- **Low overhead access to your data**. The runtime is designed to have low
  overhead access to your data via query & mutation functions, allowing you to
  access your database via a simple
  [JavaScript interface](/database/reading-data/reading-data.mdx).

### Supported APIs

The default runtime supports most npm libraries that work in the browser,
[Deno](https://deno.com/), and
[Cloudflare workers](https://developers.cloudflare.com/workers/). If your
library isn't supported, you can use an action with the
[Node.js runtime](#nodejs-runtime), or reach out in
[Discord](https://convex.dev/community). We are improving support all the time.

#### Network APIs

- [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)
- [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event)
- [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget)
- [fetch](https://developer.mozilla.org/en-US/docs/Web/API/fetch) — in
  [Actions](#actions) only
- [File](https://developer.mozilla.org/en-US/docs/Web/API/File)
- [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)
- [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers)
- [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)
- [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)

#### Encoding APIs

- [TextDecoder](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder)
- [TextEncoder](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder)
- [atob](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob)
- [btoa](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa)

#### Web Stream APIs

- [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)
- [ReadableStreamBYOBReader](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader)
- [ReadableStreamDefaultReader](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader)
- [TransformStream](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream)
- [WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream)
- [WritableStreamDefaultWriter](https://developer.mozilla.org/en-US/docs/Web/API/WritableStreamDefaultWriter)

#### Web Crypto APIs

- [crypto](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
- [CryptoKey](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)
- [SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto)

### Restrictions on queries and mutations

Query and mutation functions are further **restricted by the runtime to be
[deterministic](https://en.wikipedia.org/wiki/Deterministic_algorithm)**. This
allows Convex to automatically retry them by the system as necessary.

Determinism means that no matter how many times your function is run, as long as
it is given the same arguments, it will have identical side effects and return
the same value.

You don't have to think all that much about maintaining these properties of
determinism when you write your Convex functions. Convex will provide helpful
error messages as you go, so you can't *accidentally* do something forbidden.

#### Using randomness and time in queries and mutations

Convex provides a "seeded" strong pseudo-random number generator
at `Math.random()` so that it can guarantee the determinism of your function.
The random number generator's seed is an implicit parameter to your function.
Multiple calls to `Math.random()` in one function call will return different
random values. Note that Convex does not reevaluate the JavaScript modules on
every function run, so a call to `Math.random()` stored in a global variable
will not change between function runs.

To ensure the logic within your function is reproducible, the system time used
globally (outside of any function) is "frozen" at deploy time, while the system
time during Convex function execution is "frozen" when the function
begins. `Date.now()` will return the same result for the entirety of your
function's execution. For example,

```javascript
const globalRand = Math.random(); // `globalRand` does not change between runs.
const globalNow = Date.now(); // `globalNow` is the time when Convex functions were deployed.

export const updateSomething = mutation({
  args: {},
  handler: () => {
    const now1 = Date.now(); // `now1` is the time when the function execution started.
    const rand1 = Math.random(); // `rand1` has a new value for each function run.
    // implementation
    const now2 = Date.now(); // `now2` === `now1`
    const rand2 = Math.random(); // `rand1` !== `rand2`
  },
});
```

### Actions

Actions are unrestricted by the same rules of determinism as query and mutation
functions. Notably actions are allowed to call third-party HTTP endpoints via
the browser-standard
[`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) function.

By default actions also run in Convex’s custom JavaScript runtime with all of
its advantages including no cold starts and a browser-like API environment. They
can also live in the same file as your query and mutation functions.

## Node.js runtime

Some JavaScript and TypeScript libraries use features that are not included in
the default Convex runtime. Convex actions provide an escape hatch to
[Node.js](https://nodejs.org/en/about) via the `"use node"` directive at the top
of a file that contains your action.
[Learn more](/functions/actions.mdx#choosing-the-runtime-use-node).

Use of the Node.js environment is restricted to **action functions only**. If
you want to use a library designed for Node.js and interact with the Convex
database, you need to call the Node.js library from an action, and use
[`runQuery`](/functions/actions.mdx#action-context) or
[`runMutation`](/functions/actions.mdx#action-context) helper to call a query or
mutation.

Every `.ts` and `.js` file in the convex directory
[is bundled](/functions/bundling.mdx) either for the default Convex JavaScript
runtime or Node.js, along with any code it imports.

Files with the `"use node"` directive should not contain any Convex queries or
mutations since they cannot be run in the Node.js runtime. Additionally, files
without the `"use node"` directive should not import any files with the
`"use node"` directive. Files that contain no Convex functions, like a
`convex/utils.ts` file, also need the "use node" directive if they use
Node.js-specific libraries.

If you encounter bundling errors about Node.js-specific imports like `fs` /
`node:fs` not being available when deploying convex functions, running
`npx convex dev --once --debug-node-apis` gives more information about these. It
uses a slower bundling method to track the train of imports, narrowing down
which import is responsible for the error.

Note that argument size limits are lower (5MiB instead of 16MiB).

### Node.js version configuration

By default, all actions ran in the Node.js environment are executed in
Node.js 20. This version is configurable in the
[convex.json](/production/project-configuration.mdx#configuring-the-nodejs-version)
file. We currently support Node.js 20 and 22.

When pushing a new Node.js version to the server, the new code for your
functions may be executed in the old Node.js version for up a few minutes.

Note: This configuration is not supported when running the self-hosted Convex
backend. The node version that is specified in the
[.nvmrc](https://github.com/get-convex/convex-backend/blob/main/.nvmrc) will be
used instead.



================================================
FILE: npm-packages/docs/docs/functions/validation.mdx
================================================
---
title: "Argument and Return Value Validation"
sidebar_label: "Validation"
sidebar_position: 50
description: "Validate function arguments and return values for security"
---

import ConvexValues from "@site/docs/_convexValues.mdx";

import messagesTS from "!!raw-loader!@site/../demos/args-validation/convex/messages.ts";

Argument and return value validators ensure that
[queries](./query-functions.mdx), [mutations](./mutation-functions.mdx), and
[actions](./actions.mdx) are called with the correct types of arguments and
return the expected types of return values.

**This is important for security!** Without argument validation, a malicious
user can call your public functions with unexpected arguments and cause
surprising results. [TypeScript](/understanding/best-practices/typescript) alone
won't help because TypeScript types aren't present at runtime. We recommend
adding argument validation for all public functions in production apps. For
non-public functions that are not called by clients, we recommend
[internal functions](/functions/internal-functions.mdx) and optionally
validation.

**Example:**
[Argument Validation](https://github.com/get-convex/convex-demos/tree/main/args-validation)

## Adding validators

To add argument validation to your functions, pass an object with `args` and
`handler` properties to the `query`, `mutation` or `action` constructor. To add
return value validation, use the `returns` property in this object:

<TSAndJSSnippet
  title="convex/message.ts"
  sourceTS={messagesTS}
  sourceJS={messagesTS}
  snippet="mutation"
/>

If you define your function with an argument validator, there is no need to
include [TypeScript](/understanding/best-practices/typescript.mdx) type
annotations! The type of your function will be inferred automatically.
Similarly, if you define a return value validator, the return type of your
function will be inferred from the validator, and TypeScript will check that it
matches the inferred return type of the `handler` function.

Unlike TypeScript, validation for an object will throw if the object contains
properties that are not declared in the validator.

If the client supplies arguments not declared in `args`, or if the function
returns a value that does not match the validator declared in `returns`. This is
helpful to prevent bugs caused by mistyped names of arguments or returning more
data than intended to a client.

Even `args: {}` is a helpful use of validators because TypeScript will show an
error on the client if you try to pass any arguments to the function which
doesn't expect them.

## Supported types

All functions, both public and internal, can accept and return the following
data types. Each type has a corresponding validator that can be accessed on the
[`v`](/api/modules/values#v) object imported from `"convex/values"`.

The [database](/database.mdx) can store the exact same set of
[data types](/database/types.md).

Additionally you can also express type unions, literals, `any` types, and
optional fields.

### Convex values

<ConvexValues />

### Unions

You can describe fields that could be one of multiple types using `v.union`:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    stringOrNull: v.union(v.string(), v.null()),
  },
  handler: async (ctx, { stringOrNull }) => {
    //...
  },
});
```

For convenience, `v.nullable(foo)` is equivalent to `v.union(foo, v.null())`.

### Literals

Fields that are a constant can be expressed with `v.literal`. This is especially
useful when combined with unions:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    oneTwoOrThree: v.union(
      v.literal("one"),
      v.literal("two"),
      v.literal("three"),
    ),
  },
  handler: async (ctx, { oneTwoOrThree }) => {
    //...
  },
});
```

### Record objects

You can describe objects that map arbitrary keys to values with `v.record`:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    simpleMapping: v.record(v.string(), v.boolean()),
  },
  handler: async (ctx, { simpleMapping }) => {
    //...
  },
});
```

You can use other types of string validators for the keys:

```typescript
defineTable({
  userIdToValue: v.record(v.id("users"), v.boolean()),
});
```

Notes:

- This type corresponds to the
  [Record\<K,V\>](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
  type in TypeScript.
- You cannot use string literals as a `record` key.
- Using `v.string()` as a `record` key validator will only allow ASCII
  characters.

### Any

Fields that could take on any value can be represented with `v.any()`:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    anyValue: v.any(),
  },
  handler: async (ctx, { anyValue }) => {
    //...
  },
});
```

This corresponds to the `any` type in TypeScript.

### Optional fields

You can describe optional fields by wrapping their type with `v.optional(...)`:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    optionalString: v.optional(v.string()),
    optionalNumber: v.optional(v.number()),
  },
  handler: async (ctx, { optionalString, optionalNumber }) => {
    //...
  },
});
```

This corresponds to marking fields as optional with `?` in TypeScript.

## Extracting TypeScript types

The [`Infer`](/api/modules/values#infer) type allows you to turn validator calls
into TypeScript types. This can be useful to remove duplication between your
validators and TypeScript types:

```ts
import { mutation } from "./_generated/server";
import { Infer, v } from "convex/values";

const nestedObject = v.object({
  property: v.string(),
});

// Resolves to `{property: string}`.
export type NestedObject = Infer<typeof nestedObject>;

export default mutation({
  args: {
    nested: nestedObject,
  },
  handler: async (ctx, { nested }) => {
    //...
  },
});
```

### Reusing and extending validators

Validators can be defined once and shared between functions and table schemas.

```typescript
const statusValidator = v.union(v.literal("active"), v.literal("inactive"));

const userValidator = v.object({
  name: v.string(),
  email: v.email(),
  status: statusValidator,
  profileUrl: v.optional(v.string()),
});

const schema = defineSchema({
  users: defineTable(userValidator).index("by_email", ["email"]),
});
```

You can create new object validators from existing ones by adding or removing
fields using `.pick`, `.omit`, `.extend`, and `.partial` on object validators.

```typescript
// Creates a new validator with only the name and profileUrl fields.
const publicUser = userValidator.pick("name", "profileUrl");

// Creates a new validator with all fields except the specified fields.
const userWithoutStatus = userValidator.omit("status", "profileUrl");

// Creates a validator where all fields are optional.
// This is useful for validating patches to a document.
const userPatch = userWithoutStatus.partial();

// Creates a new validator adding system fields to the user validator.
const userDocument = userValidator.extend({
  _id: v.id("users"),
  _creationTime: v.number(),
});
```

Notes:

- Object validators don't allow extra properties, objects with properties that
  aren't specified will fail validation.
- Top-level table fields cannot start with `_` because they are reserved for
  system fields like `_id` and `_creationTime`.



================================================
FILE: npm-packages/docs/docs/functions/error-handling/application-errors.mdx
================================================
---
title: "Application Errors"
sidebar_label: "Application Errors"
description: "Handle expected failures in Convex functions"
---

import Server from "!!raw-loader!@site/../private-demos/snippets/convex/applicationErrors.ts";
import ClientTS from "!!raw-loader!@site/../private-demos/snippets/src/applicationErrors.tsx";
import ClientJS from "!!raw-loader!@site/../private-demos/snippets/src/applicationErrorsJS.jsx";

If you have expected ways your functions might fail, you can either return
different values or throw `ConvexError`s.

## Returning different values

If you're using TypeScript different return types can enforce that you're
handling error scenarios.

For example, a `createUser` mutation could return

```ts
Id<"users"> | { error: "EMAIL_ADDRESS_IN_USE" };
```

to express that either the mutation succeeded or the email address was already
taken.

This ensures that you remember to handle these cases in your UI.

## Throwing application errors

You might prefer to throw errors for the following reasons:

- You can use the exception bubbling mechanism to throw from a deeply nested
  function call, instead of manually propagating error results up the call
  stack. This will work for `runQuery`, `runMutation` and `runAction` calls in
  [actions](/functions/actions.mdx) too.
- In [mutations](/functions/mutation-functions.mdx), throwing an error will
  prevent the mutation transaction from committing
- On the client, it might be simpler to handle all kinds of errors, both
  expected and unexpected, uniformly

Convex provides an error subclass,
[`ConvexError`](/api/classes/values.ConvexError), which can be used to carry
information from the backend to the client:

<TSAndJSSnippet
  title="convex/myFunctions.ts"
  sourceTS={Server}
  sourceJS={Server}
  snippet="example"
  highlightPatterns={["ConvexError"]}
/>

### Application error `data` payload

You can pass the same [data types](/database/types.md) supported by function
arguments, return types and the database, to the `ConvexError` constructor. This
data will be stored on the `data` property of the error:

```ts
// error.data === "My fancy error message"
throw new ConvexError("My fancy error message");

// error.data === {message: "My fancy error message", code: 123, severity: "high"}
throw new ConvexError({
  message: "My fancy error message",
  code: 123,
  severity: "high",
});

// error.data === {code: 123, severity: "high"}
throw new ConvexError({
  code: 123,
  severity: "high",
});
```

Error payloads more complicated than a simple `string` are helpful for more
structured error logging, or for handling sets of errors differently on the
client.

## Handling application errors on the client

On the client, application errors also use the `ConvexError` class, and the data
they carry can be accessed via the `data` property:

<TSAndJSSnippet
  title="src/App.tsx"
  sourceTS={ClientTS}
  sourceJS={ClientJS}
  highlightPatterns={["ConvexError", ".data"]}
/>



================================================
FILE: npm-packages/docs/docs/functions/error-handling/error-handling.mdx
================================================
---
title: "Error Handling"
sidebar_position: 70
description: "Handle errors in Convex queries, mutations, and actions"
---

import { ComponentCardList } from "@site/src/components/ComponentCard";

There are four reasons why your Convex [queries](/functions/query-functions.mdx)
and [mutations](/functions/mutation-functions.mdx) may hit errors:

1. [Application Errors](#application-errors-expected-failures): The function
   code hits a logical condition that should stop further processing, and your
   code throws a `ConvexError`
1. Developer Errors: There is a bug in the function (like calling
   `db.get("documents", null)` instead of `db.get("documents", id)`).
1. [Read/Write Limit Errors](#readwrite-limit-errors): The function is
   retrieving or writing too much data.
1. Internal Convex Errors: There is a problem within Convex (like a network
   blip).

Convex will automatically handle internal Convex errors. If there are problems
on our end, we'll automatically retry your queries and mutations until the
problem is resolved and your queries and mutations succeed.

On the other hand, you must decide how to handle application, developer and
read/write limit errors. When one of these errors happens, the best practices
are to:

1. Show the user some appropriate UI.
2. Send the error to an exception reporting service using the
   [Exception Reporting Integration](/production/integrations/exception-reporting).
3. Log the incident using `console.*` and set up reporting with
   [Log Streaming](/production/integrations/log-streams/log-streams.mdx). This
   can be done in addition to the above options, and doesn't require an
   exception to be thrown.

Additionally, you might also want to send client-side errors to a service like
[Sentry](https://sentry.io) to capture additional information for debugging and
observability.

## Errors in queries

If your query function hits an error, the error will be sent to the client and
thrown from your `useQuery` call site. **The best way to handle these errors is
with a React
[error boundary component](https://reactjs.org/docs/error-boundaries.html).**

Error boundaries allow you to catch errors thrown in their child component tree,
render fallback UI, and send information about the error to your exception
handling service. Adding error boundaries to your app is a great way to handle
errors in Convex query functions as well as other errors in your React
components. If you are using Sentry, you can use their
[`Sentry.ErrorBoundary`](https://docs.sentry.io/platforms/javascript/guides/react/components/errorboundary/)
component.

With error boundaries, you can decide how granular you'd like your fallback UI
to be. One simple option is to wrap your entire application in a single error
boundary like:

```tsx
<StrictMode>
  <ErrorBoundary>
    <ConvexProvider client={convex}>
      <App />
    </ConvexProvider>
  </ErrorBoundary>
</StrictMode>,
```

Then any error in any of your components will be caught by the boundary and
render the same fallback UI.

On the other hand, if you'd like to enable some portions of your app to continue
functioning even if other parts hit errors, you can instead wrap different parts
of your app in separate error boundaries.

<Admonition type="note" title="Retrying">

Unlike other frameworks, there is no concept of "retrying" if your query
function hits an error. Because Convex functions are
[deterministic](/functions/query-functions.mdx#caching--reactivity--consistency),
if the query function hits an error, retrying will always produce the same
error. There is no point in running the query function with the same arguments
again.

</Admonition>

## Errors in mutations

If a mutation hits an error, this will

1. Cause the promise returned from your mutation call to be rejected.
2. Cause your [optimistic update](/client/react/optimistic-updates.mdx) to be
   rolled back.

If you have an exception service like [Sentry](https://sentry.io/) configured,
it should report "unhandled promise rejections" like this automatically. That
means that with no additional work your mutation errors should be reported.

Note that errors in mutations won't be caught by your error boundaries because
the error doesn't happen as part of rendering your components.

If you would like to render UI specifically in response to a mutation failure,
you can use `.catch` on your mutation call. For example:

```javascript
sendMessage(newMessageText).catch((error) => {
  // Do something with `error` here
});
```

If you're using an `async` handled function you can also use `try...catch`:

```javascript
try {
  await sendMessage(newMessageText);
} catch (error) {
  // Do something with `error` here
}
```

<Admonition type="caution" title="Reporting caught errors">

If you handle your mutation error, it will no longer become an unhandled promise
rejection. You may need to report this error to your exception handling service
manually.

</Admonition>

## Errors in action functions

Unlike queries and mutations, [actions](//docs/functions/actions.mdx) may have
side-effects and therefore can't be automatically retried by Convex when errors
occur. For example, say your action sends a email. If it fails part-way through,
Convex has no way of knowing if the email was already sent and can't safely
retry the action. It is responsibility of the caller to handle errors raised by
actions and retry if appropriate.

## Differences in error reporting between dev and prod

Using a dev deployment any server error thrown on the client will include the
original error message and a server-side stack trace to ease debugging.

Using a production deployment any server error will be redacted to only include
the name of the function and a generic `"Server Error"` message, with no stack
trace. Server
[application errors](/functions/error-handling/application-errors.mdx) will
still include their custom `data`.

Both development and production deployments log full errors with stack traces
which can be found on the [Logs](/dashboard/deployments/logs.md) page of a given
deployment.

## Application errors, expected failures

If you have expected ways your functions might fail, you can either return
different values or throw `ConvexError`s.

See [Application Errors](/functions/error-handling/application-errors.mdx).

## Read/write limit errors

To ensure uptime and guarantee performance, Convex will catch queries and
mutations that try to read or write too much data. These limits are enforced at
the level of a single query or mutation function execution. The exact limits are
listed in [Limits](/production/state/limits.mdx#transactions).

Documents are "scanned" by the database to figure out which documents should be
returned from `db.query`. So for example `db.query("table").take(5).collect()`
will only need to scan 5 documents, but `db.query("table").filter(...).first()`
might scan up to as many documents as there are in `"table"`, to find the first
one that matches the given filter.

The number of calls to `db.get` and `db.query` has a limit to prevent a single
query from subscribing to too many index ranges, or a mutation from reading from
too many ranges that could cause conflicts.

In general, if you're running into these limits frequently, we recommend
[indexing your queries](/database/reading-data/indexes/indexes.md) to reduce the
number of documents scanned, allowing you to avoid unnecessary reads. Queries
that scan large swaths of your data may look innocent at first, but can easily
blow up at any production scale. If your functions are close to hitting these
limits they will log a warning.

For information on other limits, see [here](/production/state/limits.mdx).

## Debugging Errors

See [Debugging](/functions/debugging.mdx) and specifically
[Finding relevant logs by Request ID](/functions/debugging.mdx#finding-relevant-logs-by-request-id).

## Related Components

<ComponentCardList
  items={[
    {
      title: "Workpool",
      description:
        "Workpool give critical tasks priority by organizing async operations into separate, customizable queues. Supports retries and parallelism limits.",
      href: "https://www.convex.dev/components/workpool",
    },
    {
      title: "Workflow",
      description:
        "Simplify programming long running code flows. Workflows execute durably with configurable retries and delays.",
      href: "https://www.convex.dev/components/workflow",
    },
  ]}
/>



================================================
FILE: npm-packages/docs/docs/generated-api/api.md
================================================
---
title: "api.js"
sidebar_position: 2
description:
  "Generated API references for your Convex functions and internal calls"
---

<Admonition type="caution" title="This code is generated">

These exports are not directly available in the `convex` package!

Instead you need to run `npx convex dev` to create `convex/_generated/api.js`
and `convex/_generated/api.d.ts`.

</Admonition>

These types require running code generation because they are specific to the
Convex functions you define for your app.

If you aren't using code generation, you can use
[`makeFunctionReference`](/api/modules/server#makefunctionreference) instead.

### api

An object of type `API` describing your app's public Convex API.

Its `API` type includes information about the arguments and return types of your
app's Convex functions.

The api object is used by client-side React hooks and Convex functions that run
or schedule other functions.

```javascript title="src/App.jsx"
import { api } from "../convex/_generated/api";
import { useQuery } from "convex/react";

const data = useQuery(api.messages.list);
```

### internal

Another object of type `API` describing your app's internal Convex API.

```js title="convex/upgrade.js"
import { action } from "../_generated/server";
import { internal } from "../_generated/api";

export default action({
  handler: async ({ runMutation }, { planId, ... }) => {
    // Call out to payment provider (e.g. Stripe) to charge customer
    const response = await fetch(...);
    if (response.ok) {
      // Mark the plan as "professional" in the Convex DB
      await runMutation(internal.plans.markPlanAsProfessional, { planId });
    }
  },
});
```



================================================
FILE: npm-packages/docs/docs/generated-api/data-model.md
================================================
---
title: "dataModel.d.ts"
sidebar_position: 1
description: "Generated TypeScript types for your database schema and documents"
---

<Admonition type="caution" title="This code is generated">

These exports are not directly available in the `convex` package!

Instead you must run `npx convex dev` to create
`convex/_generated/dataModel.d.ts`.

</Admonition>

Generated data model types.

## Types

### TableNames

Ƭ **TableNames**: `string`

The names of all of your Convex tables.

---

### Doc

Ƭ **Doc**`<TableName>`: `Object`

The type of a document stored in Convex.

#### Type parameters

| Name        | Type                                | Description                                             |
| :---------- | :---------------------------------- | :------------------------------------------------------ |
| `TableName` | extends [`TableNames`](#tablenames) | A string literal type of the table name (like "users"). |

---

### Id

An identifier for a document in Convex.

Convex documents are uniquely identified by their `Id`, which is accessible on
the `_id` field. To learn more, see [Document IDs](/database/document-ids.mdx).

Documents can be loaded using `db.get(tableName, id)` in query and mutation
functions.

IDs are just strings at runtime, but this type can be used to distinguish them
from other strings when type checking.

This is an alias of [`GenericId`](/api/modules/values#genericid) that is typed
for your data model.

#### Type parameters

| Name        | Type                                | Description                                             |
| :---------- | :---------------------------------- | :------------------------------------------------------ |
| `TableName` | extends [`TableNames`](#tablenames) | A string literal type of the table name (like "users"). |

---

### DataModel

Ƭ **DataModel**: `Object`

A type describing your Convex data model.

This type includes information about what tables you have, the type of documents
stored in those tables, and the indexes defined on them.

This type is used to parameterize methods like
[`queryGeneric`](/api/modules/server#querygeneric) and
[`mutationGeneric`](/api/modules/server#mutationgeneric) to make them type-safe.



================================================
FILE: npm-packages/docs/docs/generated-api/index.md
================================================
---
title: Generated Code
description:
  "Auto-generated JavaScript and TypeScript code specific to your app's API"
---

Convex uses code generation to create code that is specific to your app's data
model and API. Convex generates JavaScript files (`.js`) with TypeScript type
definitions (`.d.ts`).

Code generation isn't required to use Convex, but using the generated code will
give you more better autocompletion in your editor and more type safety if
you're using TypeScript.

To generate the code, run:

```
npx convex dev
```

This creates a `convex/_generated` directory that contains:

- [`api.js` and `api.d.ts`](./api.md)
- [`dataModel.d.ts`](./data-model.md)
- [`server.js` and `server.d.ts`](./server.md)



================================================
FILE: npm-packages/docs/docs/generated-api/server.md
================================================
---
title: "server.js"
sidebar_position: 4
description:
  "Generated utilities for implementing Convex queries, mutations, and actions"
---

<Admonition type="caution" title="This code is generated">

These exports are not directly available in the `convex` package!

Instead you must run `npx convex dev` to create `convex/_generated/server.js`
and `convex/_generated/server.d.ts`.

</Admonition>

Generated utilities for implementing server-side Convex query and mutation
functions.

## Functions

### query

▸ **query**(`func`): [`RegisteredQuery`](/api/modules/server#registeredquery)

Define a query in this Convex app's public API.

This function will be allowed to read your Convex database and will be
accessible from the client.

This is an alias of [`queryGeneric`](/api/modules/server#querygeneric) that is
typed for your app's data model.

#### Parameters

| Name   | Description                                                                             |
| :----- | :-------------------------------------------------------------------------------------- |
| `func` | The query function. It receives a [QueryCtx](server.md#queryctx) as its first argument. |

#### Returns

[`RegisteredQuery`](/api/modules/server#registeredquery)

The wrapped query. Include this as an `export` to name it and make it
accessible.

---

### internalQuery

▸ **internalQuery**(`func`):
[`RegisteredQuery`](/api/modules/server#registeredquery)

Define a query that is only accessible from other Convex functions (but not from
the client).

This function will be allowed to read from your Convex database. It will not be
accessible from the client.

This is an alias of
[`internalQueryGeneric`](/api/modules/server#internalquerygeneric) that is typed
for your app's data model.

#### Parameters

| Name   | Description                                                                             |
| :----- | :-------------------------------------------------------------------------------------- |
| `func` | The query function. It receives a [QueryCtx](server.md#queryctx) as its first argument. |

#### Returns

[`RegisteredQuery`](/api/modules/server#registeredquery)

The wrapped query. Include this as an `export` to name it and make it
accessible.

---

### mutation

▸ **mutation**(`func`):
[`RegisteredMutation`](/api/modules/server#registeredmutation)

Define a mutation in this Convex app's public API.

This function will be allowed to modify your Convex database and will be
accessible from the client.

This is an alias of [`mutationGeneric`](/api/modules/server#mutationgeneric)
that is typed for your app's data model.

#### Parameters

| Name   | Description                                                                             |
| :----- | :-------------------------------------------------------------------------------------- |
| `func` | The mutation function. It receives a [MutationCtx](#mutationctx) as its first argument. |

#### Returns

[`RegisteredMutation`](/api/modules/server#registeredmutation)

The wrapped mutation. Include this as an `export` to name it and make it
accessible.

---

### internalMutation

▸ **internalMutation**(`func`):
[`RegisteredMutation`](/api/modules/server#registeredmutation)

Define a mutation that is only accessible from other Convex functions (but not
from the client).

This function will be allowed to read and write from your Convex database. It
will not be accessible from the client.

This is an alias of
[`internalMutationGeneric`](/api/modules/server#internalmutationgeneric) that is
typed for your app's data model.

#### Parameters

| Name   | Description                                                                                      |
| :----- | :----------------------------------------------------------------------------------------------- |
| `func` | The mutation function. It receives a [MutationCtx](server.md#mutationctx) as its first argument. |

#### Returns

[`RegisteredMutation`](/api/modules/server#registeredmutation)

The wrapped mutation. Include this as an `export` to name it and make it
accessible.

---

### action

▸ **action**(`func`): [`RegisteredAction`](/api/modules/server#registeredaction)

Define an action in this Convex app's public API.

An action is a function which can execute any JavaScript code, including
non-deterministic code and code with side-effects, like calling third-party
services. They can be run in Convex's JavaScript environment or in Node.js using
the `"use node"` directive. They can interact with the database indirectly by
calling queries and mutations using the [`ActionCtx`](#actionctx).

This is an alias of [`actionGeneric`](/api/modules/server#actiongeneric) that is
typed for your app's data model.

#### Parameters

| Name   | Description                                                                        |
| :----- | :--------------------------------------------------------------------------------- |
| `func` | The action function. It receives an [ActionCtx](#actionctx) as its first argument. |

#### Returns

[`RegisteredAction`](/api/modules/server#registeredaction)

The wrapped function. Include this as an `export` to name it and make it
accessible.

---

### internalAction

▸ **internalAction**(`func`):
[`RegisteredAction`](/api/modules/server#registeredaction)

Define an action that is only accessible from other Convex functions (but not
from the client).

This is an alias of
[`internalActionGeneric`](/api/modules/server#internalactiongeneric) that is
typed for your app's data model.

#### Parameters

| Name   | Description                                                                                 |
| :----- | :------------------------------------------------------------------------------------------ |
| `func` | The action function. It receives an [ActionCtx](server.md#actionctx) as its first argument. |

#### Returns

[`RegisteredAction`](/api/modules/server#registeredaction)

The wrapped action. Include this as an `export` to name it and make it
accessible.

---

### httpAction

▸
**httpAction**(`func: (ctx: ActionCtx, request: Request) => Promise<Response>`):
[`PublicHttpAction`](/api/modules/server#publichttpaction)

#### Parameters

| Name   | Type                                                      | Description                                                                                                                                                                                         |
| :----- | :-------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `func` | `(ctx: ActionCtx, request: Request) => Promise<Response>` | The function. It receives an [`ActionCtx`](/api/modules/server#actionctx) as its first argument and a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) as its second argument. |

#### Returns

[`PublicHttpAction`](/api/modules/server#publichttpaction)

The wrapped function. Import this function from `convex/http.js` and route it to
hook it up.

## Types

### QueryCtx

Ƭ **QueryCtx**: `Object`

A set of services for use within Convex query functions.

The query context is passed as the first argument to any Convex query function
run on the server.

This differs from the [MutationCtx](#mutationctx) because all of the services
are read-only.

This is an alias of [`GenericQueryCtx`](/api/interfaces/server.GenericQueryCtx)
that is typed for your app's data model.

#### Type declaration

| Name      | Type                                                       |
| :-------- | :--------------------------------------------------------- |
| `db`      | [`DatabaseReader`](#databasereader)                        |
| `auth`    | [`Auth`](/api/interfaces/server.Auth.md)                   |
| `storage` | [`StorageReader`](/api/interfaces/server.StorageReader.md) |

---

### MutationCtx

Ƭ **MutationCtx**: `Object`

A set of services for use within Convex mutation functions.

The mutation context is passed as the first argument to any Convex mutation
function run on the server.

This is an alias of
[`GenericMutationCtx`](/api/interfaces/server.GenericMutationCtx) that is typed
for your app's data model.

#### Type declaration

| Name        | Type                                                       |
| :---------- | :--------------------------------------------------------- |
| `db`        | [`DatabaseWriter`](#databasewriter)                        |
| `auth`      | [`Auth`](/api/interfaces/server.Auth.md)                   |
| `storage`   | [`StorageWriter`](/api/interfaces/server.StorageWriter.md) |
| `scheduler` | [`Scheduler`](/api/interfaces/server.Scheduler.md)         |

---

### ActionCtx

Ƭ **ActionCtx**: `Object`

A set of services for use within Convex action functions.

The action context is passed as the first argument to any Convex action function
run on the server.

This is an alias of [`ActionCtx`](/api/modules/server#actionctx) that is typed
for your app's data model.

#### Type declaration

| Name           | Type                                                                                                                                                                         |
| :------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `runQuery`     | (`name`: `string`, `args`?: `Record<string, Value>`) => `Promise<Value>`                                                                                                     |
| `runMutation`  | (`name`: `string`, `args`?: `Record<string, Value>`) => `Promise<Value>`                                                                                                     |
| `runAction`    | (`name`: `string`, `args`?: `Record<string, Value>`) => `Promise<Value>`                                                                                                     |
| `auth`         | [`Auth`](/api/interfaces/server.Auth.md)                                                                                                                                     |
| `scheduler`    | [`Scheduler`](/api/interfaces/server.Scheduler.md)                                                                                                                           |
| `storage`      | [`StorageActionWriter`](/api/interfaces/server.StorageActionWriter.md)                                                                                                       |
| `vectorSearch` | (`tableName`: `string`, `indexName`: `string`, `query`: [`VectorSearchQuery`](/api/interfaces/server.VectorSearchQuery.md)) => `Promise<Array<{ _id: Id, _score: number }>>` |

---

### DatabaseReader

An interface to read from the database within Convex query functions.

This is an alias of
[`GenericDatabaseReader`](/api/interfaces/server.GenericDatabaseReader) that is
typed for your app's data model.

---

### DatabaseWriter

An interface to read from and write to the database within Convex mutation
functions.

This is an alias of
[`GenericDatabaseWriter`](/api/interfaces/server.GenericDatabaseWriter) that is
typed for your app's data model.



================================================
FILE: npm-packages/docs/docs/http-api/index.md
================================================
---
title: "Convex HTTP API"
sidebar_label: "Public HTTP API"
description: "Connecting to Convex directly with HTTP"
---

import Tabs from "@theme/Tabs"; import TabItem from "@theme/TabItem";

The public functions that define a deployment are exposed at public HTTP
endpoints.

## Convex value format

Each of the HTTP APIs take a `format` query param that describes how documents
are formatted. Currently the only supported value is `json`. See our
[types page](/database/types#convex-values) for details. Note that for
simplicity, the `json` format does not support all Convex data types as input,
and uses overlapping representation for several data types in output. We plan to
add a new format with support for all Convex data types in the future.

## API authentication

The Functions API can be optionally authenticated as a user via a bearer token
in a `Authorization` header. The value is `Bearer <access_key>` where the key is
a token from your auth provider. See the
[under the hood](/auth/clerk#under-the-hood) portion of the Clerk docs for
details on how this works with Clerk.

Streaming export and streaming import requests require deployment admin
authorization via the HTTP header `Authorization`. The value is
`Convex <access_key>` where the access key comes from "Deploy key" on the Convex
dashboard and gives full read and write access to your Convex data.

## Functions API

### POST `/api/query`, `/api/mutation`, `/api/action`

These HTTP endpoints allow you to call Convex functions and get the result as a
value.

You can find your backend deployment URL on the dashboard
[Settings](/dashboard/deployments/settings.md) page, then the API URL will be
`<CONVEX_URL>/api/query` etc., for example:

<Tabs>
<TabItem value="shell" label="Shell">

```
curl https://acoustic-panther-728.convex.cloud/api/query \
   -d '{"path": "messages:list", "args": {}, "format": "json"}' \
   -H "Content-Type: application/json"
```

</TabItem>
<TabItem value="js" label="NodeJS">

```js
const url = "https://acoustic-panther-728.convex.cloud/api/query";
const request = { path: "messages:list", args: {}, format: "json" };

const response = fetch(url, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify(request),
});
```

</TabItem>
<TabItem value="py" label="Python">

```py
import requests

url = "https://acoustic-panther-728.convex.cloud/api/query"
headers = {"accept": "application/json"}
body = {"path": "messages:list", "args": {}, "format": "json"}

response = requests.post(url, headers=headers, json=body)
```

</TabItem>
</Tabs>

**JSON Body parameters**

| Name   | Type   | Required | Description                                                                                                  |
| ------ | ------ | -------- | ------------------------------------------------------------------------------------------------------------ |
| path   | string | y        | Path to the Convex function formatted as a string as defined [here](/functions/query-functions#query-names). |
| args   | object | y        | Named argument object to pass to the Convex function.                                                        |
| format | string | n        | Output format for values. Valid values: [`json`]                                                             |

**Result JSON on success**

| Field Name | Type         | Description                                            |
| ---------- | ------------ | ------------------------------------------------------ |
| status     | string       | "success"                                              |
| value      | object       | Result of the Convex function in the requested format. |
| logLines   | list[string] | Log lines printed out during the function execution.   |

**Result JSON on error**

| Field Name   | Type         | Description                                                                                              |
| ------------ | ------------ | -------------------------------------------------------------------------------------------------------- |
| status       | string       | "error"                                                                                                  |
| errorMessage | string       | The error message.                                                                                       |
| errorData    | object       | Error data within an [application error](/functions/error-handling/application-errors) if it was thrown. |
| logLines     | list[string] | Log lines printed out during the function execution.                                                     |

### POST `/api/run/{functionIdentifier}`

This HTTP endpoint allows you to call arbitrary Convex function types with the
path in the request URL and get the result as a value. The function identifier
is formatted as a string as defined
[here](/functions/query-functions#query-names) with a `/` replacing the `:`.

You can find your backend deployment URL on the dashboard
[Settings](/dashboard/deployments/settings.md) page, then the API URL will be
`<CONVEX_URL>/api/run/{functionIdentifier}` etc., for example:

<Tabs>
<TabItem value="shell" label="Shell">

```
curl https://acoustic-panther-728.convex.cloud/api/run/messages/list \
   -d '{"args": {}, "format": "json"}' \
   -H "Content-Type: application/json"
```

</TabItem>
<TabItem value="js" label="NodeJS">

```js
const url = "https://acoustic-panther-728.convex.cloud/api/run/messages/list";
const request = { args: {}, format: "json" };

const response = fetch(url, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify(request),
});
```

</TabItem>
<TabItem value="py" label="Python">

```py
import requests

url = "https://acoustic-panther-728.convex.cloud/api/run/messages/list"
headers = {"accept": "application/json"}
body = {"args": {}, "format": "json"}

response = requests.get(url, headers=headers, body=json)
```

</TabItem>
</Tabs>

**JSON Body parameters**

| Name   | Type   | Required | Description                                                          |
| ------ | ------ | -------- | -------------------------------------------------------------------- |
| args   | object | y        | Named argument object to pass to the Convex function.                |
| format | string | n        | Output format for values. Defaults to `json`. Valid values: [`json`] |

**Result JSON on success**

| Field Name | Type         | Description                                            |
| ---------- | ------------ | ------------------------------------------------------ |
| status     | string       | "success"                                              |
| value      | object       | Result of the Convex function in the requested format. |
| logLines   | list[string] | Log lines printed out during the function execution.   |

**Result JSON on error**

| Field Name   | Type         | Description                                                                                              |
| ------------ | ------------ | -------------------------------------------------------------------------------------------------------- |
| status       | string       | "error"                                                                                                  |
| errorMessage | string       | The error message.                                                                                       |
| errorData    | object       | Error data within an [application error](/functions/error-handling/application-errors) if it was thrown. |
| logLines     | list[string] | Log lines printed out during the function execution.                                                     |



================================================
FILE: npm-packages/docs/docs/platform-apis/embedded-dashboard.mdx
================================================
---
title: Embedding the dashboard
sidebar_position: 20
---

Convex provides a hosted dashboard that is embeddable via iframe. Embedding the
dashboard is useful for developers building AI app generators, like
[Convex Chef](https://chef.convex.dev).

You can embed the Convex dashboard by adding an `<iframe>` to
https://dashboard-embedded.convex.dev. Normally, the embedded dashboard requires
the user to enter credentials to use it, but you may skip the login step by
providing deployment credentials via a
[`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage)
to the iframe.

When using `postMessage`, there may be a delay until the credentials are
received. The default login page will be shown until credentials are received,
so we recommend adding a delay before displaying the rendered iframe to avoid
flashing a login screen.

<Admonition
  type="caution"
  title="This will share the credentials of the deployment client-side"
>
  When using `postMessage` to authenticate with the embedded dashboard, the
  deployment key will be shared with the end-user. This means that the user gets
  full control of the deployment. Do this only when sharing credentials with the
  user is safe, such as with an [OAuth
  Application](/platform-apis/oauth-applications) (for Convex deployments that
  are in the Convex account of the end user), or deploy keys [created with the
  Management API](/management-api/create-deploy-key) (if the Convex deployment
  is in a Convex account that the end user doesn’t control).
</Admonition>

Required information for `postMessage`:

- `deploymentUrl`: The deployment cloud URL. Returned when creating the project
  with the [Create project API](/management-api/create-project)
- `deploymentName`: The readable identifier for the deployment. Returned when
  creating the project with the
  [Create project API](/management-api/create-project).
- `adminKey`: A deploy key scoped to the specified `deploymentName`. Can be
  retrieved with the [Create deploy key API](/management-api/create-deploy-key).

Optional configuration:

- `visiblePages`: An array of page keys to show in the sidebar. If not provided,
  all pages are shown. If an empty array is provided, the sidebar will be
  hidden. Available page keys: `"health"`, `"data"`, `"functions"`, `"files"`,
  `"schedules"`, `"logs"`, `"history"`, `"settings"`. Please note that this only
  changes the user interface on the client side, and does not strictly prevent
  the user from accessing the functionality exposed by the pages.

Here's an example of the Convex dashboard embedded in a React application:

```tsx
import { useEffect, useRef } from "react";

export function Dashboard({
  deploymentUrl,
  deploymentName,
  deployKey,
  visiblePages,
}: {
  deploymentUrl: string;
  deploymentName: string;
  deployKey: string;
  visiblePages?: string[];
}) {
  const iframeRef = useRef<HTMLIFrameElement>(null);

  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // We first wait for the iframe to send a dashboard-credentials-request message.
      // This makes sure that we don't send the credentials until the iframe is ready.
      if (event.data?.type !== "dashboard-credentials-request") {
        return;
      }
      iframeRef.current?.contentWindow?.postMessage(
        {
          type: "dashboard-credentials",
          adminKey: deployKey,
          deploymentUrl,
          deploymentName,
          // Optional: specify which pages to show
          visiblePages,
        },
        "*",
      );
    };

    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, [deploymentUrl, adminKey, deploymentName, visiblePages]);

  return (
    <iframe
      ref={iframeRef}
      // You can also default on other pages, for instance /functions, /files or /logs
      src="https://dashboard-embedded.convex.dev/data"
      allow="clipboard-write"
    />
  );
}
```



================================================
FILE: npm-packages/docs/docs/platform-apis/oauth-applications.mdx
================================================
---
title: OAuth Applications
sidebar_position: 10
---

# OAuth Applications

Convex allows third-party app developers to manage a user's projects on their
behalf through **Application Tokens**.

Application tokens are obtained through the OAuth authorization code flow, which
will be described in detail below.

There are two types of OAuth tokens:

- Team-scoped tokens that are authorized to create new projects, create new
  deployments within projects, and have read and write access to data and
  functions to every project on the team.
- Project-scoped tokens that can create new deployments and access data and
  functions within a specific project.

<Admonition type="note">
  All application tokens are also scoped to the permissions of the member that
  authorized usage. If the member is removed from the team, or their permissions
  changed, the permissions of the token will also change.
</Admonition>

## Creating an application

To obtain application tokens, you'll first have to register an OAuth application
with Convex, which can be done in your
[Team Settings](https://dashboard.convex.dev/team/settings/applications/oauth-apps).

To register an application, you'll need to provide a name for the application
and a set of redirect URIs. Redirect URIs are used to return users to your
application once they have authorized you to access their Convex team or
project. You may add up to 20 redirect URIs, including ones pointing to
[localhost](http://localhost) for testing.

Once you've created your application, it will be in the "Unverified" state. In
the Unverified state, you'll be able to obtain application tokens for your own
team, but not for other teams. We recommend testing your application in the
Unverified state before requesting verification.

You may request verification by clicking the ⋮ button next to your application,
and clicking "Request Verification".

### Verification requirements

To have your application be verified and be accessible for all Convex users, it
must meet the following criteria:

- The application description has an explanation of the capabilities and planned
  future capabilities of your application.
- The application name, redirect URIs, and content of the redirect URIs do not
  attempt to misrepresent another organization, business, or entity.
- The listed redirect URIs belong to your organization.

The Convex team will respond to your verification request by email if more
information is required.

## Implementing OAuth

Convex implements [OAuth 2.0](https://oauth.net/2/) (RFC 6749)'s
[Authorization Code Grant](https://oauth.net/2/grant-types/authorization-code/)
flow. Convex also optionally supports the
[PKCE extension](https://oauth.net/2/pkce/) (RFC 7636) to improve security.

- Convex provides two _authorization endpoint_ URLs, depending on whether you
  are generating team-scoped or project-scoped tokens:
  - `https://dashboard.convex.dev/oauth/authorize/team`
  - `https://dashboard.convex.dev/oauth/authorize/project`
- Convex's **token endpoint** is `https://api.convex.dev/oauth/token`.

We'll walk through the authorization flow step by step. However, we recommend
using an OAuth 2.0 client library to help construct the required URLs and API
calls.

## Step 1: Redirect the user to Convex's authorization endpoint

In your application, navigate the user to:

`https://dashboard.convex.dev/oauth/authorize[TOKEN_SCOPE]?client_id=[CLIENT_ID]&redirect_uri=[REDIRECT_URI]&response_type=code&state=[STATE]`

- `[TOKEN_SCOPE]` should be replaced with "team" or "project"
- `[CLIENT_ID]` should be replaced with your app's client ID as assigned by
  Convex.
- `[REDIRECT_URI]` is a URL on your application's domain. The user will be
  redirected back to that URL after authorizing.
  - **Important note**: You'll need to provide us with all the redirect URIs
    that your application might use (likely just one). This is required to
    prevent a malicious application from masquerading as yours, but redirecting
    to a different callback.
- `[STATE]` is an optional arbitrary string. It's up to you how to encode it,
  but your application will use this to decide what to do with the auth token
  after it receives it.

**Remember to URI-encode all the parameters!**

This brings the user to a page that looks like this:

![OAuth authorization page](/screenshots/oauth-page.png)

From here, the user can select which team they'd like to authorize access to. If
using the project flow, the user will also be able to select an existing project
or create a new project. After they click "Authorize", the page will redirect to
your redirect URL.

## Step 2: Receive the callback

The authorization endpoint brings the user to your redirect URI with the `code`
and `state` query parameters populated. If your `redirect_uri` was
`https://yourapp.example.com/cb`, the result would look like:

`https://yourapp.example.com/cb?code=[CODE]&state=[STATE]`

where `state` is the same value you provided earlier, and `code` is a randomly
generated string like `895c59eb98504a5bbaa7ad2e49cf4817`. This code **is not**
the final auth token - you'll need to exchange it for one within 10 minutes.

## Step 3: Exchange the authorization code for a project token

Your application should make an HTTP POST request to the following endpoint:

`https://api.convex.dev/oauth/token`

The body should have content type `application/x-www-form-urlencoded` and look
like the following:

`client_id=[CLIENT_ID]&client_secret=[CLIENT_SECRET]&grant_type=authorization_code&redirect_uri=[REDIRECT_URI]&code=[CODE]`

- `client_id` is the same one used to construct the authorization endpoint URL.
- `client_secret` is your app's secret assigned by Convex.
- `grant_type` is always `authorization_code`.
- `redirect_uri` is the same one used to construct the authorization endpoint
  URL.
- `code` is the authorization code provided to your callback.
  - Note that a `code` can only be exchanged _once_ for an access token.

If all provided values are correct, Convex's API returns a JSON response
containing:

```jsx
{
	"access_token": "team:my-team|AAAAAA==",
	"token_type": "bearer"
}
```

The `access_token` is the application token!

# Using PKCE (RFC 7636)

Convex supports this extension to the Authorization Code grant type. Only the
`S256` method is allowed. PKCE protects a leaked authorization code from being
used by an attacker even if your client secret is not private (e.g. if it has to
be embedded in a client-side application).

OAuth client libraries typically support PKCE already, but to implement it
manually:

- Each time you request user authorization, before redirecting the user,
  construct a random string called the `code_verifier`. It's recommended that
  you generate a random 32-byte value and base64url-encode it.
- Calculate `code_challenge = base64url(sha256(code_verifier))`. This will be a
  43-character string.
- Redirect the user to authorization endpoint as before
  (`/oauth/authorize/[TOKEN_SCOPE]`), but additionally provide the parameters
  `code_challenge=[CODE_CHALLENGE]&code_challenge_method=S256`.
- When exchanging the authorization code for a token, additionally provide the
  parameter `code_verifier=[CODE_VERIFIER]`.



================================================
FILE: npm-packages/docs/docs/production/contact.md
================================================
---
title: "Contact Us"
sidebar_position: 500
description:
  "Get support, provide feedback, stay updated with Convex releases, and report
  security vulnerabilities through our community channels."
---

Convex is a rapidly developing platform and we're always eager to hear your
feedback.

## Feedback and Support

Please share any general questions, feature requests, or product feedback in our
[Convex Discord Community](https://convex.dev/community). We're particularly
excited to see what you build on Convex!

Any specific support questions that aren't able to be adequately addressed on
our Discord channel can be directed to
[support@convex.dev](mailto:support@convex.dev).

## Following Convex

Release notes are shared on [Convex News](https://news.convex.dev/tag/releases)
and the [Convex Discord Community](https://convex.dev/community).

Product announcements, articles and demos are posted on
[Stack](https://stack.convex.dev/), [News](https://news.convex.dev/),
[our YouTube channel](https://www.youtube.com/channel/UCoC_9mdiPwIu1sDxDtGQggQ),
and [X (fka Twitter)](https://x.com/convex).

## Vulnerability Disclosure

If you believe you've discovered a bug in Convex's security, please get in touch
at [security@convex.dev](mailto:security@convex.dev) and we'll get back to you
within 24 hours. We request that you not publicly disclose the issue until we
have had a chance to address it.



================================================
FILE: npm-packages/docs/docs/production/environment-variables.mdx
================================================
---
title: "Environment Variables"
sidebar_label: "Environment Variables"
sidebar_position: 2
description: "Store and access environment variables in Convex"
---

Environment variables are key-value pairs that are useful for storing values you
wouldn't want to put in code or in a table, such as an API key. You can set
environment variables in Convex through the dashboard, and you can access them
in [functions](/functions.mdx) using `process.env`.

## Setting environment variables

Under [Deployment Settings](/dashboard/deployments/settings.md) in the
Dashboard, you can see a list of environment variables in the current
deployment.
![Environment Variables Table](/screenshots/environment_variables_table.png)

You can add up to 100 environment variables. Environment variable names cannot
be more than 40 characters long, and they must start with a letter and only
contain letters numbers, and underscores. Environment variable values cannot be
larger than 8KB.

You can modify environment variables using the pencil icon button:

![Edit Environment Variable](/screenshots/edit_environment_variable.png)

Environment variables can also be viewed and modified with the
[command line](/cli.md#read-and-write-environment-variables).

```sh
npx convex env list
npx convex env set API_KEY secret-api-key
```

### Using environment variables in dev and prod deployments

Since environment variables are set per-deployment, you can use different values
for the same key in dev and prod deployments. This can be useful for when you
have different external accounts you'd like to use depending on the environment.
For example, you might have a dev and prod SendGrid account for sending emails,
and your function expects an environment variable called `SENDGRID_API_KEY` that
should work in both environments.

If you expect an environment variable to be always present in a function, you
must add it to **all** your deployments. In this example, you would add an
environment variable with the name `SENDGRID_API_KEY` to your dev and prod
deployments, with a different value for dev and prod.

## Accessing environment variables

You can access environment variables in Convex functions using
`process.env.KEY`. If the variable is set it is a `string`, otherwise it is
`undefined`. Here is an example of accessing an environment variable with the
key `GIPHY_KEY`:

```javascript
function giphyUrl(query) {
  return (
    "https://api.giphy.com/v1/gifs/translate?api_key=" +
    process.env.GIPHY_KEY +
    "&s=" +
    encodeURIComponent(query)
  );
}
```

Note that you should not condition your Convex function exports on environment
variables. The set of Convex functions that can be called is determined during
deployment and is not reevaluated when you change an environment variable. The
following code will throw an error at runtime, if the DEBUG environment variable
changes between deployment and calling the function.

```javascript
// THIS WILL NOT WORK!
export const myFunc = process.env.DEBUG ? mutation(...) : internalMutation(...);
```

Similarly, environment variables used in cron definitions will only be
reevaluated on deployment.

## System environment variables

The following environment variables are always available in Convex functions:

- `CONVEX_CLOUD_URL` - Your deployment URL (eg.
  `https://dusty-nightingale-847.convex.cloud`) for use with Convex clients.
- `CONVEX_SITE_URL` - Your deployment site URL (eg.
  `https://dusty-nightingale-847.convex.site`) for use with
  [HTTP Actions](/functions/http-actions.mdx)

## Project environment variable defaults

You can set up default environment variable values for a project for development
and preview deployments in Project Settings.

![Project Default Environment Variables](/screenshots/project_default_environment_variables.png)

These default values will be used when creating a new development or preview
deployment, and will have no effect on existing deployments (they are not kept
in sync).

The Deployment Settings will indicate when a deployment has environment
variables that do not match the project defaults.
![Environment Variable Default Mismatch](/screenshots/environment_variable_default_diff.png)



================================================
FILE: npm-packages/docs/docs/production/multiple-repos.mdx
================================================
---
title: Multiple Repositories
sidebar_label: Multiple Repositories
description: "Use Convex in multiple repositories"
sidebar_position: 180
---

import Functions from "!!raw-loader!@site/../private-demos/snippets/convex/tsGeneration.ts";
import API from "!!raw-loader!@site/../private-demos/snippets/api.ts";
import Frontend from "!!raw-loader!@site/../private-demos/snippets/src/tsGeneration.tsx";

Your TypeScript clients can call Convex functions in a type-safe way outside of
the repository where your Convex functions are defined. By following the steps
below, you can generate a file similar to `convex/_generated/api.d.ts` that you
can check in and use in a separate repository.

<BetaAdmonition feature="TypeScript API generation" verb="is" />

<StepByStep>
  <Step title="Install the Convex Helpers npm package">
    Install the `convex-helpers` package, which contains a CLI command to generate an api file.

    ```sh
    npm install convex-helpers
    ```

  </Step>
  <Step title="Run a command to generate a TypeScript API file">
    Running this command will call into your configured Convex deployment and generate an `api.ts` file based
    on it. You can see additional flags by passing `--help` to the command.

    ```sh
    npx convex-helpers ts-api-spec
    ```

  </Step>
</StepByStep>

## Example

Below are code snippets of what this workflow looks like in action. These
snippets include three different files:

- `convex/messages.ts` - contains Convex function definitions
- `api.ts` - a generated file from running the command above
- `src/App.tsx` - frontend code in a separate repository where `api.ts` is
  checked in

<TSAndJSSnippet
  title="convex/messages.ts"
  snippets="send"
  sourceTS={Functions}
  sourceJS={Functions}
/>

<TSAndJSSnippet title="api.ts" sourceTS={API} sourceJS={API} />

<TSAndJSSnippet
  title="src/App.tsx"
  sourceTS={Frontend}
  sourceJS={Frontend}
  highlightPatterns={["import { api } from"]}
/>

## Limits

- Argument and return value validators are not required, but they will enrich
  the types of your TypeScript API. Where validators aren't defined, we default
  to `v.any()` as the validator.
- You cannot call internal functions from outside of your Convex deployment.



================================================
FILE: npm-packages/docs/docs/production/pause-deployment.mdx
================================================
---
title: "Pausing a Deployment"
sidebar_label: "Pausing a Deployment"
sidebar_position: 4
description: "Temporarily disable a deployment without deleting data"
---

Pausing a deployment is a way to "turn off" a deployment without deleting any
data. This can be useful if you have an action that is blowing through a
third-party API quota and you just need a big red stop button.

When a deployment is paused:

- New function calls will return an error.
- Scheduled jobs will queue and run when the deployment is resumed.
- Cron jobs will be skipped.
- Everything else (e.g. code push, dashboard edits) should work as usual.

**This is important!** All new function calls will return an error when a
deployment is paused, so if you are running an app in production you may want to
consider alternatives like pushing code that disables a feature you are trying
to "turn off". We recommend testing this feature in a dev deployment first
before pausing a production deployment.

![Pause Deployment Button](/screenshots/pause_deployment.png)

A deployment can be resumed with this button on the same page:

![Resume Deployment](/screenshots/resume_deployment.png)



================================================
FILE: npm-packages/docs/docs/production/project-configuration.mdx
================================================
---
title: "Project Configuration"
sidebar_label: "Project Configuration"
sidebar_position: 3
description:
  "Configure your Convex project for development and production deployment using
  convex.json, environment variables, and deployment settings."
---

## Local development

When you're developing locally you need two pieces of information:

1. The name of your dev deployment. This is where your functions are pushed to
   and served from. It is stored in the `CONVEX_DEPLOYMENT` environment
   variable. `npx convex dev` writes it to the `.env.local` file.
2. The URL of your dev deployment, for your client to connect to. The name of
   the variable and which file it can be read from varies between client
   frameworks. `npx convex dev` writes the URL to the `.env.local` or `.env`
   file.

## Production deployment

You should only be deploying to your production deployment once you have tested
your changes on your local deployment. When you're ready, you can deploy either
via a hosting/CI provider or from your local machine.

For a CI environment you can follow the
[hosting](/production/hosting/hosting.mdx) docs. `npx convex deploy` run by the
CI pipeline will use the `CONVEX_DEPLOY_KEY`, and the frontend build command
will use the deployment URL variable, both configured in your CI environment.

You can also deploy your backend from your local machine. `npx convex deploy`
will ask for a confirmation and then deploy to the production deployment in the
same project as your configured development `CONVEX_DEPLOYMENT`.

## `convex.json`

Additional project configuration can be specified in the `convex.json` file in
the root of your project (in the same directory as your `package.json`).

You can use the JSON schema for editor validation by adding a `$schema`
property:

```json title="convex.json"
{
  "$schema": "./node_modules/convex/schemas/convex.schema.json"
}
```

The file supports the following configuration options:

### Changing the `convex/` folder name or location

You can choose a different name or location for the `convex/` folder via the
`functions` field. For example, Create React App doesn't allow importing from
outside the `src/` directory, so if you're using Create React App you should
have the following config:

```json title="convex.json"
{
  "$schema": "./node_modules/convex/schemas/convex.schema.json",
  "functions": "src/convex/"
}
```

### Installing packages on the server

You can specify which packages used by Node actions should be installed on the
server, instead of being bundled, via the `node.externalPackages` field.
[Read more](/functions/bundling.mdx#external-packages).

### Importing the generated functions API via `require()` syntax

The Convex code generation can be configured to generate a CommonJS-version of
the `_generated/api.js` file via the `generateCommonJSApi` field.
[Read more](/client/javascript/node.mdx#javascript-with-commonjs-require-syntax).

### Configuring the Node.js version

You can specify which Node.js version is used by Node actions via the
`node.nodeVersion` field. The currently supported values are `"20"` and `"22"`.
[Read more](/functions/runtimes.mdx#nodejs-version-configuration).

<Admonition type="info" title="Convex version required">

To change the Node.js version used by your project, you must use the `convex`
NPM package version 1.27.0 or later.

</Admonition>

```json title="convex.json"
{
  "$schema": "./node_modules/convex/schemas/convex.schema.json",
  "node": {
    "nodeVersion": "22"
  }
}
```

Note: This configuration is not supported when running the self-hosted Convex
backend. The node version that is specified in the
[.nvmrc](https://github.com/get-convex/convex-backend/blob/main/.nvmrc) will be
used instead.

### Using static code generation (beta)

Convex's code generation heavily relies on TypeScript's type inference. This
makes updates snappy and jump-to-definition work for the `api` and `internal`
objects, but it often slows down with large codebases.

If you're running into language server performance issues, you can instruct the
Convex CLI to generate static versions of the `_generated/api.d.ts` and
`_generated/dataModel.d.ts`:

```json title="convex.json"
{
  "$schema": "./node_modules/convex/schemas/convex.schema.json",
  "codegen": {
    "staticApi": true,
    "staticDataModel": true
  }
}
```

This will greatly improve autocomplete and incremental typechecking performance,
but it does have some tradeoffs:

- These types only update when `convex dev` is running.
- Jump-to-definition no longer works. To find `api.example.f`, you'll need to
  manually open `convex/example.ts` and find `f`.
- Functions no longer have return type inference and will default to `v.any()`
  if they don't have a returns validator.
- [TypeScript enums](https://www.typescriptlang.org/docs/handbook/enums.html) no
  longer work in schema or API definitions. Use unions of string literal types
  instead.

This feature is currently in beta, and we'd love to improve these limitations.
Let us know if you run into any issues or have any feedback!

### Configuring the TypeScript compiler

By default, Convex will use the `tsc` binary installed in your project for
typechecking. If you would like to use the TypeScript 7 native preview instead,
you can set the `typescriptCompiler` option to `tsgo`. Note that
`@typescript/native-preview` must be installed in your project to use `tsgo`.

<Admonition type="info" title="Convex version required">

To use the TypeScript 7 native preview, you must use the `convex` NPM package
version 1.31.1 or later.

</Admonition>

```json title="convex.json"
{
  "$schema": "./node_modules/convex/schemas/convex.schema.json",
  "typescriptCompiler": "tsgo"
}
```

### Configuring bundler options

Convex includes sourcemaps when bundling your source code to provide stack
traces and to display your code on the dashboard. If your code bundle is
especially large, you can improve CLI upload times by excluding the source code
content from the bundle. Set the `includeSourcesContent` property to `false` in
the `bundler` options. Stack traces will continue to function as usual, but you
will no longer be able to view your source code in the dashboard.

<Admonition type="info" title="Convex version required">

This configuration option is only available in version 1.31.3 or later of the
`convex` NPM package.

</Admonition>

```json title="convex.json"
{
  "$schema": "./node_modules/convex/schemas/convex.schema.json",
  "bundler": {
    "includeSourcesContent": false
  }
}
```

### Configuring WorkOS AuthKit integration

If you're using [WorkOS AuthKit](/auth/authkit/index.mdx) for authentication,
you can configure automatic provisioning (development only) and configuration of
WorkOS environments via the `authKit` field.

<Admonition type="info" title="Convex version required">

This configuration option is only available in version 1.31.6 or later of the
`convex` NPM package.

</Admonition>

```json title="convex.json"
{
  "$schema": "./node_modules/convex/schemas/convex.schema.json",
  "authKit": {
    "dev": {
      "configure": {
        "redirectUris": ["http://localhost:3000/callback"],
        "appHomepageUrl": "http://localhost:3000",
        "corsOrigins": ["http://localhost:3000"]
      },
      "localEnvVars": {
        "WORKOS_CLIENT_ID": "${authEnv.WORKOS_CLIENT_ID}",
        "WORKOS_API_KEY": "${authEnv.WORKOS_API_KEY}",
        "NEXT_PUBLIC_WORKOS_REDIRECT_URI": "http://localhost:3000/callback"
      }
    },
    "preview": {
      "configure": {
        "redirectUris": ["https://${buildEnv.VERCEL_BRANCH_URL}/callback"],
        "appHomepageUrl": "https://${buildEnv.VERCEL_PROJECT_PRODUCTION_URL}",
        "corsOrigins": ["https://${buildEnv.VERCEL_BRANCH_URL}"]
      }
    },
    "prod": {
      "environmentType": "production",
      "configure": {
        "redirectUris": [
          "https://${buildEnv.VERCEL_PROJECT_PRODUCTION_URL}/callback"
        ],
        "appHomepageUrl": "https://${buildEnv.VERCEL_PROJECT_PRODUCTION_URL}",
        "corsOrigins": ["https://${buildEnv.VERCEL_PROJECT_PRODUCTION_URL}"]
      }
    }
  }
}
```

This configuration controls how WorkOS environments are provisioned and
configured for each deployment type (dev, preview, prod). See the
[Automatic AuthKit Configuration](/auth/authkit/auto-provision.mdx) guide for
complete details.



================================================
FILE: npm-packages/docs/docs/production/hosting/custom.mdx
================================================
---
title: "Custom Domains & Hosting"
sidebar_label: "Custom Domains & Hosting"
description:
  "Serve requests from any domains and host your frontend on any static hosting
  provider, such as GitHub."
sidebar_position: 100
---

## Custom Domains

You can configure a custom domain, like `api.example.com`, to serve HTTP actions
or Convex functions from your production Convex deployments. The settings for
this feature are accessed through the Project Settings page on any of your
projects.

![Add Custom Domain](/screenshots/add_custom_domain.png)

After you enter a domain, you will be shown which records to set on your DNS
provider. Some popular DNS providers that you can use to buy a domain are
Cloudflare and GoDaddy. We will verify your domain in the background, and once
these records are set, you will see a green checkmark.

When you see that checkmark, your backend will now serve traffic from that
domain. The first request may take up to a minute because Convex will have to
mint a new SSL certificate.

Reach out to support@convex.dev if you have any questions about getting set up!

<ProFeatureUpsell feature="Custom domains" verb="require" />

### Hosting with a Custom Domain

To use a custom domain to serve your Convex functions, there's an additional
step: override the `CONVEX_CLOUD_URL` environment variable.

![Override system environment variables](/screenshots/override_system_env_vars.png)

Then re-deploy your project. This may entail clicking "Redeploy" in Vercel or
Netlify, or directly running `npx convex deploy --cmd 'npm run build'`. The
newly deployed code will access your Convex functions through your custom
domain.

The `CONVEX_CLOUD_URL` environment variable is used in several places:

- `npx convex deploy --cmd '...'` sets `CONVEX_URL` (or similarly named) for
  your frontend to connect websockets and HTTP clients
- In your Convex functions, it is available as `process.env.CONVEX_CLOUD_URL`
- File storage URLs: `ctx.storage.getUrl(id)` and
  `ctx.storage.generateUploadUrl()`
- Generate an OpenAPI spec with `npx convex function-spec --prod`

You may also override the `CONVEX_SITE_URL` environment variable to be a custom
HTTP Action domain.

- In your Convex functions, it is available as `process.env.CONVEX_SITE_URL`
- It may be used for webhooks
- It may be used in `auth.config.ts` as the `issuer` for Convex Auth

## Custom Hosting

If you're using only Convex for backend functionality you can host your web app
on any static hosting provider. This guide will use
[GitHub Pages](https://pages.github.com/) as an example.

If you're using Next.js or other framework with server functionality you'll need
to use a provider that supports it, such as
[Netlify](/production/hosting/netlify.mdx) or
[Vercel](/production/hosting/vercel.mdx). You can still host Next.js statically
via a
[static export](https://nextjs.org/docs/pages/building-your-application/deploying/static-exports).

### Configure your build

First make sure that you have a working build process.

In this guide we'll set up a local build, but your hosting provider might
support a remote build. For example see
[Vite's Deploying to GitHub Pages guide](https://vitejs.dev/guide/static-deploy.html#github-pages)
which uses GitHub actions.

We'll use Vite and GitHub Pages as an example.

1. Configure <JSDialectFileName name="vite.config.mts" />:

   ```ts title="vite.config.mts"
   import { defineConfig } from "vite";
   import react from "@vitejs/plugin-react";

   // https://vitejs.dev/config/
   export default defineConfig({
     plugins: [react()],
     // highlight-next-line
     build: {
       // highlight-next-line
       outDir: "docs",
       // highlight-next-line
     },
     // highlight-next-line
     base: "/some-repo-name/",
   });
   ```

   The `build.outDir` field specifies where Vite will place the production
   build, and we use `docs` because that's the directory GitHub Pages allow
   hosting from.

   The `base` field specifies the URL path under which you'll serve your app, in
   this case we will serve on
   `https://<some username>.github.io/<some repo name>`.

### Configure your hosting provider

With GitHub Pages, you can choose whether you want to include your build output
in your main working branch or publish from a separate branch.

Open your repository's GitHub page > _Settings_ > _Pages_. Under _Build and
deployment_ > _Source_ choose `Deploy from a branch`.

Under _branch_ choose a branch (if you want to use a separate branch, push at
least one commit to it first), and the `/docs` folder name. Hit _Save_.

### Build and deploy to Convex and GitHub Pages

To manually deploy to GitHub pages follow these steps:

1. Checkout the branch you chose to publish from
2. Run `npx convex deploy --cmd 'npm run build'` and confirm that you want to
   push your current backend code to your **production** deployment
3. Commit the build output changes and push to GitHub.

### How it works

First, `npx convex deploy` runs through these steps:

1. It sets the `VITE_CONVEX_URL` (or similarly named) environment variable to
   your **production** Convex deployment.
2. It invokes the frontend framework build process, via `npm run build`. The
   build process reads the environment variable and uses it to point the built
   site at your **production** deployment.
3. It deploys your backend code, from the `convex` directory, to your
   **production** deployment.

Afterwards you deploy the built frontend code to your hosting provider. In this
case you used Git, but for other providers you might use a different method,
such as an old-school FTP request.

You can use `--cmd-url-env-var-name` to customize the variable name used by your
frontend code if the `deploy` command cannot infer it, like

```sh
npx convex deploy --cmd-url-env-var-name CUSTOM_CONVEX_URL --cmd 'npm run build'
```

### Authentication

You will want to configure your [authentication](/auth.mdx) provider (Clerk,
Auth0 or other) to accept your production URL, where your frontend is served.



================================================
FILE: npm-packages/docs/docs/production/hosting/hosting.mdx
================================================
---
title: "Hosting and Deployment"
description: "Share your Convex backend and web app with the world"
sidebar_position: 1
---

The easiest way to publish your full-stack web app is to use a hosting provider
like [Vercel](https://vercel.com) or [Netlify](https://netlify.com).

Both Vercel and Netlify integrate with Git to deploy code whenever a new
revision is pushed. To host your app:

1. Commit all files and push to your favorite Git hosting provider such as
   [GitHub](https://github.com/), [GitLab](https://gitlab.com/) or
   [Bitbucket](https://bitbucket.org/).

2. Follow the appropriate guide below.

If you aren't using Netlify or Vercel, you can follow the Custom Hosting guide.

- [Vercel](/production/hosting/vercel.mdx)
- [Netlify](/production/hosting/netlify.mdx)
- [Custom Hosting](/production/hosting/custom.mdx)



================================================
FILE: npm-packages/docs/docs/production/hosting/netlify.mdx
================================================
---
title: "Using Convex with Netlify"
sidebar_label: "Netlify"
description: "Host your frontend on Netlify and your backend on Convex"
sidebar_position: 20
---

Hosting your Convex app on Netlify allows you to automatically re-deploy both
your backend and your frontend whenever you push your code.

## Deploying to Netlify

This guide assumes you already have a working React app with Convex. If not
follow the [Convex React Quickstart](/quickstart/react.mdx) first. Then:

<StepByStep>
  <Step title="Create a Netlify account">
    If you haven't done so, create a [Netlify](https://netlify.com) account.
    This is free for small projects and should take less than a minute to set
    up.

    <></>

  </Step>
  <Step title="Link your project on Netlify">
    Create a Netlify project at https://app.netlify.com/start and link it to the
    source code repository for your project on GitHub or other Git platform.

    <div className="screenshot-border">
      ![Netlify import project](/screenshots/netlify_import.png)
    </div>

  </Step>
  <Step title="Override the Build command">
    Override the _Build command_ to be
    `npx convex deploy --cmd 'npm run build'`.

    If your project lives in a subdirectory of your repository you'll
    also need to change _Base directory_ in Netlify accordingly.

    <div className="screenshot-border">
      ![Netlify build settings](/screenshots/netlify_build_settings.png)
    </div>

  </Step>
  <Step title="Set up the CONVEX_DEPLOY_KEY environment variable">
    On your [Convex Dashboard](https://dashboard.convex.dev/)
    go to your project's _Settings_ page. Click the _Generate_ button to generate a **Production** deploy key.
    Then click the copy button to copy the key.

    In Netlify, click _Add environment variables_ and _New variable_.

    Create an environment variable `CONVEX_DEPLOY_KEY` and paste
    in your deploy key.

    <div className="screenshot-border">
      ![Netlify environment variable CONVEX_DEPLOY_KEY](/screenshots/netlify_prod_deploy_key.png)
    </div>

  </Step>
  <Step title="Deploy your site">
    Now click the _Deploy_ button and your work here is done!

    <></>

  </Step>

</StepByStep>

Netlify will automatically publish your site to a URL
`https://<site-name>.netlify.app` listed at the top of the site overview page.
Every time you push to your git repository, Netlify will automatically deploy
your Convex functions and publish your site changes.

<Admonition type="info" title="Using a Custom Domain?">
  If you're using a custom domain to serve your Convex functions, you'll need
  additional configuration. See [Custom
  Domains](/production/hosting/custom.mdx#hosting-with-a-custom-domain) for more
  information.
</Admonition>
### How it works

In Netlify, we overrode the _Build Command_ to be
`npx convex deploy --cmd 'npm run build'`.

`npx convex deploy` will read `CONVEX_DEPLOY_KEY` from the environment and use
it to set the `CONVEX_URL` (or similarly named) environment variable to point to
your **production** deployment.

Your frontend framework of choice invoked by `npm run build` will read the
`CONVEX_URL` environment variable and point your deployed site (via
`ConvexReactClient`) at your **production** deployment.

Finally, `npx convex deploy` will push your Convex functions to your production
deployment.

Now, your production deployment has your newest functions and your app is
configured to connect to it.

You can use `--cmd-url-env-var-name` to customize the variable name used by your
frontend code if the `deploy` command cannot infer it, like

```sh
npx convex deploy --cmd-url-env-var-name CUSTOM_CONVEX_URL --cmd 'npm run build'
```

## Authentication

You will want to configure your [authentication](/auth.mdx) provider (Clerk,
Auth0 or other) to accept your production `<site-name>.netlify.app` URL.

## Deploy Previews

Netlify's Deploy Previews allow you to preview changes to your app before
they're merged in. In order to preview both changes to frontend code and Convex
functions, you can set up
[Convex preview deployments](/production/hosting/preview-deployments.mdx).

This will create a fresh Convex backend for each preview and leave your
production and development deployments unaffected.

This assumes you have already followed the steps in
[Deploying to Netlify](#deploying-to-netlify) above.

<StepByStep>
  <Step title="Set up the CONVEX_DEPLOY_KEY environment variable">
    On your [Convex Dashboard](https://dashboard.convex.dev/)
    go to your project's _Settings_ page. Click the _Generate Preview Deploy Key_ button to generate a **Preview** deploy key.
    Then click the copy button to copy the key.

    In Netlify, click _Site configuration_ > _Environment variables_. Edit your existing `CONVEX_DEPLOY_KEY` environment variable.
    Select _Different value for each deploy context_ and paste the key under _Deploy Previews_.


    <div className="screenshot-border">
      ![Netlify environment variable CONVEX_DEPLOY_KEY](/screenshots/netlify_preview_deploy_key.png)
    </div>

  </Step>
  <Step title="(optional) Set up default environment variables">
    If your app depends on certain Convex environment variables, you can set up [default
    environment variables](/production/environment-variables.mdx#project-environment-variable-defaults) for preview and development deployments in your project.
    <div className="screenshot-border">
      ![Project Default Environment Variables](/screenshots/project_default_environment_variables.png)
    </div>
  </Step>

<Step title="(optional) Run a function to set up initial data">
  Deploy Previews run against fresh Convex backends, which do not share data
  with development or production Convex deployments. You can call a Convex
  function to set up data by adding `--preview-run 'functionName'` to the `npx
  convex deploy` command. This function will only be run for preview deployments, and will be ignored
  when deploying to production.

```sh title="Netlify > Site configuration > Build & deploy > Build settings > Build command"
npx convex deploy --cmd 'npm run build' --preview-run 'functionName'
```

</Step>

  <Step title="Now test out creating a PR and generating a Deploy Preview!">

    You can find the Convex deployment for your branch in the Convex dashboard.
    <div className="screenshot-border">
      ![Preview Deployment in Deployment Picker](/screenshots/preview_deployment_deployment_picker.png)
    </div>

  </Step>

</StepByStep>

### How it works

For Deploy Previews, `npx convex deploy` will read `CONVEX_DEPLOY_KEY` from the
environment, and use it to create a Convex deployment associated with the Git
branch name for the Deploy Preview. It will set the `CONVEX_URL` (or similarly
named) environment variable to point to the new Convex deployment.

Your frontend framework of choice invoked by `npm run build` will read the
`CONVEX_URL` environment variable and point your deployed site (via
`ConvexReactClient`) at the Convex preview deployment.

Finally, `npx convex deploy` will push your Convex functions to the preview
deployment and run the `--preview-run` function (if provided). This deployment
has separate functions, data, crons and all other configuration from any other
deployments.

`npx convex deploy` will infer the Git branch name for Vercel, Netlify, GitHub,
and GitLab environments, but the `--preview-create` option can be used to
customize the name associated with the newly created deployment.

Production deployments will work exactly the same as before.



================================================
FILE: npm-packages/docs/docs/production/hosting/preview-deployments.mdx
================================================
---
title: "Preview Deployments"
sidebar_label: "Preview Deployments"
description: "Use Convex with your hosting provider's preview deployments"
sidebar_position: 200
---

Convex preview deployments allow your team to test out backend changes before
pushing them to production.

In combination with Vercel Preview Deployments or Netlify Deploy Previews, you
can preview both frontend and backend changes together.

<BetaAdmonition feature="Convex preview deployments" verb="are" />

## Setup

Follow the [Vercel](/production/hosting/vercel.mdx#preview-deployments) or
[Netlify](/production/hosting/netlify.mdx#deploy-previews) hosting guide for
setting up frontend and backend previews together, as well as details on how
Convex preview deployments work.

See `npx convex deploy --help` for all available options for
`npx convex deploy`.

## Limits

Convex preview deployments are automatically cleaned up 5 days (14 days on the
Professional Convex plan) after creation, or when a new preview deployment with
the same name is created. They can also be manually deleted from the Convex
dashboard.

Preview deployments count towards your deployment limit.

When a Convex preview deployment is deleted, the Vercel/Netlify preview link
will open and show UI, but will be unable to run any Convex functions since it
is pointing at a Convex deployment that no longer exists. In these cases,
re-deploying in Vercel/Netlify should produce a link pointing at a new Convex
deployment.

Convex allows a single deployment at a time for a given name (Git branch). When
pushing updates to an existing branch, the deployment will be deleted, resulting
in a preview link unable to run Convex functions, before it is replaced by a new
Convex deployment.

Initial data can be set up on a Convex preview deployment by running a function.
There are currently no other ways to set up data on a Convex preview deployment
-- viewing changes against a copy of production data or importing data from a
different Convex deployment is not supported.

Note that if the function call fails, the `deploy` command will fail, but the
new preview deployment will have already been provisioned. Best course of action
is to fix the issue in the function and redeploy.

Support for preview deployments is a beta feature, so
[let us know on Discord](https://convex.dev/community) if you have feedback!



================================================
FILE: npm-packages/docs/docs/production/hosting/vercel.mdx
================================================
---
title: "Using Convex with Vercel"
sidebar_label: "Vercel"
description: "Host your frontend on Vercel and your backend on Convex"
sidebar_position: 10
---

Hosting your Convex app on Vercel allows you to automatically re-deploy both
your backend and your frontend whenever you push your code.

## Deploying to Vercel

### Using the Vercel Marketplace

<Admonition type="info">
  Projects deployed with the Vercel marketplace will be a part of their own
  Convex team. If you already have a Convex team, you may [follow these
  instructions](/production/hosting/vercel.mdx#connecting-your-convex-project-to-vercel).
</Admonition>

Convex is available on the
[Vercel Marketplace](https://vercel.com/marketplace/convex). You may create,
deploy, and pay for (if using a paid subscription) for your Convex projects
through Vercel by using the marketplace.

Convex projects created through the Vercel Marketplace will automatically be
configured to deploy automatically.

Quickly deploy a template project to the Vercel Marketplace:

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fget-convex%2Fvercel-marketplace-convex&project-name=vercel-with-convex&repository-name=vercel-with-convex&demo-title=Convex%20with%20Vercel&demo-description=A%20minimal%20template%20showcasing%20using%20Convex%20with%20Vercel&demo-url=https%3A%2F%2Fconvex-vercel-template-demo.previews.convex.dev%2F&products=%5B%7B%22type%22%3A%22integration%22%2C%22integrationSlug%22%3A%22convex%22%2C%22productSlug%22%3A%22convex%22%2C%22protocol%22%3A%22storage%22%7D%5D)

### Connecting your Convex project to Vercel

#### Using a template

To start a new project quickly, you may click this button and follow the
instructions to quickly deploy your Convex project to Vercel.

**Note:** You'll need to create a project on the Convex dashboard to use this
template.

[![Deploy with
  Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fget-convex%2Fvercel-marketplace-convex&project-name=vercel-with-convex&repository-name=vercel-with-convex&demo-title=Convex%20with%20Vercel&demo-description=A%20minimal%20template%20showcasing%20using%20Convex%20with%20Vercel&demo-url=https%3A%2F%2Fconvex-vercel-template-demo.previews.convex.dev%2F&products=%5B%7B%22type%22%3A%22integration%22%2C%22integrationSlug%22%3A%22convex%22%2C%22productSlug%22%3A%22convex%22%2C%22protocol%22%3A%22storage%22%7D%5D)

#### From scratch

This guide assumes you already have a working React app with Convex. If not
follow the [Convex React Quickstart](/quickstart/react.mdx) first. Then:

<StepByStep>
  <Step title="Create a Vercel account">
    If you haven't done so, create a [Vercel](https://vercel.com) account. This is
    free for small projects and should take less than a minute to set up.

    <></>

  </Step>
  <Step title="Link your project on Vercel">
    Create a Vercel project at https://vercel.com/new and link it to the
    source code repository for your project on GitHub or other Git platform.

    ![Vercel import project](/screenshots/vercel_import.png)

  </Step>
  <Step title="Override the Build command">
    Override the "Build command" to be
    `npx convex deploy --cmd 'npm run build'`.

    If your project lives in a subdirectory of your repository you'll
    also need to change _Root Directory_ above accordingly.

    ![Vercel build settings](/screenshots/vercel_build_command.png)

  </Step>

  <Step title="Set up the CONVEX_DEPLOY_KEY environment variable">
    Go to the [Project Settings](https://dashboard.convex.dev/project/settings#production-deploy-keys) page in the Convex Dashboard. Click the _Generate Production Deploy Key_ button to generate a **Production** deploy key.
    Then click the copy button to copy the key.

    In Vercel, click _Environment Variables_.
    Create an environment variable named `CONVEX_DEPLOY_KEY` and paste
    in your deploy key. Under _Environment_, uncheck all except _Production_ and click _Save_.

    ![Vercel environment variable CONVEX_DEPLOY_KEY](/screenshots/vercel_prod_deploy_key.png)

  </Step>
  <Step title="Deploy your site">
    Now click the _Deploy_ button and your work here is done!

    <></>

  </Step>

</StepByStep>

Vercel will automatically publish your site to an URL like
`https://<site-name>.vercel.app`, shown on the page after deploying. Every time
you push to your Git repository, Vercel will automatically deploy your Convex
functions and publish your site changes.

<Admonition type="info" title="Using a Custom Domain?">
  If you're using a custom domain to serve your Convex functions, you'll need
  additional configuration. See [Custom
  Domains](/production/hosting/custom.mdx#hosting-with-a-custom-domain) for more
  information.
</Admonition>

### How it works

In Vercel, we overrode the _Build Command_ to be
`npx convex deploy --cmd 'npm run build'`.

`npx convex deploy` will read `CONVEX_DEPLOY_KEY` from the environment and use
it to set the `CONVEX_URL` (or similarly named) environment variable to point to
your **production** deployment.

Your frontend framework of choice invoked by `npm run build` will read the
`CONVEX_URL` (or similarly named) environment variable to point your deployed
site (via `ConvexReactClient`) at your **production** deployment.

Finally, `npx convex deploy` will push your Convex functions to your production
deployment.

Now, your production deployment has your newest functions and your app is
configured to connect to it.

You can use `--cmd-url-env-var-name` to customize the variable name used by your
frontend code if the `deploy` command cannot infer it, like

```sh
npx convex deploy --cmd-url-env-var-name CUSTOM_CONVEX_URL --cmd 'npm run build'
```

### Authentication

You will want to configure your [authentication](/auth.mdx) provider (Clerk,
Auth0 or other) to accept your production URL. Note that Clerk does not support
`https://<site-name>.vercel.app`, so you'll have to configure a custom domain.

## Preview Deployments

Vercel Preview Deployments allow you to preview changes to your app before
they're merged in. In order to preview both changes to frontend code and Convex
functions, you can set up
[Convex preview deployments](/production/hosting/preview-deployments.mdx).

This will create a fresh Convex backend for each preview and leave your
production and development deployments unaffected.

This assumes you have already followed the steps in
[Deploying to Vercel](#deploying-to-vercel) above.

<StepByStep>
  <Step title="Set up the CONVEX_DEPLOY_KEY environment variable">
    On your [Convex Dashboard](https://dashboard.convex.dev/)
    go to your project's _Settings_ page. Click the _Generate Preview Deploy Key_ button to generate a **Preview** deploy key.
    Then click the copy button to copy the key.

    In Vercel, click _Environment Variables_.
    Create an environment variable named `CONVEX_DEPLOY_KEY` and paste
    in your deploy key. Under _Environment_, uncheck all except _Preview_ and click _Save_.

    <div className="screenshot-border">
      ![Vercel environment variable CONVEX_DEPLOY_KEY](/screenshots/vercel_preview_deploy_key.png)
    </div>

  </Step>
  <Step title="(optional) Set up default environment variables">
    If your app depends on certain Convex environment variables, you can set up [default
    environment variables](/production/environment-variables.mdx#project-environment-variable-defaults) for preview and development deployments in your project.
    <div className="screenshot-border">
      ![Project Default Environment Variables](/screenshots/project_default_environment_variables.png)
    </div>
  </Step>

<Step title="(optional) Run a function to set up initial data">
  Vercel Preview Deployments run against fresh Convex backends, which do not share data
  with development or production Convex deployments. You can call a Convex
  function to set up data by adding `--preview-run 'functionName'` to the `npx
  convex deploy` command. This function will only be run for preview deployments, and will be ignored
  when deploying to production.

```sh title="Vercel > Settings > Build & Development settings > Build Command"
npx convex deploy --cmd 'npm run build' --preview-run 'functionName'
```

</Step>

  <Step title="Now test out creating a PR and generating a Preview Deployment!">

    You can find the Convex deployment for your branch in the Convex dashboard.
    <div className="screenshot-border">
      ![Preview Deployment in Deployment Picker](/screenshots/preview_deployment_deployment_picker.png)
    </div>

  </Step>

</StepByStep>

### How it works

For Preview Deployments, `npx convex deploy` will read `CONVEX_DEPLOY_KEY` from
the environment, and use it to create a Convex deployment associated with the
Git branch name for the Vercel Preview Deployment. It will set the `CONVEX_URL`
(or similarly named) environment variable to point to the new Convex deployment.

Your frontend framework of choice invoked by `npm run build` will read the
`CONVEX_URL` environment variable and point your deployed site (via
`ConvexReactClient`) at the Convex preview deployment.

Finally, `npx convex deploy` will push your Convex functions to the preview
deployment and run the `--preview-run` function (if provided). This deployment
has separate functions, data, crons and all other configuration from any other
deployments.

`npx convex deploy` will infer the Git branch name for Vercel, Netlify, GitHub,
and GitLab environments, but the `--preview-create` option can be used to
customize the name associated with the newly created deployment.

Production deployments will work exactly the same as before.



================================================
FILE: npm-packages/docs/docs/production/integrations/exception-reporting.mdx
================================================
---
title: "Exception Reporting"
sidebar_label: "Exception Reporting"
sidebar_position: 3
description:
  "Configure exception reporting integrations for your Convex deployment"
---

Configure exception reporting to gain visibility into errors from your Convex
function executions. Convex supports integration with
[Sentry](https://sentry.io/) and with
[Datadog Error Tracking](https://www.datadoghq.com/product/error-tracking/).

Currently, exception reporting is only available to Pro users.

## Configuring Sentry

To configure sentry, navigate to the
[Deployment Settings](/dashboard/deployments/settings.md) in the Dashboard, and
the "Integrations" tab in the sidebar.

![Integrations Page](/screenshots/integrations_page.png)

Click on the Sentry card and follow the setup directions. You will need your
[Sentry DSN](https://docs.sentry.io/product/sentry-basics/concepts/dsn-explainer/).
You may optionally specify additional tags to be added to each exception event.

![Configure sentry](/screenshots/configure_sentry.png)

## Supported Tags

Convex automatically tags exception events on their way to sentry with the
following tags. These tags cannot be overridden.

- `func`: The name of the running function in
  [string format](/functions/query-functions#query-names)
- `func_type`: One of `["query", "mutation", "action", "http_action"]`
- `func_runtime`: One of the [function runtimes](/functions/runtimes.mdx) -
  `["default", "node"]`
- `request_id`: The
  [request id](/functions/debugging.mdx#finding-relevant-logs-by-request-id) of
  the function that errored.
- `server_name`: The name of the deployment. e.g. `happy-animal-123`
- `environment`: One of `["prod", "dev", "preview"]`
- `user`: If the function is [authenticated](/auth.mdx), then the
  [tokenIdentifier](/api/interfaces/server.UserIdentity#tokenidentifier) is used
  as the user id on Sentry. The `tokenIdentifier` is a stable and globally
  unique string representing the authenticated user.

## Sentry Notes

- Sentry Exceptions may take a minute or two to propagate to Sentry.
- Convex's built-in sentry support does not yet support the advanced
  customization provided by the sentry SDK.
- Please reach out with any questions, comments, or suggestions
  [on Discord](https://convex.dev/community).

## Configuring Datadog Error Tracking

Follow the instructions in the
[Datadog application](https://app.datadoghq.com/error-tracking/settings/setup/sentry)
to configure Datadog error tracking via the Sentry SDK. Then use the
Convex-Sentry integration to proceed.



================================================
FILE: npm-packages/docs/docs/production/integrations/integrations.mdx
================================================
---
title: "Integrations"
description: "Integrate Convex with third party services"
sidebar_position: 1
---

import { ComponentCardList } from "@site/src/components/ComponentCard";

Convex integrates with a variety of supported third party tools for log
streaming and exception reporting.

- [Log Streams](/production/integrations/log-streams) enable streaming of log
  events from your Convex deployment to supported destinations, such as Axiom,
  Datadog, or a custom webhook.
- [Exception Reporting](/production/integrations/exception-reporting) gives
  visibility into errors in your Convex function executions.

## Configuring an Integration

To configure an integration, navigate to the
[Deployment Settings](https://dashboard.convex.dev/deployment/settings) in the
Dashboard, and the "Integrations" tab in the sidebar. This page provides a list
of your configured integrations, their current health status, and other
integrations available to be configured. To configure a integration, click on
the card and follow the setup directions.

![Integrations Page](/screenshots/integrations_page.png)

## Deleting an Integration

To remove an integration and stop further events from being piped out to the
configured destination, select the menu icon in the upper-right corner of a
configured panel and select "Delete integration". After confirming, the
integration will stop running within a few seconds.

## Feedback

Please reach out with any questions, comments, or suggestions
[on Discord](https://convex.dev/community).

## Integration Components

Beyond integrations for logs and exceptions, [Convex Components](/components)
make it easier to work with third party services. See the full list of
components on the [Convex Components Directory](https://convex.dev/components).

<ComponentCardList
  items={[
    {
      title: "Cloudflare R2",
      description: "Store and serve files in Cloudflare's R2 storage.",
      href: "https://www.convex.dev/components/cloudflare-r2",
    },
    {
      title: "Collaborative Text Editor",
      description:
        "Real-time collaborative text editing using BlockNote or Tiptap.",
      href: "https://www.convex.dev/components/prosemirror-sync",
    },
    {
      title: "Expo Push Notifications",
      description: "Send mobile push notifications using Expo.",
      href: "https://www.convex.dev/components/push-notifications",
    },
    {
      title: "Twilio SMS",
      description: "Send and receive SMS messages using Twilio's API.",
      href: "https://www.convex.dev/components/twilio",
    },
    {
      title: "LaunchDarkly Feature Flags",
      description: "Sync feature flags with backend, backed by LaunchDarkly.",
      href: "https://www.convex.dev/components/launchdarkly",
    },
    {
      title: "Polar",
      description: "Add subscriptions and billing with Polar.",
      href: "https://www.convex.dev/components/polar",
    },
  ]}
/>



================================================
FILE: npm-packages/docs/docs/production/integrations/streaming-import-export.md
================================================
---
title: "Streaming Data in and out of Convex"
sidebar_label: "Streaming Import/Export"
description: "Streaming Data in and out of Convex"
sidebar_position: 4
---

[Fivetran](https://www.fivetran.com) and [Airbyte](https://airbyte.com) are data
integration platforms that allow you to sync your Convex data with other
databases.

Fivetran enables streaming export from Convex to any of their
[supported destinations](https://fivetran.com/docs/destinations). The Convex
team maintains a Convex source connector, for streaming export. Streaming import
into Convex via Fivetran is not supported at the moment.

Using Airbyte enables streaming import from any of their
[supported sources](https://airbyte.com/connectors?connector-type=Sources) into
Convex and streaming export from Convex into any of their
[supported destinations](https://airbyte.com/connectors?connector-type=Destinations).
The Convex team maintains a Convex source connector for streaming export and a
Convex destination connector for streaming import.

<BetaAdmonition feature="Fivetran & Airbyte integrations" verb="are" />

## Streaming Export

Exporting data can be useful for handling workloads that aren't supported by
Convex directly. Some use cases include:

1. Analytics
   - Convex isn't optimized for queries that load huge amounts of data. A data
     platform like [Databricks](https://www.databricks.com) or
     [Snowflake](https://www.snowflake.com/) is more appropriate.
2. Flexible querying
   - While Convex has powerful
     [database queries](/database/reading-data/reading-data.mdx#querying-documents)
     and built-in [full text search](/search.mdx) support, there are still some
     queries that are difficult to write within Convex. If you need very dynamic
     sorting and filtering for something like an "advanced search" view,
     databases like [ElasticSearch](https://www.elastic.co) can be helpful.
3. Machine learning training
   - Convex isn't optimized for queries running computationally intensive
     machine learning algorithms.

<ProFeatureUpsell feature="Streaming export" verb="requires" />

See the [Fivetran](https://fivetran.com/integrations/convex) or
[Airbyte](https://docs.airbyte.com/integrations/sources/convex) docs to learn
how to set up a streaming export. [Contact us](https://convex.dev/community) if
you need help or have questions.

## Streaming Import

Adopting new technologies can be a slow, daunting process, especially when the
technologies involve databases. Streaming import enables adopting Convex
alongside your existing stack without having to write your own migration or data
sync tooling. Some use cases include:

1. Prototyping how Convex could replace your project's existing backend using
   its own data.
2. Building new products faster by using Convex alongside existing databases.
3. Developing a reactive UI-layer on top of an existing dataset.
4. Migrating your data to Convex (if the [CLI](/cli.md) tool doesn't meet your
   needs).

<Admonition type="caution" title="Make imported tables read-only">
A common use case is to "mirror" a table in the source database to Convex to
build something new using Convex. We recommend leaving imported
tables as read-only in Convex because syncing the results back to the source
database could result in dangerous write conflicts. While Convex doesn't yet
have access controls that would ensure a table is read-only, you can make sure that
there are no mutations or actions writing to imported tables in your code and avoid editing
documents in imported tables in the dashboard.
</Admonition>

Streaming import is included with all Convex plans. See the Airbyte docs on how
to set up the Convex destination connector
[here](https://docs.airbyte.com/integrations/destinations/convex).



================================================
FILE: npm-packages/docs/docs/production/integrations/log-streams/legacy-event-schema.mdx
================================================
# (Legacy) Event schema

<Admonition type="info">
  Log streams configured before May 23, 2024 will use the legacy format
  documented here. We recommend updating your log stream to use the new format.
</Admonition>

## Updating to the new format

You can update existing log streams to the new format in the dashboard under
your [deployment's Settings](https://dashboard.convex.dev/deployment/settings) >
Integrations.

You can either create an entirely new dataset to hold events using the new
format, or can reuse your existing dataset to hold historical events in the
legacy format as well as events in the new format going forward.

We recommend reading the documentation on both the legacy format and the
[current format](/production/integrations/log-streams/log-streams.mdx#log-event-schema)
for the full set of differences, but here are a few key differences:

- Many fields have been renamed to drop leading underscores and use `snake_case`
- Fields have been added, e.g.
  - `function.request_id`
  - `usage.vector_storage_read_bytes`
  - `log_level`
- Fields have been renamed or nested for clarity, e.g.
  - `reason` -> `error_message`
  - `_functionPath` -> `function.path`

## (Legacy) Event schema

Log events have a well-defined JSON schema that allow building complex,
type-safe pipelines ingesting log events.

## System fields

System fields are reserved fields which are included on log events and prefixed
by an underscore.

All log events include the following system fields:

- `_topic`: string that categorizes a log event by its internal source
- `_timestamp`: Unix epoch timestamp in milliseconds. This is as an integer.

## Log sources

This section outlines the source and data model of all log events.

### `console` logs

Convex function logs via the `console` API.

Schema:

- `_topic = "_console"`
- `_timestamp` = Unix epoch timestamp in milliseconds
- `_functionType = "query" | "mutation" | "action" | "httpAction"`
- `_functionPath` =
  - If this is an HTTP action, this is a string of the HTTP method and URL
    pathname i.e. `POST /my_endpoint`
  - Otherwise, this is a path to function within `convex/` directory including
    an optional module export identifier i.e. `myDir/myFile:myFunction`.
- `_functionCached = true | false`. This field is only set if
  `_functionType = "query"` and says if this log event came from a cached
  function execution.
- `message` = payload string of arguments to `console` API

Example query log event:

```json
{
  "_topic": "_console",
  "_timestamp": 1695066350531,
  "_functionType": "query",
  "_functionPath": "myDir/myFile",
  "_functionCached": true,
  "message": "[LOG] 'My log message'"
}
```

### Function execution record logs

Function executions which log a record of their execution and their result.

Schema:

- `_topic = "_execution_record"`
- `_timestamp` = Unix epoch timestamp in milliseconds
- `_functionType = "query" | "mutation" | "action" | "httpAction"`
- `_functionPath` = path to function within `convex/` directory including module
  export identifier
- `_functionCached = true | false`. This field is only set if
  `_functionType = "query"` and says if this log event came from a cached
  function execution.
- `status = "success" | "failure"`
- `reason` = error message from function. Only set if `status = "failure"`
- `executionTimeMs` = length of execution of this function in milliseconds
- `databaseReadBytes` = the database read bandwidth used by this function in
  bytes
- `databaseWriteBytes` = the database write bandwidth used by this function in
  bytes
- `storageReadBytes` = the file storage read bandwidth this function used in
  bytes
- `storageWriteBytes` = the file storage write bandwidth this function used in
  bytes

Example execution record log from an HTTP action:

```json
{
  "_topic": "_execution_record",
  "_timestamp": 1695066350531,
  "_functionType": "httpAction",
  "_functionPath": "POST /sendImage",
  "status": "failure",
  "reason": "Unexpected Error: Some error message\n\n  at ....",
  "executionTimeMs": 73
}
```

### Audit trail logs

Audit logs of deployment events.

Schema:

- `_topic = "_audit_log"`
- `_timestamp` = Unix epoch timestamp in milliseconds
- `action = "create_environment_variable" | "update_environment_variable" | "delete_environment_variable" | "replace_environment_variable" | "push_config" | "build_indexes" | "change_deployment_state"`
- `actionMetadata` = object whose fields depends on the value of the `action`
  field.

Example `push_config` audit log:

```json
{
  "_topic": "_audit_log",
  "_timestamp": 1695066350531,
  "action": "push_config",
  "actionMetadata": {
    "modules": {
      "added": ["ffmpeg.js", "fetch.js", "test.js"],
      "removed": ["removed.js"]
    }
  }
}
```

### Verification logs

Internal logging events used to verify access to a log stream.

Schema

- `_topic = "_verification"`
- `_timestamp` = Unix epoch timestamp in milliseconds.
- `message = Convex connection test`



================================================
FILE: npm-packages/docs/docs/production/integrations/log-streams/log-streams.mdx
================================================
---
title: "Log Streams"
sidebar_label: "Log Streams"
sidebar_position: 2
description: "Configure logging integrations for your Convex deployment"
---

Log streams enable streaming of events such as function executions and
`console.log`s from your Convex deployment to supported destinations, such as
Axiom, Datadog, or a custom webhook.

The most recent logs produced by your Convex deployment can be viewed in the
Dashboard [Logs page](/dashboard/deployments/logs.md), the
[Convex CLI](/cli.md), or in the browser console, providing a quick and easy way
to view recent logs.

Log streaming to a third-party destination like Axiom or Datadog enables storing
historical logs, more powerful querying and data visualization, and integrations
with other tools (e.g. PagerDuty, Slack).

<ProFeatureUpsell feature="Log streams" verb="require" />

## Configuring log streams

We currently support the following log streams, with plans to support many more:

- [Axiom](https://www.axiom.co)
- [Datadog](https://www.datadoghq.com/)
- Webhook to a custom URL

See the instructions for
[configuring an integration](/production/integrations/integrations.mdx#configuring-an-integration).
The specific information needed for each log stream is covered below.

### Axiom

Configuring an Axiom log stream requires specifying:

- The name of your
  [Axiom dataset](https://axiom.co/docs/reference/settings#dataset)
- An Axiom [API key](https://axiom.co/docs/reference/settings#api-token)
- An optional list of attributes and their values to be included in all log
  events send to Axiom. These will be sent via the `attributes` field in the
  [Ingest API](https://axiom.co/docs/send-data/ingest#ingest-api).

When configuring a Convex dataset in Axiom, a dashboard will automatically be
created in Axiom. You can find it in the _Integrations_ section of the
_Dashboards_ tab. To customize the layout of the dashboard, you can
[fork it](https://axiom.co/docs/dashboards/create#fork-dashboards).

![A dashboard in Axiom](/screenshots/axiom_dashboard.png)

### Datadog

Configuring a Datadog log stream requires specifying:

- The [site location](https://docs.datadoghq.com/getting_started/site/) of your
  Datadog deployment
- A Datadog
  [API key](https://docs.datadoghq.com/account_management/api-app-keys/#add-an-api-key-or-client-token)
- A comma-separated list of tags that will be passed using the
  [`ddtags` field](https://docs.datadoghq.com/getting_started/tagging/) in all
  payloads sent to Datadog. This can be used to include any other metadata that
  can be useful for querying or categorizing your Convex logs ingested by your
  Datadog deployment.

### Webhook

A webhook log stream is the simplest and most generic stream, allowing piping
logs via POST requests to any URL you configure. The only parameter required to
set up this stream is the desired webhook URL.

A request to this webhook contains as its body a JSON array of events in the
schema defined below.

## Securing webhook log streams

Webhook log stream requests include a signature so you can verify that a request
is legitimate. The request body is signed using HMAC-SHA256 and encoded as a
lowercase hex string, and the resulting signature is included in the
`x-webhook-signature` HTTP header. The HMAC secret is visible in the dashboard
upon configuring the webhook.

To verify the authenticity of a request, sign and encode the request body using
the HMAC secret and
[compare the result in constant time](https://www.chosenplaintext.ca/articles/beginners-guide-constant-time-cryptography.html)
(for instance using
[`SubtleCrypto.verify()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify)
in JavaScript) with the signature included in the request header. Note that the
signature is prefixed with `sha256=`.

For additional security, consider validating that the `timestamp` field of the
log event body falls within an acceptable time range to prevent replay attacks.

```typescript
import { Hono } from "hono";

const app = new Hono();

app.post("/webhook", async (c) => {
  const payload = await c.req.json();
  const log = payload[0];

  // If using JSONL, parse the first line:
  // const payload = await c.req.text();
  // const log = JSON.parse(payload.split("\n")[0]);

  // Validate that the timestamp of the first log is within 5 minutes
  if (log.timestamp < Date.now() - 5 * 60 * 1000) {
    c.status(403);
    return c.text("Request expired");
  }

  const signature = c.req.header("x-webhook-signature");
  if (!signature) {
    c.status(401);
    return c.text("Unauthorized");
  }

  const hmacSecret = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(process.env.WEBHOOK_SECRET!),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["verify"],
  );
  const hashPayload = await c.req.arrayBuffer();

  // Use constant-time comparison to verify the payload
  const isValid = await crypto.subtle.verify(
    "HMAC",
    hmacSecret,
    Uint8Array.fromHex(signature.replace("sha256=", "")),
    hashPayload,
  );

  if (isValid) {
    return c.text("Success");
  }

  c.status(401);
  return c.text("Unauthorized");
});

export default app;
```

## Log event schema

<Admonition type="info">
  Log streams configured before May 23, 2024 will use the legacy format
  documented on [this
  page](/production/integrations/log-streams/legacy-event-schema.mdx). We
  recommend updating your log stream to use the new format.
</Admonition>

Log events have a well-defined JSON schema that allow building complex,
type-safe pipelines ingesting log events.

All events will have the following three fields:

- `topic`: string, categorizes a log event, one of
  `["verification", "console", "function_execution", "audit_log", "concurrency_stats", "scheduler_stats", "current_storage_usage"]`
- `timestamp`: number, Unix epoch timestamp in milliseconds as an integer
- `convex`: An object containing metadata related to your Convex deployment,
  including `deployment_name`, `deployment_type`, `project_name`, and
  `project_slug`.

Note: In the Axiom integration, event-specific information will be available
under the `data` field.

### `verification` events

This is an event sent to confirm the log stream is working. Schema:

- `topic`: `"verification"`
- `timestamp`: Unix epoch timestamp in milliseconds
- `message`: string

### `console` events

Convex function logs via the [`console` API](/functions/debugging.mdx).

Schema:

- `topic`: `"console"`
- `timestamp`: Unix epoch timestamp in milliseconds
- `function`: object, see
  [function fields](/production/integrations/log-streams/log-streams.mdx#function-fields)
- `log_level`: string, one of `["DEBUG", "INFO", "LOG", "WARN", "ERROR"]`
- `message`: string, the
  [`object-inspect`](https://www.npmjs.com/package/object-inspect)
  representation of the `console.log` payload
- `is_truncated`: boolean, whether this message was truncated to fit within our
  logging limits
- `system_code`: optional string, present for automatically added warnings when
  functions are approaching [limits](/production/state/limits.mdx#functions)

Example event for `console.log("Sent message!")` from a mutation:

```json
{
    "topic": "console"
    "timestamp": 1715879172882,
    "function": {
      "path": "messages:send",
      "request_id": "d064ef901f7ec0b7",
      "type": "mutation"
    },
    "log_level": "LOG",
    "message": "'Sent message!'"
}
```

### `function_execution` events

These events occur whenever a function is run.

Schema:

- `topic`: `"function_execution"`
- `timestamp`: Unix epoch timestamp in milliseconds
- `function`: object, see
  [function fields](/production/integrations/log-streams/log-streams.mdx#function-fields)
- `execution_time_ms`: number, the time in milliseconds this function took to
- `status`: string, one of `["success", "failure"]`
- `error_message`: string, present for functions with status `failure`,
  containing the error and any stack trace.
- `mutation_queue_length`: optional number (for mutations only), the length of
  the per-session mutation queue at the time the mutation was executed. This is
  useful for monitoring and debugging mutation queue backlogs in individual
  sessions.
- `mutation_retry_count`: number, the number of previous failed executions (for
  mutations only) run before a successful one. Only applicable to mutations and
  actions.
- `occ_info`: object, if the function call resulted in an OCC (write conflict
  between two functions), this field will be present and contain information
  relating to the OCC.
  [Learn more about write conflicts](https://docs.convex.dev/error/#1).
  - `table_name`: table the conflict occurred in
  - `document_id`: Id of the document that received conflicting writes
  - `write_source`: name of the function that conflicted writes against
    `table_name`
  - `retry_count`: the number of previously failed attempts before the current
    function execution
- `scheduler_info`: object, if set, indicates that the function was originally
  invoked by the [scheduler](/scheduling/scheduled-functions).
  - `job_id`: the job within the
    [`_scheduled_functions`](/scheduling/scheduled-functions#retrieving-scheduled-function-status)
    table
- `usage`:
  - `database_read_bytes`: number
  - `database_write_bytes`: number, this and `database_read_bytes` make up the
    database bandwidth used by the function
  - `database_read_documents`: number, the number of documents read by the
    function
  - `file_storage_read_bytes`: number
  - `file_storage_write_bytes`: number, this and `file_storage_read_bytes` make
    up the file bandwidth used by the function
  - `vector_storage_read_bytes`: number
  - `vector_storage_write_bytes`: number, this and `vector_storage_read_bytes`
    make up the vector bandwidth used by the function
  - `memory_used_mb`: number, for queries, mutations, and actions, the memory
    used in MiB. This combined with `execution_time_ms` makes up the compute.

Example event for a query:

```json
{
  "data": {
    "execution_time_ms": 294,
    "function": {
      "cached": false,
      "path": "message:list",
      "request_id": "892104e63bd39d9a",
      "type": "query"
    },
    "status": "success",
    "timestamp": 1715973841548,
    "topic": "function_execution",
    "usage": {
      "database_read_bytes": 1077,
      "database_write_bytes": 0,
      "database_read_documents": 3,
      "file_storage_read_bytes": 0,
      "file_storage_write_bytes": 0,
      "vector_storage_read_bytes": 0,
      "vector_storage_write_bytes": 0
    }
  }
}
```

### Function fields

The following fields are added under `function` for all `console` and
`function_execution` events:

- `type`: string, one of `["query", "mutation", "action", "http_action"]`
- `path`: string, e.g. `"myDir/myFile:myFunction"`, or `"POST /my_endpoint"`
- `cached`: optional boolean, for queries this denotes whether this event came
  from a cached function execution
- `request_id`: string, the
  [request ID](/functions/debugging.mdx#finding-relevant-logs-by-request-id) of
  the function.

### `concurrency_stats` events

These events are sent once a minute, reporting function concurrency statistics.
Events are only sent if the stats have changed. Missing data points should be
interpolated from the previous data event.

Schema:

Each event contains concurrency statistics for each function type (e.g. queries,
mutations, actions). The records for each events have the following schema:

- `num_running`: The maximum number of concurrently running functions within the
  minute the metric was reported
- `num_queued`: The maximum number of queued functions within the minute the
  metric was reported. Functions may become temporarily queued when concurrency
  limits have been reached.

- `topic`: `"concurrency_stats"`
- `timestamp`: Unix epoch timestamp in milliseconds
- `query`: Concurrency stats for queries
- `mutation`: Concurrency stats for mutations
- `action`: Concurrency stats for actions
- `node_action`: Concurrency stats for node actions
- `http_action`: Concurrency stats for HTTP actions

### `scheduler_stats` events

These events are periodically sent by the scheduler reporting statistics from
the scheduled function executor.

Schema:

- `topic`: `"scheduler_stats"`
- `timestamp`: Unix epoch timestamp in milliseconds
- `lag_seconds`: The difference between `timestamp` and the scheduled run time
  of the oldest overdue scheduled job, in seconds.
- `num_running_jobs`: number, the number of scheduled jobs currently running

### `current_storage_usage` events

These events are periodically sent with snapshots of the current storage usage
across your deployment. They provide aggregated totals for all storage types.

These events are not currently sent for self-hosted deployments.

For calculating billing costs:

- Database Storage Bytes: `total_document_size_bytes + total_index_size_bytes`
- File Storage: `total_file_storage_bytes + total_backup_storage_bytes`
- Vector Storage: `total_vector_storage_bytes`

Schema:

- `topic`: `"current_storage_usage"`
- `timestamp`: Unix epoch timestamp in milliseconds
- `total_document_size_bytes`: number, total size in bytes of all documents
  stored in database tables
- `total_index_size_bytes`: number, total size in bytes of all database indexes
- `total_vector_storage_bytes`: number, total size in bytes of vector index
  storage
- `total_file_storage_bytes`: number, total size in bytes of file storage
- `total_backup_storage_bytes`: number, total size in bytes of snapshot/backup
  storage

Example event:

```json
{
  "topic": "current_storage_usage",
  "timestamp": 1715973841548,
  "total_document_size_bytes": 104857600,
  "total_index_size_bytes": 10485760,
  "total_vector_storage_bytes": 5242880,
  "total_file_storage_bytes": 52428800,
  "total_backup_storage_bytes": 209715200
}
```

### `audit_log` events

These events represent changes to your deployment, which also show up in the
[History tab](https://dashboard.convex.dev/deployment/history) in the dashboard.

Schema:

- `topic`: `audit_log`
- `timestamp`: Unix epoch timestamp in milliseconds
- `audit_log_action`: string, e.g. `"create_environment_variable"`,
  `"push_config"`, `"change_deployment_state"`
- `audit_log_metadata`: string, stringified JSON holding metadata about the
  event. The exact format of this event may change.

Example `push_config` audit log:

```json
{
  "topic": "audit_log",
  "timestamp": 1714421999886,
  "audit_log_action": "push_config",
  "audit_log_metadata": "{\"auth\":{\"added\":[],\"removed\":[]},\"crons\":{\"added\":[],\"deleted\":[],\"updated\":[]},..."
}
```

## Guarantees

Log events provide a best-effort delivery guarantee. Log streams are buffered
in-memory and sent out in batches to your deployment's configured streams. This
means that logs can be dropped if ingestion throughput is too high. Similarly,
due to network retries, it is possible for a log event to be duplicated in a log
stream.

That's it! Your logs are now configured to stream out. If there is a log
streaming destination that you would like to see supported,
[please let us know](/production/contact.md)!

<StackPosts query="axiom" />



================================================
FILE: npm-packages/docs/docs/production/state/limits.mdx
================================================
---
title: "Limits"
sidebar_position: 2
---

We’d love for you to have _unlimited_ joy building on Convex but engineering
practicalities dictate a few limits. This page outlines current limits in the
Convex ecosystem.

Many of these limits will become more permissive over time. Please get in touch
if any are prohibitive for your application.

Limits are applied per team unless stated otherwise.

## Team

|             | Free/Starter | Professional             |
| ----------- | ------------ | ------------------------ |
| Developers  | 1-6          | 25$ per member per month |
| Deployments | 40           | 120                      |

## Database

|                   | Free/Starter                                                      | Professional                                       | Notes                                                                                     |
| ----------------- | ----------------------------------------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Storage           | 0.5 GiB included<br/>(on Starter: $0.22/month per additional GiB) | 50 GiB included<br/>$0.20/month per additional GiB | Includes database rows and indexes but not files or backups.                              |
| Bandwidth         | 1 GiB/month included<br/>(on Starter: $0.22 per additional GiB)   | 50 GiB/month included<br/>$0.20 per additional GiB | Document and index data transferred between Convex functions and the underlying database. |
| Tables            | 10,000                                                            | 10,000                                             | Per deployment.                                                                           |
| Indexes per table | 32                                                                | 32                                                 |                                                                                           |
| Fields per index  | 16                                                                | 16                                                 |
| Index name length | 64 characters                                                     | 64 characters                                      |                                                                                           |

### Restrictions

- Table and index names must be valid identifiers and cannot start with an
  underscore.

## Documents

Applied per document and to any nested `Object` unless stated otherwise.

|                     |               | Notes                                                            |
| ------------------- | ------------- | ---------------------------------------------------------------- |
| Size                | 1 MiB         |                                                                  |
| Fields              | 1024          | The number of fields/keys                                        |
| Field name length   | 64 characters | Nested `Object` keys can have length up to 1024 characters.      |
| Field nesting depth | 16            | How many times objects and arrays can be nested, e.g. `[[[[]]]]` |
| Array elements      | 8192          |                                                                  |

### Restrictions

- Field names must only contain non-control alphanumeric ASCII characters and
  underscores and must start with an alphabetic character or underscore.
- Documents cannot contain top-level fields that start with an underscore, other
  than the system-provided `_id` and `_creationTime` fields.
- Strings must be valid Unicode sequences with no unpaired surrogates.

## Functions

|                                                                              | Free/Starter                                                              | Professional                                              | Notes                                                                                                         |
| ---------------------------------------------------------------------------- | ------------------------------------------------------------------------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| Function calls                                                               | 1,000,000/month included<br/>(on Starter: $2.20 per additional 1,000,000) | 25,000,000/month included<br/>$2 per additional 1,000,000 | Explicit client calls, scheduled executions, subscription updates, and file accesses count as function calls. |
| Action execution                                                             | 20 GiB-hours included<br/>(on Starter: $0.33/GiB-hour additional)         | 250 GiB-hours included<br/>$0.30/GiB-hour additional      | Convex runtime: 64 MiB RAM.<br/>Node.js runtime: 512 MiB RAM.                                                 |
| Code size                                                                    | 32 MiB                                                                    | 32 MiB                                                    | Per deployment.                                                                                               |
| Function argument size                                                       | 16 MiB                                                                    | 16 MiB                                                    | Node actions only support arguments up to 5MiB.                                                               |
| Function return value size                                                   | 16 MiB                                                                    | 16 MiB                                                    |                                                                                                               |
| HTTP action response size                                                    | 20 MiB                                                                    | 20 MiB                                                    | There is no specific limit on request size                                                                    |
| Length of a console.log line                                                 | 4 KiB                                                                     | 4 KiB                                                     |                                                                                                               |
| [Log streaming](/production/integrations/log-streams/log-streams.mdx) limits | 4096 logs, flushed every 10 seconds                                       | 4096 logs, flushed every 10 seconds                       | How many logs can be buffered when streaming                                                                  |

## Concurrent Function Executions

Number of functions you can run at a time for each function type.

|                        | Free/Starter | Professional<sup>\*</sup> |
| ---------------------- | ------------ | ------------------------- |
| Queries                | 16           | 256                       |
| Mutations              | 16           | 256                       |
| Convex runtime actions | 64           | 256                       |
| Node actions           | 64           | 1000                      |
| HTTP actions           | 16           | 128                       |
| Scheduled jobs         | 10           | 300                       |

<sup>*</sup> Limits can be lifted for Professional plan customers on a
case-by-case basis. Send us support message through the dashboard to discuss
your needs. Usually this is only needed if your product has highly bursty
traffic.

## Execution time and scheduling

|                                              |                 | Notes                                                                                                                   |
| -------------------------------------------- | --------------- | ----------------------------------------------------------------------------------------------------------------------- |
| Query/mutation execution time                | 1 second        | Limit applies only to user code and doesn’t include database operations.                                                |
| Action execution time                        | 10&nbsp;minutes |                                                                                                                         |
| Scheduled functions                          | 1000            | The number of other functions a single mutation can schedule.                                                           |
| Total size of scheduled functions' arguments | 16 MiB          | Applies only to mutations.                                                                                              |
| Concurrent IO operations per function        | 1000            | The number of IO operations a single function can perform, e.g., a database operation, or a fetch request in an action. |
| Outstanding scheduled functions              | 1,000,000       |                                                                                                                         |

## Transactions

These limits apply to each `query` or `mutation` function.

|                            |        | Notes                                                     |
| -------------------------- | ------ | --------------------------------------------------------- |
| Data read                  | 16 MiB | Data not returned due to a `filter` counts as scanned     |
| Data written               | 16 MiB |
| Documents scanned          | 32,000 | Documents not returned due to a `filter` count as scanned |
| Index ranges read          | 4,096  | The number of calls to `db.get` and `db.query`.           |
| Documents written          | 16,000 |
| Function return value size | 16 MiB |

## Environment Variables

Applied per-deployment.

|                     |               |
| ------------------- | ------------- |
| Number of variables | 1000          |
| Maximum name length | 40 characters |
| Maximum value size  | 8 KiB         |

## File Storage

|           | Free/Starter                                                     | Professional                                        | Notes                                                                                                     |
| --------- | ---------------------------------------------------------------- | --------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| Storage   | 1 GiB included<br/>(on Starter: $0.033/month per additional GiB) | 100 GiB included<br/>$0.03/month per additional GiB | Includes user files and backups.                                                                          |
| Bandwidth | 1 GiB/month included<br/>(on Starter: $0.33 per additional GiB)  | 50 GiB/month included<br/>$0.30 per additional GiB  | Includes serving user files, accessing user files inside functions, and generating and restoring backups. |

## Full text search

|                          | Value |
| ------------------------ | ----- |
| Search indexes per table | 4     |
| Filters per search index | 16    |
| Terms per search query   | 16    |
| Filters per search query | 8     |
| Maximum term length      | 32 B  |
| Maximum result set       | 1024  |

## Vector search

|                          | Value                    |
| ------------------------ | ------------------------ |
| Vector indexes per table | 4                        |
| Filters per vector index | 16                       |
| Terms per search query   | 16                       |
| Vectors to search by     | 1                        |
| Dimension fields         | 1 (value between 2-4096) |
| Filters per search query | 64                       |
| Maximum term length      | 32 B                     |
| Maximum result set       | 256 (defaults to 10)     |

If any of these limits don't work for you,
[let us know](https://convex.dev/community)!

Please see our [plans and pricing page](https://www.convex.dev/pricing) for
resource limits. After these limits are hit on a free plan, new mutations that
attempt to commit more insertions or updates may fail. Paid plans have no hard
resource limits - they can scale to billions of documents and TBs of storage.



================================================
FILE: npm-packages/docs/docs/production/state/state.mdx
================================================
---
title: "Status and Guarantees"
id: "state"
sidebar_position: 1
description:
  "Learn about Convex's production guarantees, availability targets, data
  durability, security features, and upcoming platform enhancements."
---

Please [contact us](mailto:support@convex.dev) with any specific requirements or
if you want to build a project on Convex that is not yet satisfied by our
guarantees.

## Guarantees

The official Convex Terms of Service, Privacy Policy and Customer Agreements are
[outlined in our official terms](https://www.convex.dev/legal/tos). We do not
yet have contractual agreements beyond what is listed in our official terms and
the discussions within this document don't constitute an amendment to these
terms.

Convex is always under continual development and future releases may require
code changes in order to upgrade to a new version. Code developed on Convex 1.0
or later will continue to operate as-is. If we are required to make a breaking
change in future we will contact teams directly to provide substantial advance
notice.

All user data in Convex is encrypted at rest. Database state is replicated
durably across multiple physical availability zones. Regular periodic and
incremental database backups are performed and stored with 99.999999999% (11
9's) durability.

We target an availability of 99.99% (4 9's) for Convex deployments although
these may experience downtime for maintenance without notice. A physical outage
may affect availability of a deployment but will not affect durability of the
data stored in Convex.

## Limits

For information on limits, see [here](/production/state/limits.mdx).

## Beta Features

Features tagged with **beta** in these docs are still in development. They can
be used in production but their APIs might change in the future, requiring
additional effort when upgrading to a new version of the Convex NPM package and
other Convex client libraries.

## Future Features

Convex is still under very active development and here we list some of the
missing functionality on our radar. We'd love to hear more about your
requirements in the [Convex Discord Community](https://convex.dev/community).

### Authorization

Convex currently has an [_authentication framework_](/auth.mdx) which verifies
user identities. In the future we plan to add an _authorization framework_ which
will allow developers to define what data a user can access.

For now, you can implement manual authorization checks within your queries and
mutations, but stay tuned for a more comprehensive, fool-proof solution in the
future.

### Telemetry

Currently, the dashboard provides only basic metrics. Serious sites at scale are
going to need to integrate our logs and metrics into more fully fledged
observability systems that categorize them and empower things like alerting.

Convex will eventually have methods to publish deployment data in formats that
can be ingested by third parties.

### Analytics / OLAP

Convex is designed to primarily service all your app's realtime implementation
(OLTP) needs. It is less suited to be a good solution for the kinds of complex
queries and huge table scans that are necessary to address the requirements of
analytics (OLAP) use cases.

Convex exposes
[Fivetran and Airbyte connectors](/production/integrations/streaming-import-export.md)
to export Convex data to external analytics systems.

### Browser support

Convex does not yet have an official browser support policy, but we strive to
support most modern browsers with significant
[usage](https://caniuse.com/usage-table).



================================================
FILE: npm-packages/docs/docs/quickstart/android.mdx
================================================
---
title: Android Kotlin Quickstart
sidebar_label: Android Kotlin
description: "Add Convex to an Android Kotlin project"
hide_table_of_contents: true
sidebar_position: 600
---

Learn how to query data from Convex in a Android Kotlin project.

This quickstart assumes that you have Android Studio, node and npm installed. If
you don’t have those tools, take time to install them first.

<StepByStep>
  <Step title="Create a new Android app in Android Studio">
    Choose the following options in the wizard.

    ```
    1. Choose the "Empty Activity" template
    2. Name it "Convex Quickstart"
    3. Choose min SDK as 26
    4. Choose Kotlin as the Gradle DSL
    ```

  </Step>

  <Step title="Configure the AndroidManifest">
    Add the following to your `AndroidManifest.xml`.

    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">
        // highlight-next-line
        <uses-permission android:name="android.permission.INTERNET"/>
        <application>
            <!-- ... existing application contents -->
        </application>
    </manifest>
    ```

  </Step>

  <Step title="Configure your dependencies">
    Add the following entries to the `:app` `build.gradle.kts` file (ignore IDE
    suggestion to move them to version catalog for now, if present).
    
    Ensure that you sync Gradle when all of the above is complete (Android
    Studio should prompt you to do so).

    ```kotlin
    plugins {
        // ... existing plugins
        // highlight-next-line
        kotlin("plugin.serialization") version "1.9.0"
    }

    dependencies {
        // ... existing dependencies
        // highlight-next-line
        implementation("dev.convex:android-convexmobile:0.4.1@aar") {
            // highlight-next-line
            isTransitive = true
        // highlight-next-line
        }
        // highlight-next-line
        implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
    }
    ```

  </Step>

  <Step title="Install the Convex Backend">
    Open a terminal in your Android Studio instance and install the Convex 
    client and server library.

    ```bash
    npm init -y
    npm install convex
    ```

  </Step>

  <Step title="Start Convex">
    Start a Convex dev deployment. Follow the command line instructions.

    ```bash
    npx convex dev
    ```

  </Step>

  <Step title="Create a sample data for your database">
    Create a new `sampleData.jsonl` file with these contents.

    ```json
    {"text": "Buy groceries", "isCompleted": true}
    {"text": "Go for a swim", "isCompleted": true}
    {"text": "Integrate Convex", "isCompleted": false}
    ```

  </Step>

  <Step title="Add the sample data to your database">
    Open another terminal tab and run.

    ```bash
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Create a `tasks.ts` file in your `convex/` directory with the following 
    contents.

    ```tsx
    import { query } from "./_generated/server";

    export const get = query({
      args: {},
      handler: async (ctx) => {
        return await ctx.db.query("tasks").collect();
      },
    });
    ```

  </Step>

  <Step title="Create a data class">
    Add a new `data class` to your `MainActivity` to support the task data 
    defined above. Import whatever it asks you to.

    ```kotlin
    @Serializable
    data class Task(val text: String, val isCompleted: Boolean)
    ```

  </Step>

  <Step title="Create your UI">
    Delete the template `@Composable` functions that Android Studio created and
    add a new one to display data from your Convex deployment. Again, import
    whatever it asks you to.

    ```kotlin
    @Composable
    fun Tasks(client: ConvexClient, modifier: Modifier = Modifier) {
        var tasks: List<Task> by remember { mutableStateOf(listOf()) }
        LaunchedEffect(key1 = "launch") {
            client.subscribe<List<Task>>("tasks:get").collect { result ->
                result.onSuccess { remoteTasks ->
                    tasks = remoteTasks
                }
            }
        }
        LazyColumn(
            modifier = modifier
        ) {
            items(tasks) { task ->
                Text(text = "Text: ${task.text}, Completed?: ${task.isCompleted}")
            }
        }
    }
    ```

  </Step>

  <Step title="Connect the app to your backend">
    1. Get the deployment URL of your dev server with
        `cat .env.local | grep CONVEX_URL`
    2. Update the `onCreate` method in your `MainActivity.kt` to look like

    ```kotlin
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            ConvexQuickstartTheme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    // highlight-next-line
                    Tasks(
                        // highlight-next-line
                        client = ConvexClient($YOUR_CONVEX_URL),
                        // highlight-next-line
                        modifier = Modifier.padding(innerPadding)
                    // highlight-next-line
                    )
                }
            }
        }
    }
    ```

  </Step>

  <Step title="Fix any missing imports">
    Fix up any missing imports (your import declarations should look something
    like this):

    ```kotlin
    import android.os.Bundle
    import androidx.activity.ComponentActivity
    import androidx.activity.compose.setContent
    import androidx.activity.enableEdgeToEdge
    import androidx.compose.foundation.layout.fillMaxSize
    import androidx.compose.foundation.layout.padding
    import androidx.compose.foundation.lazy.LazyColumn
    import androidx.compose.foundation.lazy.items
    import androidx.compose.material3.Scaffold
    import androidx.compose.material3.Text
    import androidx.compose.runtime.Composable
    import androidx.compose.runtime.LaunchedEffect
    import androidx.compose.runtime.getValue
    import androidx.compose.runtime.mutableStateOf
    import androidx.compose.runtime.remember
    import androidx.compose.runtime.setValue
    import androidx.compose.ui.Modifier
    import dev.convex.android.ConvexClient
    import kotlinx.serialization.Serializable
    ```

  </Step>
  <Step title="Run the app">
    You can also try adding, updating or deleting documents in your `tasks`
    table at `dashboard.convex.dev` - the app will update with the changes in
    real-time.

    ```
    From the IDE menu choose "Run" > "Run 'app'"
    ```

  </Step>

</StepByStep>

See the complete [Android Kotlin documentation](/client/android.md).



================================================
FILE: npm-packages/docs/docs/quickstart/bun.mdx
================================================
---
title: Bun Quickstart
sidebar_label: Bun
description: "Add Convex to a Bun project"
hide_table_of_contents: true
sidebar_position: 450
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/bun/sampleData.jsonl";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/bun/convex/tasks.js";
import script from "!!raw-loader!@site/../private-demos/quickstarts/bun/index.ts";

Learn how to query data from Convex in a Bun project.

For instructions for subscriptions instead of point-in-time queries see
[Bun notes](/client/javascript/bun.mdx).

# Using Convex with Bun

<StepByStep>
  <Step title="Create a new Bun project">
    Create a new directory for your Bun project.

    ```sh
    mkdir my-project && cd my-project && bun init -y
    ```

  </Step>
  <Step title="Install the Convex client and server library">
    Install the `convex` package.

    ```sh
    bun add convex
    ```

  </Step>
  <Step title="Set up a Convex dev deployment">
    Next, run `bunx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    bunx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    bunx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file `tasks.js` in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasks}
      title="convex/tasks.js"
    />

  </Step>

  <Step title="Connect the script to your backend">
    In a new file `index.ts`, create a `ConvexClient` using
    the URL of your development environment.

    <Snippet
      source={script}
      title="index.ts"
    />

  </Step>

  <Step title="Run the script">
    Run the script from the same directory and see the list of tasks logged to the terminal.

    ```sh
    bun index.ts
    ```

  </Step>

</StepByStep>

See the complete [Bun documentation](/client/javascript/bun.mdx).



================================================
FILE: npm-packages/docs/docs/quickstart/nextjs.mdx
================================================
---
title: Next.js Quickstart
sidebar_label: Next.js
description: "Add Convex to a Next.js project"
hide_table_of_contents: true
sidebar_position: 200
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/nextjs/sampleData.jsonl";
import layout from "!!raw-loader!@site/../private-demos/quickstarts/nextjs-app-dir/app/layout.tsx";
import ConvexClientProvider from "!!raw-loader!@site/../private-demos/quickstarts/nextjs-app-dir/app/ConvexClientProvider.tsx";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/nextjs-app-dir/convex/tasks.ts";
import page from "!!raw-loader!@site/../private-demos/quickstarts/nextjs-app-dir/app/page.tsx";
import layoutJs from "!!raw-loader!@site/../private-demos/quickstarts/nextjs-app-dir-js/app/layout.js";
import ConvexClientProviderJs from "!!raw-loader!@site/../private-demos/quickstarts/nextjs-app-dir-js/app/ConvexClientProvider.jsx";
import tasksJs from "!!raw-loader!@site/../private-demos/quickstarts/nextjs-app-dir-js/convex/tasks.js";
import pageJs from "!!raw-loader!@site/../private-demos/quickstarts/nextjs-app-dir-js/app/page.js";

<Admonition type="tip" title="Convex + Next.js">

Convex is an all-in-one backend and database that integrates quickly and easily
with Next.js.

Once you've gotten started, see how to set up
[hosting](/production/hosting/hosting.mdx),
[server rendering](/client/nextjs/app-router/server-rendering.mdx), and
[auth](https://docs.convex.dev/client/nextjs/).

</Admonition>

To get setup quickly with Convex and Next.js run

<p>
  <b>
    <CodeWithCopyButton text="npm create convex@latest" />
  </b>
</p>

or follow the guide below.

---

Learn how to query data from Convex in a Next.js app using the App Router
and<LanguageSelector verbose />

Alternatively see the
[Pages Router](/client/nextjs/pages-router/quickstart-nextjs-pages-router.mdx)
version of this quickstart.

<StepByStep>
  <Step title="Create a Next.js app">
    Create a Next.js app using the `npx create-next-app` command.

    Choose the default option for every prompt (hit Enter).

    <JSDialectVariants>
      ```sh
      npx create-next-app@latest my-app
      ```

      ```sh
      npx create-next-app@latest my-app --js
      ```
    </JSDialectVariants>

  </Step>
  <Step title="Install the Convex client and server library">
    To get started, install the `convex` package.

    Navigate to your app and install `convex`.


    ```sh
    cd my-app && npm install convex
    ```

  </Step>
  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Use the [`import`](/database/import-export/import) command to add a `tasks` table with the sample data into your Convex database.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    In the `convex/` folder, add a new file <JSDialectFileName name="tasks.ts" /> with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name: `api.tasks.get`.

    <TSAndJSSnippet
      sourceTS={tasks}
      sourceJS={tasksJs}
      title="convex/tasks.ts"
    />

  </Step>

  <Step title="Create a client component for the Convex provider">
    For `<ConvexProvider>` to work on the client, `ConvexReactClient` must be passed to it.

    In the `app/` folder, add a new file <JSDialectFileName name="ConvexClientProvider.tsx" /> with the following code. This creates a client component that wraps `<ConvexProvider>` and passes it the `<ConvexReactClient>`.

    <TSAndJSSnippet
      sourceTS={ConvexClientProvider}
      sourceJS={ConvexClientProviderJs}
      title="app/ConvexClientProvider.tsx"
    />

  </Step>

  <Step title="Wire up the ConvexClientProvider">
    In <JSDialectFileName name="app/layout.tsx" ext="js" />, wrap the children of the `body` element with the `<ConvexClientProvider>`.

    <TSAndJSSnippet
      sourceTS={layout}
      sourceJS={layoutJs}
      title="app/layout.tsx"
      jsExtension="js"
      highlightPatterns={[ "Convex", ]}
    />

  </Step>

  <Step title="Display the data in your app">
    In <JSDialectFileName name="app/page.tsx" ext="js" />, use the `useQuery()` hook to fetch from your `api.tasks.get`
    API function.

    <TSAndJSSnippet
      sourceTS={page}
      sourceJS={pageJs}
      title="app/page.tsx"
      jsExtension="js"
      highlightPatterns={[ "use client", "useQuery", "api", "tasks", "text", "\\)\\)\\}" ]}
    />

  </Step>

  <Step title="Start the app">
    Run your Next.js development server, open [http://localhost:3000](http://localhost:3000) in a browser,
    and see the list of tasks.

    ```sh
    npm run dev
    ```

  </Step>

</StepByStep>

See the complete [Next.js documentation](/client/nextjs/app-router/index.mdx).



================================================
FILE: npm-packages/docs/docs/quickstart/nodejs.mdx
================================================
---
title: Node.js Quickstart
sidebar_label: Node.js
description: "Add Convex to a Node.js project"
hide_table_of_contents: true
sidebar_position: 400
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/nodejs/sampleData.jsonl";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/nodejs/convex/tasks.js";
import script from "!!raw-loader!@site/../private-demos/quickstarts/nodejs/script.js";

Learn how to query data from Convex in a Node.js project.

For instructions for subscriptions instead of point-in-time queries and more
project configurations (TypeScript, bundlers, CJS vs ESM) see
[Node.js notes](/client/javascript/node.mdx).

<StepByStep>
  <Step title="Create a new npm project">
    Create a new directory for your Node.js project.

    ```sh
    mkdir my-project && cd my-project && npm init -y && npm pkg set type="module"
    ```

  </Step>
  <Step title="Install the Convex client and server library">
    Install the `convex`
    package which provides a convenient interface for working
    with Convex from JavaScript.

    Also install the `dotenv` library for loading `.env` files.

    ```sh
    npm install convex dotenv
    ```

  </Step>
  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file `tasks.js` in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasks}
      title="convex/tasks.js"
    />

  </Step>

  <Step title="Connect the script to your backend">
    In a new file `script.js`, create a `ConvexHttpClient` using
    the URL of your development environment.

    <Snippet
      source={script}
      title="script.js"
    />

  </Step>

  <Step title="Run the script">
    Run the script from the same directory and see the list of tasks logged to the terminal.

    ```sh
    node script.js
    ```

  </Step>

</StepByStep>

See the complete [Node.js documentation](/client/javascript/node.mdx).



================================================
FILE: npm-packages/docs/docs/quickstart/nuxt.mdx
================================================
---
title: Nuxt Quickstart
sidebar_label: Nuxt
description: "Add Convex to a Nuxt project"
hide_table_of_contents: true
sidebar_position: 325
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/vue/sampleData.jsonl";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/nuxt/convex/tasks.ts";
import schema from "!!raw-loader!@site/../private-demos/quickstarts/nuxt/convex/schema.ts";
import App from "!!raw-loader!@site/../private-demos/quickstarts/nuxt/app/app.vue";

Learn how to query data from Convex in a Nuxt app.

This quickstart guide uses a [community-maintained](/client/vue/nuxt.md) Nuxt
client for Convex.

<StepByStep>
  <Step title="Create a Nuxt application">
    Create a Nuxt application using the `npm create nuxt@latest my-nuxt-app` command.

    Convex will work with any of the official modules but to follow this quickstart skip installing them for now.

    <br></br>

    ```sh
    npm create nuxt@latest my-nuxt-app
    ```

  </Step>

  <Step title="Install the Convex library">
    To get started, install the `convex` package and the `convex-nuxt` module to your Nuxt application.

    ```sh
    cd my-nuxt-app && npm install convex && npx nuxi module add convex-nuxt
    ```

  </Step>

  <Step title="Add the Convex URL">
    Add the Convex URL to your `nuxt.config.ts` file.

    ```ts noDialect title="nuxt.config.ts"
    export default defineNuxtConfig({
      compatibilityDate: '2025-07-15',
      devtools: { enabled: true },
      modules: ['convex-nuxt'],
      // highlight-start
      convex: {
        url: process.env.CONVEX_URL
      },
      // highlight-end
    })
    ```

  </Step>

  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="(optional) Define a schema">
    Add a new file `schema.ts` in the `convex/` folder
    with a description of your data.

    This will declare the types of your data for optional
    typechecking with TypeScript, and it will be also
    enforced at runtime.

    <br></br>

    <Snippet
      source={schema}
      title="convex/schema.ts"
    />

  </Step>

  <Step title="Expose a database query">
    Add a new file `tasks.ts` in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasks}
      title="convex/tasks.ts"
    />

  </Step>

  <Step title="Display the data in your app">
    In `app.vue` use `useQuery` to subscribe your `api.tasks.get`
    API function.

    <Snippet
      source={App}
      title="app/app.vue"
    />

  </Step>

  <Step title="Update script to start development server">
    By default, Convex stores environment variables in `.env.local`, and Nuxt
    looks for environment variables in `.env`.

    To use the default `npm run dev` command,
    update your `package.json` to use the `--dotenv .env.local` flag.

    ```json title="package.json"
    {
      "name": "nuxt-app",
      "private": true,
      "type": "module",
      "scripts": {
        "build": "nuxt build",
        // highlight-next-line
        "dev": "nuxt dev --dotenv .env.local",
        "generate": "nuxt generate",
        "preview": "nuxt preview",
        "postinstall": "nuxt prepare"
      },
      "dependencies": {
        "convex": "^1.25.2",
        "convex-nuxt": "^0.1.3",
        "nuxt": "^3.17.6",
        "vue": "^3.5.17",
        "vue-router": "^4.5.1"
      }
    }
    ```

  </Step>

  <Step title="Start the app">
    Start the app, open [http://localhost:3000](http://localhost:3000) in a browser,
    and see the list of tasks.

    ```sh
    npm run dev
    ```

  </Step>

</StepByStep>

For more examples, take a look at the
[Nuxt Convex module repository](https://github.com/chris-visser/convex-nuxt).

See the complete
[Nuxt npm package documentation](https://www.npmjs.com/package/convex-nuxt).



================================================
FILE: npm-packages/docs/docs/quickstart/python.mdx
================================================
---
title: Python Quickstart
sidebar_label: Python
description: "Add Convex to a Python project"
hide_table_of_contents: true
sidebar_position: 500
---

import sampleData from "!!raw-loader!@site/../demos/python-quickstart/sampleData.jsonl";
import tasks from "!!raw-loader!@site/../demos/python-quickstart/convex/tasks.js";
import main from "!!raw-loader!@site/../demos/python-quickstart/main.py";

Learn how to query data from Convex in a Python app.

<StepByStep>
  <Step title="Create a Python script folder">
    Create a folder for your Python script
    with a virtual environment.

    ```sh
    python3 -m venv my-app/venv
    ```

  </Step>
  <Step title="Install the Convex client and server libraries">
    To get started, install the `convex` npm
    package which enables you to write your
    backend.

    And also install the `convex` Python client
    library and `python-dotenv` for working with `.env` files.

    ```sh
    cd my-app && npm init -y && npm install convex && venv/bin/pip install convex python-dotenv
    ```

  </Step>
  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file `tasks.js` in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `"tasks:get"`.

    <Snippet
      source={tasks}
      title="convex/tasks.js"
    />

  </Step>

  <Step title="Create a script to load data from Convex">
    In a new file `main.py`, create a `ConvexClient` and use it
    to fetch from your `"tasks:get"` API.
    
    <Snippet
      source={main}
      title="main.py"
    />

  </Step>

  <Step title="Run the script">
      Run the script 
      and see the serialized list of tasks.

      ```sh
      venv/bin/python -m main
      ```

  </Step>

</StepByStep>

See the [docs on PyPI](https://pypi.org/project/convex/) for more details.



================================================
FILE: npm-packages/docs/docs/quickstart/react-native.mdx
================================================
---
title: React Native Quickstart
sidebar_label: React Native
description: "Add Convex to a React Native Expo project"
hide_table_of_contents: true
sidebar_position: 300
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/expo/sampleData.jsonl";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/expo/convex/tasks.ts";
import layout from "!!raw-loader!@site/../private-demos/quickstarts/expo/app/_layout.tsx";
import index from "!!raw-loader!@site/../private-demos/quickstarts/expo/app/index.tsx";

Learn how to query data from Convex in a React Native app.

<StepByStep>
  <Step title="Create a React Native app">
    Create a React Native app using the `npx create-expo-app` command.

    ```sh
    npx create-expo-app my-app
    ```

  </Step>
  <Step title="Install the Convex client and server library">
    To get started, install the `convex`
    package which provides a convenient interface for working
    with Convex from a React app.

    Navigate to your app and install `convex`.

    ```sh
    cd my-app && npm install convex
    ```

  </Step>
  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.

    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    Create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table with the sample data into
    your Convex database with the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file `tasks.ts` in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasks}
      title="convex/tasks.ts"
    />

  </Step>

  <Step title="Reset the Expo project">
    If you haven't done so yet, reset the Expo project to get a fresh
    `app` directory.

    ```
    npm run reset-project
    ```

  </Step>

  <Step title="Connect the app to your backend">
    In `_layout.tsx`, create a `ConvexReactClient` and pass it to a `ConvexProvider`
    wrapping your component tree.

    <Snippet
      source={layout}
      title="app/_layout.tsx"
      highlightPatterns={[ "Convex", "get-random", "CONVEX", "unsaved", "}\\);", ]}
    />

  </Step>

  <Step title="Display the data in your app">
    In `index.tsx` use the `useQuery` hook to fetch
    from your `api.tasks.get` API.

    <Snippet
      source={index}
      title="app/index.tsx"
      highlightPatterns={[ "api", "useQuery", "tasks" ]}
    />

  </Step>

  <Step title="Start the app">
    Start the app, scan the provided QR code with your phone,
    and see the serialized list of tasks in the center of the screen.

    ```sh
    npm start
    ```

  </Step>
</StepByStep>

React native uses the same library as React web. See the complete
[React documentation](/client/react.mdx).



================================================
FILE: npm-packages/docs/docs/quickstart/react.mdx
================================================
---
title: React Quickstart
sidebar_label: React
description: "Add Convex to a React project"
hide_table_of_contents: true
sidebar_position: 100
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/sampleData.jsonl";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/convex/tasks.js";
import main from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/src/main.jsx";
import App from "!!raw-loader!@site/../private-demos/quickstarts/react-vite/src/App.jsx";
import tasksTS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite-ts/convex/tasks.ts";
import mainTS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite-ts/src/main.tsx";
import AppTS from "!!raw-loader!@site/../private-demos/quickstarts/react-vite-ts/src/App.tsx";

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/4MgsvjMb59Q"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerpolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

To get setup quickly with Convex and React run

<p>
  <b>
    <CodeWithCopyButton text="npm create convex@latest" />
  </b>
</p>

or follow the guide below.

---

Learn how to query data from Convex in a React app using Vite
and<LanguageSelector verbose />

<StepByStep>
  <Step title="Create a React app">
    Create a React app using the `create vite` command.

    <JSDialectVariants>
      ```sh
      npm create vite@latest my-app -- --template react-ts
      ```

      ```sh
      npm create vite@latest my-app -- --template react
      ```
    </JSDialectVariants>

  </Step>
  <Step title="Install the Convex client and server library">
    To get started, install the `convex`
    package which provides a convenient interface for working
    with Convex from a React app.

    Navigate to your app directory and install `convex`.


    ```sh
    cd my-app && npm install convex
    ```

  </Step>
  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="(optional) Define a schema">
    Add a new file `schema.ts` in the `convex/` folder
    with a description of your data.

    This will declare the types of your data for optional
    typechecking with TypeScript, and it will be also
    enforced at runtime.

    <JSDialectVariants>
    Alternatively remove the line `'plugin:@typescript-eslint/recommended-requiring-type-checking',`
    from the `.eslintrc.cjs` file to lower the type checking strictness.

    <></>
    </JSDialectVariants>

    ```ts noDialect title="convex/schema.ts"
    import { defineSchema, defineTable } from "convex/server";
    import { v } from "convex/values";

    export default defineSchema({
      tasks: defineTable({
        text: v.string(),
        isCompleted: v.boolean(),
      }),
    });
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file <JSDialectFileName name="tasks.ts" /> in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <TSAndJSSnippet
      sourceTS={tasksTS}
      sourceJS={tasks}
      title="convex/tasks.ts"
    />

  </Step>

  <Step title="Connect the app to your backend">
    In <JSDialectFileName name="src/main.jsx" />, create a `ConvexReactClient` and pass it to a `ConvexProvider`
    wrapping your app.

    <TSAndJSSnippet
      sourceTS={mainTS}
      sourceJS={main}
      title="src/main.tsx"
      highlightPatterns={[ "Convex", ]}
    />

  </Step>

  <Step title="Display the data in your app">
    In <JSDialectFileName name="src/App.jsx" />, use the `useQuery` hook to fetch from your `api.tasks.get`
    API function and display the data.

    <TSAndJSSnippet
      sourceTS={AppTS}
      sourceJS={App}
      title="src/App.tsx"
      highlightPatterns={[ "useQuery", "api", "tasks", "text", "\\)\\)\\}" ]}
    />

  </Step>

  <Step title="Start the app">
    Start the app, open [http://localhost:5173/](http://localhost:5173/) in a browser,
    and see the list of tasks.

    ```sh
    npm run dev
    ```

  </Step>

</StepByStep>

See the complete [React documentation](/client/react.mdx).



================================================
FILE: npm-packages/docs/docs/quickstart/remix.mdx
================================================
---
title: Remix Quickstart
sidebar_label: Remix
description: "Add Convex to a Remix project"
hide_table_of_contents: true
sidebar_position: 200
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/remix/sampleData.jsonl";
import root from "!!raw-loader!@site/../private-demos/quickstarts/remix/app/root.tsx";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/remix/convex/tasks.ts";
import index from "!!raw-loader!@site/../private-demos/quickstarts/remix/app/routes/_index.tsx";

Learn how to query data from Convex in a Remix app.

<StepByStep>
  <Step title="Create a Remix site">
    Create a Remix site using the `npx create-remix@latest` command.

    <br></br>

    ```sh
    npx create-remix@latest my-remix-app
    ```

  </Step>

  <Step title="Install the Convex library">
    To get started, install the `convex` package.

    ```sh
    cd my-remix-app && npm install convex
    ```

  </Step>

  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    Create a `sampleData.jsonl` file at the root of you app
    and fill it with the sample data given.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data you just created in `sampleData.jsonl`
    into your Convex database with the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file <JSDialectFileName name="tasks.ts" /> in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasks}
      title="convex/tasks.ts"
    />

  </Step>

  <Step title="Wire up the ConvexProvider">
    Modify `app/root.tsx` to set up the Convex client there to make it available on every page of your app.

    <Snippet
      source={root}
      title="app/root.tsx"
    />

  </Step>

  <Step title="Display the data in your app">
    In `app/routes/_index.tsx` use `useQuery` to subscribe your `api.tasks.get`
    API function.

    <Snippet
      source={index}
      title="app/routes/_index.tsx"
    />

  </Step>

  <Step title="Start the app">
    Start the app, open [http://localhost:5173](http://localhost:5173) in a browser,
    and see the list of tasks.

    ```sh
    npm run dev
    ```

  </Step>

</StepByStep>

Remix uses the React web library. See the complete
[React documentation](/client/react.mdx).



================================================
FILE: npm-packages/docs/docs/quickstart/rust.mdx
================================================
---
title: Rust Quickstart
sidebar_label: Rust
description: "Add Convex to a Rust project"
hide_table_of_contents: true
sidebar_position: 700
---

import sampleData from "!!raw-loader!@site/../../crates/convex/examples/quickstart/sampleData.jsonl";
import tasks from "!!raw-loader!@site/../../crates/convex/examples/quickstart/convex/tasks.js";
import main from "!!raw-loader!@site/../../crates/convex/examples/quickstart/main.rs";

Learn how to query data from Convex in a Rust app with Tokio.

<StepByStep>
  <Step title="Create a Cargo project">
    Create a new Cargo project.

    ```sh
    cargo new my_app
    cd my_app
    ```

  </Step>
  <Step title="Install the Convex client and server libraries">
    To get started, install the `convex` npm
    package which enables you to write your
    backend.

    And also install the `convex` Rust client library,
    the `tokio` runtime, and `dotenvy` for working with `.env` files.

    ```sh
    npm init -y && npm install convex && cargo add convex tokio dotenvy
    ```

  </Step>
  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file `tasks.js` in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `"tasks:get"`.

    <Snippet
      source={tasks}
      title="convex/tasks.js"
    />

  </Step>

  <Step title="Connect the app to your backend">
    In the file `src/main.rs`, create a `ConvexClient` and use it
    to fetch from your `"tasks:get"` API.
    
    <Snippet
      source={main}
      title="src/main.rs"
    />

  </Step>

  <Step title="Run the app">
      Run the app and see the serialized list of tasks.

      ```sh
      cargo run
      ```

  </Step>

</StepByStep>

See the complete [Rust documentation](https://docs.rs/convex/latest/convex/).



================================================
FILE: npm-packages/docs/docs/quickstart/script-tag.mdx
================================================
---
title: Script Tag Quickstart
sidebar_label: Script Tag
description: "Add Convex to any website"
hide_table_of_contents: true
sidebar_position: 450
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/nodejs/sampleData.jsonl";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/nodejs/convex/tasks.js";
import html from "!!raw-loader!@site/../demos/html/simple.html";

Learn how to query data from Convex from script tags in HTML.

<StepByStep>
  <Step title="Create a new npm project">
    Create a new directory for your Convex project.

    ```sh
    mkdir my-project && cd my-project && npm init -y
    ```

  </Step>
  <Step title="Install the Convex client and server library">
    Install the `convex`
    package which provides a convenient interface for working
    with Convex from JavaScript.

    ```sh
    npm install convex
    ```

  </Step>
  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file `tasks.js` in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasks}
      title="convex/tasks.js"
    />

  </Step>

  <Step title="Copy the deployment URL">
    Open the `.env.local` file and copy the `CONVEX_URL` of your development
    environment for use in the HTML file.

    <></>

  </Step>

  <Step title="Add the script to your webpage">
    In a new file `index.html`, create a `ConvexClient` using
    the URL of your development environment.

    Open this file in a web browser and you'll see it run each time the `tasks`
    table is modified.

    <Snippet
      source={html}
      title="index.html"
      replacements={[
        [/https?:\/\/localhost:8000/g, 'CONVEX_URL_GOES_HERE'],
        [/messages:list/g, 'tasks:get'],
        [/\(messages\)/g, '(tasks)'],
        [/messages.map\(\(msg\) \=\> msg\.body\)/g, 'tasks.map((task) => task.text)'],
      ]}
    />

  </Step>

</StepByStep>

See the complete [Script Tag documentation](/client/javascript/script-tag.mdx).



================================================
FILE: npm-packages/docs/docs/quickstart/svelte.mdx
================================================
---
title: Svelte Quickstart
sidebar_label: Svelte
description: "Add Convex to a Svelte project"
hide_table_of_contents: true
sidebar_position: 350
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/sveltekit/sampleData.jsonl";
import layout from "!!raw-loader!@site/../private-demos/quickstarts/sveltekit/src/routes/+layout.svelte";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/sveltekit/src/convex/tasks.ts";
import page from "!!raw-loader!@site/../private-demos/quickstarts/sveltekit/src/routes/+page.svelte";

Learn how to query data from Convex in a Svelte app.

<StepByStep>
  <Step title="Create a SvelteKit app">
    Create a SvelteKit app using the `npx sv create` command.

    Other sets of options will work with the library but for this quickstart guide:

    - For "Which Svelte app template," choose **"SvelteKit minimal."**
    - For a package manager, choose **"npm."**
    - For "Add type checking with TypeScript," choose **"Yes, using TypeScript syntax."**
    - For "Select additional options," you don't need to enable anything.

    <br></br>

    ```sh
    npx sv@latest create my-app
    ```

  </Step>

  <Step title="Install the Convex client and server library">
    To get started, install the `convex` and `convex-svelte` packages.

    ```sh
    cd my-app && npm install convex convex-svelte
    ```

  </Step>

  <Step title="Customize the convex path">
    SvelteKit doesn't like referencing code outside of source, so customize
    the convex functionsDir to be under `src/`.

    <Snippet
      source={'{\n\t\"functions\": "src/convex/\"\n}'}
      title="convex.json"
    />

  </Step>

  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `src/convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file <JSDialectFileName name="tasks.ts" /> in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasks}
      title="src/convex/tasks.ts"
    />

  </Step>

  <Step title="Set up Convex">
    Create a new file `src/routes/+layout.svelte` and set up the Convex client there to make it available on every page of your app.

    <Snippet
      source={layout}
      title="src/routes/+layout.svelte"
    />

  </Step>

  <Step title="Display the data in your app">
    In `src/routes/+page.svelte` use `useQuery` to subscribe your `api.tasks.get`
    API function.

    <Snippet
      source={page}
      title="src/routes/+page.svelte"
      jsExtension="js"
    />

  </Step>

  <Step title="Start the app">
    Start the app, open [http://localhost:5173](http://localhost:5173) in a browser,
    and see the list of tasks.

    ```sh
    npm run dev
    ```

  </Step>

</StepByStep>

See the
[Svelte npm package documentation](https://www.npmjs.com/package/convex-svelte).



================================================
FILE: npm-packages/docs/docs/quickstart/swift.mdx
================================================
---
title: iOS Swift Quickstart
sidebar_label: iOS Swift
description: "Add Convex to an iOS Swift project"
hide_table_of_contents: true
sidebar_position: 600
---

Learn how to query data from Convex in an application targeting iOS and MacOS
devices built with Swift and SwiftUI.

This quickstart assumes that you have a Mac with Xcode, node and npm installed.
If you don’t have those tools, take time to install them first.

<StepByStep>
  <Step title="Create a new iOS app in Xcode">
    1. Click *Create New Project*
    2. Select iOS App and click *Next*
    3. Name your project something like “ConvexQuickstart”
    4. Ensure Language is set to Swift and User Interface is SwiftUI
    5. Click *Next*
    
    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/swift_qs_step_1.png" alt="Create new iOS project" width={600} />
    </p>
  </Step>

  <Step title="Configure dependencies">
    1. Click on the top-level ConvexQuickstart app container in the project
      navigator on the left
    2.  Click on ConvexQuickstart under the PROJECT heading
    3.  Click the Package Dependencies tab
    4.  Click the + button (See Screenshot)
    5.  Paste
        ```
        https://github.com/get-convex/convex-swift
        ```
        into the search box and press enter
    6.  When the `convex-swift` package loads, click the *Add Package* button
    7.  In the *Package Products* dialog, select ConvexQuickstart in the 
        *Add to Target* dropdown
    8.  Click the Add Package button

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/swift_qs_step_2.png" alt="Add Convex dependency to package" width={600} />
    </p>

  </Step>
  <br/>
  <Step title="Install the Convex backend">
    Open a terminal and `cd` to the directory for the Xcode project you
    created. Run the following commands to install the Convex client and
    server library.

    ```bash
    npm init -y
    npm install convex
    ```

  </Step>

  <Step title="Start Convex">
    Start a Convex dev deployment. Follow the command line instructions to
    create a new project.

    ```bash
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    Create a new `sampleData.jsonl` file in your Swift project directory with
    these contents

    ```json
    {"text": "Buy groceries", "isCompleted": true}
    {"text": "Go for a swim", "isCompleted": true}
    {"text": "Integrate Convex", "isCompleted": false}
    ```

  </Step>

  <Step title="Add the sample data to a table called `tasks` in your database">
    Open another terminal tab by pressing ⌘+T which should open in your Swift
    project directory and run

    ```bash
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Create a `tasks.ts` file in the `convex/` directory within your Swift
    project with the following contents

    ```tsx
    import { query } from "./_generated/server";

    export const get = query({
      args: {},
      handler: async (ctx) => {
        return await ctx.db.query("tasks").collect();
      },
    });
    ```

  </Step>

  <Step title="Create a Swift struct">
    Back in Xcode, create a `struct` at the bottom of the `ContentView` file to
    match the sample data

    ```swift
    // We're using the name Todo instead of Task to avoid clashing with
    // Swift's builtin Task type.
    struct Todo: Decodable {
      let _id: String
      let text: String
      let isCompleted: Bool
    }
    ```

  </Step>

  <Step title="Connect the app to your backend">
   1. Get the deployment URL of your dev server
      with `cat .env.local | grep CONVEX_URL`
   2. Create a `ConvexClient` instance near the top of the file, just above the
      `ContentView` struct

    ```swift
    import SwiftUI
    import ConvexMobile

    // highlight-next-line
    let convex = ConvexClient(deploymentUrl: "YOUR_CONVEX_URL")

    struct ContentView: View {
    ...
    ```

  </Step>

  <Step title="Create your UI">

    Replace the default `ContentView` with the following code that will
    refresh the list of todo items whenever the backend data changes.

    ```swift
    struct ContentView: View {
      @State private var todos: [Todo] = []

      var body: some View {
        List {
          ForEach(todos, id: \._id) { todo in
            Text(todo.text)
          }
        }.task {
          for await todos: [Todo] in convex.subscribe(to: "tasks:get")
            .replaceError(with: []).values
          {
            self.todos = todos
          }
        }.padding()
      }
    }
    ```

  </Step>

  <Step title="Run the app">
    1. Press ⌘+R or click *Product → Run*
    2. You can also try adding, updating or
    deleting documents in your `tasks` table at `dashboard.convex.dev` - the app
    will update with the changes in real-time.

    <p style={{textAlign: 'center'}}>
      <img src="/screenshots/swift_qs_final.png" alt="App preview" width={400} />
    </p>

  </Step>

</StepByStep>

See the complete [iOS Swift documentation](/client/swift.md).



================================================
FILE: npm-packages/docs/docs/quickstart/tanstack-start.mdx
================================================
---
title: TanStack Start Quickstart
sidebar_label: TanStack Start
description: "Add Convex to a TanStack Start project"
hide_table_of_contents: true
sidebar_position: 200
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/tanstack-start/sampleData.jsonl";
import appRoutesRoot from "!!raw-loader!@site/../private-demos/quickstarts/tanstack-start/src/routes/__root.tsx";
import router from "!!raw-loader!@site/../private-demos/quickstarts/tanstack-start/src/router.tsx";
import index from "!!raw-loader!@site/../private-demos/quickstarts/tanstack-start/src/routes/index.tsx";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/tanstack-start/convex/tasks.ts";

<Admonition type="caution" title="TanStack Start is in Release Candidate">

[TanStack Start](https://tanstack.com/start/latest) is a new React framework
currently in the Release Candidate stage. You can try it today but there might
still be bug or issues.

</Admonition>

To get setup quickly with Convex and TanStack Start run

<p>
  <b>
    <CodeWithCopyButton text="npm create convex@latest -- -t tanstack-start" />
  </b>
</p>

or follow the guide below.

To use Clerk with Convex and TanStack Start, see the
[TanStack Start + Clerk guide](/client/tanstack/tanstack-start/clerk.mdx)

---

Learn how to query data from Convex in a TanStack Start site.

<StepByStep>
  <Step title="Create a TanStack Start site">

Create a TanStack Start app using the `create-start-app` command:

    ```sh
    npx create-start-app@latest
    ```

</Step>
  <Step title="Install the Convex client and server library">
    To get started with Convex install the `convex` package and a few React Query-related packages.

    ```sh
    npm install convex @convex-dev/react-query @tanstack/react-router-with-query @tanstack/react-query
    ```

  </Step>

  <Step title="Update app/routes/__root.tsx">
    Add a `QueryClient` to the router context to make React Query usable anywhere in the TanStack Start site.

    <Snippet
      source={appRoutesRoot}
      title="app/routes/__root.tsx"
      highlightPatterns={[ "createRootRouteWithContext", "QueryClient", "\\}\\>\\(\\)\\(\\{"]}
    />

  </Step>

  <Step title="Update app/router.tsx">
    Replace the file `app/router.tsx` with these contents.

    This creates a `ConvexClient` and a `ConvexQueryClient` and wires in a `ConvexProvider`.

    <Snippet
      source={router}
      title="app/router.tsx"
    />

  </Step>

  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file <JSDialectFileName name="tasks.ts" /> in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasks}
      title="convex/tasks.ts"
    />

  </Step>

  <Step title="Display the data in your app">
    Replace the file `app/routes/index.tsx` with these contents.

    The `useSuspenseQuery` hook renders the API function `api.tasks.get`
    query result on the server initially, then it updates live in the browser.

    <Snippet
      source={index}
      title="app/routes/index.tsx"
      highlightPatterns={[ "useSuspenseQuery" ]}
    />

  </Step>

  <Step title="Start the app">
    Start the app, open [http://localhost:3000](http://localhost:3000) in a browser,
    and see the list of tasks.

    ```sh
    npm run dev
    ```

  </Step>

</StepByStep>

For more see the
[TanStack Start with Convex](/client/tanstack/tanstack-start/index.mdx) client
documentation page.



================================================
FILE: npm-packages/docs/docs/quickstart/vue.mdx
================================================
---
title: Vue Quickstart
sidebar_label: Vue
description: "Add Convex to a Vue project"
hide_table_of_contents: true
sidebar_position: 325
---

import sampleData from "!!raw-loader!@site/../private-demos/quickstarts/vue/sampleData.jsonl";
import main from "!!raw-loader!@site/../private-demos/quickstarts/vue/src/main.ts";
import tasks from "!!raw-loader!@site/../private-demos/quickstarts/vue/convex/tasks.ts";
import App from "!!raw-loader!@site/../private-demos/quickstarts/vue/src/App.vue";

Learn how to query data from Convex in a Vue app.

This quickstart guide uses a [community-maintained](/client/vue.md) Vue client
for Convex.

<StepByStep>
  <Step title="Create a Vue site">
    Create a Vue site using the `npm create vue@latest my-vue-app` command.

    Convex will work with any set of options but to follow this quickstart most closely choose:
    * Yes to "Add TypeScript?"
    * No to everything else

    <br></br>

    ```sh
    npm create vue@latest my-vue-app
    ```

  </Step>

  <Step title="Install the Convex library">
    To get started, install the `convex` package.

    ```sh
    cd my-vue-app && npm install convex convex-vue
    ```

  </Step>

  <Step title="Set up a Convex dev deployment">
    Next, run `npx convex dev`. This
    will prompt you to log in with GitHub,
    create a project, and save your production and deployment URLs.

    It will also create a `convex/` folder for you
    to write your backend API functions in. The `dev` command
    will then continue running to sync your functions
    with your dev deployment in the cloud.


    ```sh
    npx convex dev
    ```

  </Step>

  <Step title="Create sample data for your database">
    In a new terminal window, create a `sampleData.jsonl`
    file with some sample data.

    <Snippet
      source={sampleData}
      title="sampleData.jsonl"
    />

  </Step>

  <Step title="Add the sample data to your database">
    Now that your project is ready, add a `tasks` table
    with the sample data into your Convex database with
    the `import` command.

    ```
    npx convex import --table tasks sampleData.jsonl
    ```

  </Step>

  <Step title="Expose a database query">
    Add a new file `tasks.ts` in the `convex/` folder
    with a query function that loads the data.

    Exporting a query function from this file
    declares an API function named after the file
    and the export name, `api.tasks.get`.

    <Snippet
      source={tasks}
      title="convex/tasks.ts"
    />

  </Step>

  <Step title="Wire up the ConvexProvider">
    In `src/main.ts` set up the Convex client there to make it available on every page of your app.

    <Snippet
      source={main}
      title="src/main.ts"
    />

  </Step>

  <Step title="Display the data in your app">
    In `src/App.vue` use `useQuery` to subscribe your `api.tasks.get`
    API function.

    <Snippet
      source={App}
      title="src/App.vue"
    />

  </Step>

  <Step title="Start the app">
    Start the app, open [http://localhost:5173](http://localhost:5173) in a browser,
    and see the list of tasks.

    ```sh
    npm run dev
    ```

  </Step>

</StepByStep>

See the complete
[Vue npm package documentation](https://www.npmjs.com/package/convex-vue).



================================================
FILE: npm-packages/docs/docs/scheduling/cron-jobs.mdx
================================================
---
title: "Cron Jobs"
sidebar_position: 2
description: "Schedule recurring functions in Convex"
---

import Example from "!!raw-loader!@site/../private-demos/snippets/convex/crons.ts";

Convex allows you to schedule functions to run on a recurring basis. For
example, cron jobs can be used to clean up data at a regular interval, send a
reminder email at the same time every month, or schedule a backup every
Saturday.

**Example:**
[Cron Jobs](https://github.com/get-convex/convex-demos/tree/main/cron-jobs)

## Defining your cron jobs

Cron jobs are defined in a `crons.ts` file in your `convex/` directory and look
like:

<TSAndJSSnippet title="convex/crons.ts" sourceTS={Example} sourceJS={Example} />

The first argument is a unique identifier for the cron job.

The second argument is the schedule at which the function should run, see
[Supported schedules](/scheduling/cron-jobs.mdx#supported-schedules) below.

The third argument is the name of the public function or
[internal function](/functions/internal-functions.mdx), either a
[mutation](/functions/mutation-functions.mdx) or an
[action](/functions/actions.mdx).

## Supported schedules

- [`crons.interval()`](/api/classes/server.Crons#interval) runs a function every
  specified number of `seconds`, `minutes`, or `hours`. The first run occurs
  when the cron job is first deployed to Convex. Unlike traditional crons, this
  option allows you to have seconds-level granularity.
- [`crons.cron()`](/api/classes/server.Crons#cron) the traditional way of
  specifying cron jobs by a string with five fields separated by spaces
  <nobr>(e.g. `"* * * * *"`)</nobr>. Times in cron syntax are in the UTC
  timezone. [Crontab Guru](https://crontab.guru/) is a helpful resource for
  understanding and creating schedules in this format.
- [`crons.hourly()`](/api/classes/server.Crons#cron),
  [`crons.daily()`](/api/classes/server.Crons#daily),
  [`crons.weekly()`](/api/classes/server.Crons#weekly),
  [`crons.monthly()`](/api/classes/server.Crons#monthly) provide an alternative
  syntax for common cron schedules with explicitly named arguments.

## Viewing your cron jobs

You can view all your cron jobs in the
[Convex dashboard cron jobs view](/dashboard/deployments/schedules.md#cron-jobs-ui).
You can view added, updated, and deleted cron jobs in the logs and history view.
Results of previously executed runs of the cron jobs are also available in the
logs view.

## Error handling

Mutations and actions have the same guarantees that are described in
[Error handling](/scheduling/scheduled-functions.mdx#error-handling) for
scheduled functions.

At most one run of each cron job can be executing at any moment. If the function
scheduled by the cron job takes too long to run, following runs of the cron job
may be skipped to avoid execution from falling behind. Skipping a scheduled run
of a cron job due to the previous run still executing logs a message visible in
the logs view of the dashboard.



================================================
FILE: npm-packages/docs/docs/scheduling/scheduled-functions.mdx
================================================
---
title: Scheduled Functions
sidebar_position: 1
description: "Schedule functions to run in the future"
---

import Example from "!!raw-loader!@site/../private-demos/snippets/convex/messages.ts";

Convex allows you to schedule functions to run in the future. This allows you to
build powerful durable workflows without the need to set up and maintain queues
or other infrastructure.

Scheduled functions are stored in the database. This means you can schedule
functions minutes, days, and even months in the future. Scheduling is resilient
against unexpected downtime or system restarts.

**Example:**
[Scheduling](https://github.com/get-convex/convex-demos/tree/main/scheduling)

## Scheduling functions

You can schedule public functions and
[internal functions](/functions/internal-functions.mdx) from mutations and
actions via the [scheduler](/api/interfaces/server.Scheduler) provided in the
respective function context.

- [runAfter](/api/interfaces/server.Scheduler#runafter) schedules a function to
  run after a delay (measured in milliseconds).
- [runAt](/api/interfaces/server.Scheduler#runat) schedules a function run at a
  date or timestamp (measured in milliseconds elapsed since the epoch).

The rest of the arguments are the path to the function and its arguments,
similar to invoking a function from the client. For example, here is how to send
a message that self-destructs in five seconds.

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={Example}
  sourceJS={Example}
  snippet="scheduling-runAfter"
  highlightPatterns={["scheduler", "runAfter"]}
/>

A single function can schedule up to 1000 functions with total argument size of
8MB.

### Scheduling from mutations

Scheduling functions from
[mutations](/functions/mutation-functions.mdx#transactions) is atomic with the
rest of the mutation. This means that if the mutation succeeds, the scheduled
function is guaranteed to be scheduled. On the other hand, if the mutations
fails, no function will be scheduled, even if the function fails after the
scheduling call.

### Scheduling from actions

Unlike mutations, [actions](/functions/actions.mdx) don't execute as a single
database transaction and can have side effects. Thus, scheduling from actions
does not depend on the outcome of the function. This means that an action might
succeed to schedule some functions and later fail due to transient error or a
timeout. The scheduled functions will still be executed.

### Scheduling immediately

Using `runAfter()` with delay set to 0 is used to immediately add a function to
the event queue. This usage may be familiar to you if you're used to calling
`setTimeout(fn, 0)`.

As noted above, actions are not atomic and are meant to cause side effects.
Scheduling immediately becomes useful when you specifically want to trigger an
action from a mutation that is conditional on the mutation succeeding.
[This post](https://stack.convex.dev/pinecone-and-embeddings#kick-off-a-background-action)
goes over a direct example of this in action, where the application depends on
an external service to fill in information to the database.

## Retrieving scheduled function status

Every scheduled function is reflected as a document in the
`"_scheduled_functions"` system table. `runAfter()` and `runAt()` return the id
of scheduled function. You can read data from system tables using the
`db.system.get` and `db.system.query` methods, which work the same as the
standard `db.get` and `db.query` methods.

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={Example}
  sourceJS={Example}
  snippet="scheduling-status"
  highlightPatterns={["system"]}
/>

This is an example of the returned document:

```json
{
  "_creationTime": 1699931054642.111,
  "_id": "3ep33196167235462543626ss0scq09aj4gqn9kdxrdr",
  "args": [{}],
  "completedTime": 1699931054690.366,
  "name": "messages.js:destruct",
  "scheduledTime": 1699931054657,
  "state": { "kind": "success" }
}
```

The returned document has the following fields:

- `name`: the path of the scheduled function
- `args`: the arguments passed to the scheduled function
- `scheduledTime`: the timestamp of when the function is scheduled to run
  (measured in milliseconds elapsed since the epoch)
- `completedTime`: the timestamp of when the function finished running, if it
  has completed (measured in milliseconds elapsed since the epoch)
- `state`: the status of the scheduled function. Here are the possible states a
  scheduled function can be in:
  - `Pending`: the function has not been started yet
  - `InProgress`: the function has started running is not completed yet (only
    applies to actions)
  - `Success`: the function finished running successfully with no errors
  - `Failed`: the function hit an error while running, which can either be a
    user error or an internal server error
  - `Canceled`: the function was canceled via the dashboard,
    `ctx.scheduler.cancel`, or recursively by a parent scheduled function that
    was canceled while in progress

Scheduled function results are available for 7 days after they have completed.

## Canceling scheduled functions

You can cancel a previously scheduled function with
[`cancel`](/api/interfaces/server.Scheduler#cancel) via the
[scheduler](/api/interfaces/server.Scheduler) provided in the respective
function context.

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={Example}
  sourceJS={Example}
  snippet="scheduling-cancel"
  highlightPatterns={["scheduler.cancel"]}
/>

What `cancel` does depends on the state of the scheduled function:

- If it hasn't started running, it won't run.
- If it already started, it will continue to run, but any functions it schedules
  will not run.

## Debugging

You can view logs from previously executed scheduled functions in the Convex
dashboard [Logs view](/dashboard/deployments/logs.md). You can view and cancel
yet to be executed functions in the
[Functions view](/dashboard/deployments/functions.md).

## Error handling

Once scheduled, mutations are guaranteed to be executed exactly once. Convex
will automatically retry any internal Convex errors, and only fail on developer
errors. See [Error Handling](/functions/error-handling/error-handling.mdx) for
more details on different error types.

Since actions may have side effects, they are not automatically retried by
Convex. Thus, actions will be executed at most once, and permanently fail if
there are transient errors while executing them. Developers can retry those
manually by scheduling a mutation that checks if the desired outcome has been
achieved and if not schedule the action again.

## Auth

The auth is not propagated from the scheduling to the scheduled function. If you
want to authenticate or check authorization, you'll have to pass the requisite
user information in as a parameter.



================================================
FILE: npm-packages/docs/docs/search/text-search.mdx
================================================
---
title: "Full Text Search"
sidebar_position: 110
description: "Run search queries over your Convex documents"
slug: "text-search"
---

Full text search allows you to find Convex documents that approximately match a
search query.

Unlike normal
[document queries](/database/reading-data/reading-data.mdx#querying-documents),
search queries look _within_ a string field to find the keywords. Search queries
are useful for building features like searching for messages that contain
certain words.

Search queries are automatically reactive, consistent, transactional, and work
seamlessly with pagination. They even include new documents created with a
mutation!

**Example:**
[Search App](https://github.com/get-convex/convex-demos/tree/main/search)

To use full text search you need to:

1. Define a search index.
2. Run a search query.

Search indexes are built and queried using Convex's multi-segment search
algorithm on top of [Tantivy](https://github.com/quickwit-oss/tantivy), a
powerful, open-source, full-text search library written in Rust.

## Defining search indexes

Like [database indexes](/database/reading-data/indexes/indexes.md), search
indexes are a data structure that is built in advance to enable efficient
querying. Search indexes are defined as part of your Convex
[schema](/database/schemas.mdx).

Every search index definition consists of:

1. A name.
   - Must be unique per table.
2. A `searchField`
   - This is the field which will be indexed for full text search.
   - It must be of type `string`.
3. [Optional] A list of `filterField`s
   - These are additional fields that are indexed for fast equality filtering
     within your search index.
4. [Optional] A boolean `staged` flag
   - If set to `true`, the index will be backfilled asynchronously from the
     deploy similar to
     [staged database indexes](/database/reading-data/indexes#staged-indexes).
     This is useful for large tables where the index backfill time is
     significant. Defaults to `false`.

To add a search index onto a table, use the
[`searchIndex`](/api/classes/server.TableDefinition#searchindex) method on your
table's schema. For example, if you want an index which can search for messages
matching a keyword in a channel, your schema could look like:

```ts noDialect title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  messages: defineTable({
    body: v.string(),
    channel: v.string(),
  }).searchIndex("search_body", {
    searchField: "body",
    filterFields: ["channel"],
    staged: false,
  }),
});
```

You can specify search and filter fields on nested documents by using a
dot-separated path like `properties.name`.

## Running search queries

A query for "10 messages in channel '#general' that best match the query 'hello
hi' in their body" would look like:

```js
const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) =>
    q.search("body", "hello hi").eq("channel", "#general"),
  )
  .take(10);
```

This is just a normal [database read](/database/reading-data/reading-data.mdx)
that begins by querying the search index!

The
[`.withSearchIndex`](/api/interfaces/server.QueryInitializer#withsearchindex)
method defines which search index to query and how Convex will use that search
index to select documents. The first argument is the name of the index and the
second is a _search filter expression_. A search filter expression is a
description of which documents Convex should consider when running the query.

A search filter expression is always a chained list of:

1. 1 search expression against the index's search field defined with
   [`.search`](/api/interfaces/server.SearchFilterBuilder#search).
2. 0 or more equality expressions against the index's filter fields defined with
   [`.eq`](/api/interfaces/server.SearchFilterFinalizer#eq).

### Search expressions

Search expressions are issued against a search index, filtering and ranking
documents by their relevance to the search expression's query. Internally,
Convex will break up the query into separate words (called _terms_) and
approximately rank documents matching these terms.

In the example above, the expression `search("body", "hello hi")` would
internally be split into `"hi"` and `"hello"` and matched against words in your
document (ignoring case and punctuation).

The behavior of search incorporates [prefix matching rules](#search-behavior).

### Equality expressions

Unlike search expressions, equality expressions will filter to only documents
that have an exact match in the given field. In the example above,
`eq("channel", "#general")` will only match documents that have exactly
`"#general"` in their `channel` field.

Equality expressions support fields of any type (not just text).

To filter to documents that are missing a field, use
`q.eq("fieldName", undefined)`.

### Other filtering

Because search queries are normal database queries, you can also
[filter results](/database/reading-data/filters.mdx) using the
[`.filter` method](/api/interfaces/server.Query#filter)!

Here's a query for "messages containing 'hi' sent in the last 10 minutes":

```js
const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) => q.search("body", "hi"))
  .filter((q) => q.gt(q.field("_creationTime", Date.now() - 10 * 60000)))
  .take(10);
```

**For performance, always put as many of your filters as possible into
`.withSearchIndex`.**

Every search query is executed by:

1. First, querying the search index using the search filter expression in
   `withSearchIndex`.
2. Then, filtering the results one-by-one using any additional `filter`
   expressions.

Having a very specific search filter expression will make your query faster and
less likely to hit Convex's limits because Convex will use the search index to
efficiently cut down on the number of results to consider.

### Retrieving results and paginating

Just like ordinary database queries, you can
[retrieve the results](/database/reading-data/reading-data.mdx#retrieving-results)
using [`.collect()`](/api/interfaces/server.Query#collect),
[`.take(n)`](/api/interfaces/server.Query#take),
[`.first()`](/api/interfaces/server.Query#first), and
[`.unique()`](/api/interfaces/server.Query#unique).

Additionally, search results can be [paginated](/database/pagination.mdx) using
[`.paginate(paginationOpts)`](/api/interfaces/server.OrderedQuery#paginate).

Note that `collect()` will throw an exception if it attempts to collect more
than the limit of 1024 documents. It is often better to pick a smaller limit and
use `take(n)` or paginate the results.

### Ordering

Search queries always return results in [relevance order](#relevance-order)
based on how well the document matches the search query. Different ordering of
results are not supported.

## Search Behavior

### Typeahead Search

Convex full-text search is designed to power as-you-type search experiences. In
your search queries, the final search term has _prefix search_ enabled, matching
any term that is a prefix of the original term. For example, the expression
`search("body", "r")` would match the documents:

- `"rabbit"`
- `"send request"`

Fuzzy search matches are deprecated. After January 15, 2025, search results will
not include `"snake"` for a typo like `"stake"`.

### Relevance order

**Relevance order is subject to change.** The relevance of search results and
the exact rules Convex applies is subject to change to improve the quality of
search results.

Search queries return results in relevance order. Internally, Convex ranks the
relevance of a document based on a combination of its
[BM25 score](https://en.wikipedia.org/wiki/Okapi_BM25) and several other
criteria such as the proximity of matches, the number of exact matches, and
more. The BM25 score takes into account:

- How many words in the search query appear in the field?
- How many times do they appear?
- How long is the text field?

If multiple documents have the same score, the newest documents are returned
first.

## Limits

Search indexes work best with English or other Latin-script languages. Text is
tokenized using Tantivy's
[`SimpleTokenizer`](https://docs.rs/tantivy/latest/tantivy/tokenizer/struct.SimpleTokenizer.html),
which splits on whitespace and punctuation. We also limit terms to 32 characters
in length and lowercase them.

Search indexes must have:

- Exactly 1 search field.
- Up to 16 filter fields.

Search indexes count against the
[limit of 32 indexes per table](/database/reading-data/indexes/indexes.md#limits).

Search queries can have:

- Up to 16 terms (words) in the search expression.
- Up to 8 filter expressions.

Additionally, search queries can scan up to 1024 results from the search index.

The source of truth for these limits is our
[source code](https://github.com/get-convex/convex-backend/blob/main/crates/search/src/constants.rs).

For information on other limits, see [here](/production/state/limits.mdx).



================================================
FILE: npm-packages/docs/docs/search/vector-search.mdx
================================================
---
title: "Vector Search"
sidebar_position: 100
description: "Run vector search queries on embeddings"
slug: "vector-search"
---

import Schema from "!!raw-loader!@site/../demos/vector-search/convex/schema.ts";
import VectorSearchSnippets from "!!raw-loader!@site/../private-demos/snippets/convex/vectorSearch.ts";
import Foods from "!!raw-loader!@site/../private-demos/snippets/convex/foods.ts";
import VectorSearchSnippets2 from "!!raw-loader!@site/../private-demos/snippets/convex/vectorSearch2.ts";
import Movies from "!!raw-loader!@site/../demos/vector-search/convex/movies.ts";

Vector search allows you to find Convex documents similar to a provided vector.
Typically, vectors will be embeddings which are numerical representations of
text, images, or audio.

Embeddings and vector search enable you to provide useful context to LLMs for AI
powered applications, recommendations for similar content and more.

Vector search is consistent and fully up-to-date. You can write a vector and
immediately read it from a vector search. Unlike
[full text search](/search.mdx), however, vector search is only available in
[Convex actions](/functions/actions.mdx).

**Example:**
[Vector Search App](https://github.com/get-convex/convex-demos/tree/main/vector-search)

To use vector search you need to:

1. Define a vector index.
1. Run a vector search from within an [action](/functions/actions.mdx).

## Defining vector indexes

Like [database indexes](/database/reading-data/indexes/indexes.md), vector
indexes are a data structure that is built in advance to enable efficient
querying. Vector indexes are defined as part of your Convex
[schema](/database/schemas.mdx).

To add a vector index onto a table, use the
[`vectorIndex`](/api/classes/server.TableDefinition#vectorindex) method on your
table's schema. Every vector index has a unique name and a definition with:

1. `vectorField` string
   - The name of the field indexed for vector search.
2. `dimensions` number
   - The fixed size of the vectors index. If you're using embeddings, this
     dimension should match the size of your embeddings (e.g. `1536` for
     OpenAI).
3. [Optional] `filterFields` array
   - The names of additional fields that are indexed for fast filtering within
     your vector index.
4. [Optional] `staged` boolean
   - If set to `true`, the index will be backfilled asynchronously from the
     deploy similar to
     [staged database indexes](/database/reading-data/indexes#staged-indexes).
     This is useful for large tables where the index backfill time is
     significant. Defaults to `false`.

For example, if you want an index that can search for similar foods within a
given cuisine, your table definition could look like:

<Snippet
  source={Schema}
  title="convex/schema.ts"
  snippet="schemaOneTable"
  highlightPatterns={["vectorIndex"]}
/>

You can specify vector and filter fields on nested documents by using a
dot-separated path like `properties.name`.

## Running vector searches

Unlike database queries or full text search, vector searches can only be
performed in a [Convex action](/functions/actions.mdx).

They generally involve three steps:

1. Generate a vector from provided input (e.g. using OpenAI)
1. Use
   [`ctx.vectorSearch`](/api/interfaces/server.GenericActionCtx#vectorsearch) to
   fetch the IDs of similar documents
1. Load the desired information for the documents

Here's an example of the first two steps for searching for similar French foods
based on a description:

<TSAndJSSnippet
  sourceTS={VectorSearchSnippets}
  sourceJS={VectorSearchSnippets}
  title="convex/foods.ts"
  snippet="vectorSearchQuery"
  highlightPatterns={["vectorSearch"]}
/>

An example of the first step can be found
[here](https://github.com/get-convex/convex-demos/blob/main/vector-search/convex/foods.ts#L18)
in the vector search demo app.

Focusing on the second step, the `vectorSearch` API takes in the table name, the
index name, and finally a
[`VectorSearchQuery`](/api/interfaces/server.VectorSearchQuery) object
describing the search. This object has the following fields:

1. `vector` array
   - An array of numbers (e.g. embedding) to use in the search.
   - The search will return the document IDs of the documents with the most
     similar stored vectors.
   - It must have the same length as the `dimensions` of the index.
2. [Optional] `limit` number
   - The number of results to get back. If specified, this value must be between
     1 and 256.
3. [Optional] `filter`
   - An expression that restricts the set of results based on the `filterFields`
     in the `vectorIndex` in your schema. See
     [Filter expressions](#filter-expressions) for details.

It returns an `Array` of objects containing exactly two fields:

1. `_id`
   - The [Document ID](https://docs.convex.dev/database/document-ids) for the
     matching document in the table
2. `_score`
   - An indicator of how similar the result is to the vector you were searching
     for, ranging from -1 (least similar) to 1 (most similar)

Neither the underlying document nor the vector are included in `results`, so
once you have the list of results, you will want to load the desired information
about the results.

There are a few strategies for loading this information documented in the
[Advanced Patterns](#advanced-patterns) section.

For now, let's load the documents and return them from the action. To do so,
we'll pass the list of results to a Convex query and run it inside of our
action, returning the result:

<TSAndJSSnippet
  sourceTS={Foods}
  sourceJS={Foods}
  title="convex/foods.ts"
  snippet="fetchResults"
/>

<TSAndJSSnippet
  sourceTS={VectorSearchSnippets2}
  sourceJS={VectorSearchSnippets2}
  title="convex/foods.ts"
  snippet="fetchResults"
/>

### Filter expressions

As mentioned above, vector searches support efficiently filtering results by
additional fields on your document using either exact equality on a single
field, or an `OR` of expressions.

For example, here's a filter for foods with cuisine exactly equal to "French":

<Snippet source={VectorSearchSnippets} snippet="filterSingleValue" />

You can also filter documents by a single field that contains several different
values using an `or` expression. Here's a filter for French or Indonesian
dishes:

<Snippet source={VectorSearchSnippets} snippet="filterMultipleValues" />

For indexes with multiple filter fields, you can also use `.or()` filters on
different fields. Here's a filter for dishes whose cuisine is French or whose
main ingredient is butter:

<Snippet source={VectorSearchSnippets} snippet="filterMultipleFields" />

**Both `cuisine` and `mainIngredient` would need to be included in the
`filterFields` in the `.vectorIndex` definition.**

### Other filtering

Results can be filtered based on how similar they are to the provided vector
using the `_score` field in your action:

```ts
const results = await ctx.vectorSearch("foods", "by_embedding", {
  vector: embedding,
});
const filteredResults = results.filter((result) => result._score >= 0.9);
```

Additional filtering can always be done by passing the vector search results to
a query or mutation function that loads the documents and performs filtering
using any of the fields on the document.

**For performance, always put as many of your filters as possible into
`.vectorSearch`.**

### Ordering

Vector queries always return results in relevance order.

Currently Convex searches vectors using an
[approximate nearest neighbor search](https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximate_nearest_neighbor)
based on [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity).
Support for more similarity metrics
[will come in the future](#future-development).

If multiple documents have the same score, ties are broken by the document ID.

## Advanced patterns

### Using a separate table to store vectors

There are two main options for setting up a vector index:

1. Storing vectors in the same table as other metadata
1. Storing vectors in a separate table, with a reference

The examples above show the first option, which is simpler and works well for
reading small amounts of documents. The second option is more complex, but
better supports reading or returning large amounts of documents.

Since vectors are typically large and not useful beyond performing vector
searches, it's nice to avoid loading them from the database when reading other
data (e.g. `db.get()`) or returning them from functions by storing them in a
separate table.

A table definition for movies, and a vector index supporting search for similar
movies filtering by genre would look like this:

<Snippet source={Schema} title="convex/schema.ts" snippet="schemaTwoTables" />

Generating an embedding and running a vector search are the same as using a
single table. Loading the relevant documents given the vector search result is
different since we have an ID for `movieEmbeddings` but want to load a `movies`
document. We can do this using the `by_embedding` database index on the `movies`
table:

<TSAndJSSnippet
  sourceTS={VectorSearchSnippets}
  sourceJS={VectorSearchSnippets}
  title="convex/movies.ts"
  snippet="fetchMovies"
  highlightPatterns={["withIndex"]}
/>

### Fetching results and adding new documents

Returning information from a vector search involves an action (since vector
search is only available in actions) and a query or mutation to load the data.

The example above used a query to load data and return it from an action. Since
this is an action, the data returned is not reactive. An alternative would be to
return the results of the vector search in the action, and have a separate query
that reactively loads the data. The search results will not update reactively,
but the data about each result would be reactive.

The
[Vector Search Demo App](https://github.com/get-convex/convex-demos/tree/main/vector-search)
uses this strategy to show similar movies with a reactive "Votes" count.

## Limits

Convex supports millions of vectors today. This is an ongoing project and we
will continue to scale this offering out with the rest of Convex.

Vector indexes must have:

- Exactly 1 vector index field.
  - The field must be of type `v.array(v.float64())` (or a union in which one of
    the possible types is `v.array(v.float64())`)
- Exactly 1 dimension field with a value between 2 and 4096.
- Up to 16 filter fields.

Vector indexes count towards the
[limit of 32 indexes per table](/database/reading-data/indexes/indexes.md#limits).
In addition you can have up to 4 vector indexes per table.

Vector searches can have:

- Exactly 1 vector to search by in the `vector` field
- Up to 64 filter expressions
- Up to 256 requested results (defaulting to 10).

If your action performs a vector search then passes the results to a query or
mutation function, you may find that one or more results from the vector search
have been deleted or mutated. Because vector search is only available in
actions, you cannot perform additional transactional queries or mutations based
on the results. If this is important for your use case, please
[let us know on Discord](https://convex.dev/community)!

Only documents that contain a vector of the size and in the field specified by a
vector index will be included in the index and returned by the vector search.

For information on limits, see [here](/production/state/limits.mdx).

## Future development

We're always open to customer feedback and requests. Some ideas we've considered
for improving vector search in Convex include:

- More sophisticated filters and filter syntax
- Filtering by score in the `vectorSearch` API
- Better support for generating embeddings

If any of these features is important for your app,
[let us know on Discord](https://convex.dev/community)!



================================================
FILE: npm-packages/docs/docs/testing/ci.mdx
================================================
---
title: Continuous Integration
sidebar_label: CI
sidebar_position: 300
description: "Set up continuous integration testing for Convex applications"
---

Continuous integration allows your team to move fast by combining changes from
all team members and automatically testing them on a remote machine.

## Testing in GitHub Actions

It's easy if you're using [GitHub](https://docs.github.com/en/actions) to set up
[CI](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration)
workflow for running your test suite:

```yaml title=".github/workflows/test.yml"
name: Run Tests

on: [pull_request, push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: npm ci
      - run: npm run test
```

After you commit and push this file to your repository, GitHub will run
`npm run test` every time you create a pull request or push a new commit.

{/* todo: testing against preview deployments */}



================================================
FILE: npm-packages/docs/docs/testing/convex-backend.mdx
================================================
---
title: Testing Local Backend
sidebar_label: Local Backend
sidebar_position: 200
description: "Test functions using the local open-source Convex backend"
---

Alternatively to [`convex-test`](/testing/convex-test.mdx) you can test your
functions using the
[open-source version of the Convex backend](https://github.com/get-convex/convex-backend).

## Getting Started

Follow [this guide](https://stack.convex.dev/testing-with-local-oss-backend) for
the instructions.

Compared to `convex-test`, which uses a JS mock of the backend, running your
tests against the real backend has these advantages:

- Your tests will run against the same code as your Convex production (as long
  you keep the local backend up-to-date).
- Limits on argument, data, query sizes are enforced.
- You can bootstrap a large test dataset from a data import.
- You can test your client code in combination with your backend logic.

## Limitations

Note that testing against the local backend also has some drawbacks:

- It requires setting up the local backend, which is more involved.
- No control over time and any scheduled functions will run as scheduled.
- Crons will also run unless disabled via
  [`IS_TEST`](https://stack.convex.dev/testing-with-local-oss-backend#setting-up-a-local-backend).
- No way to mock `fetch` calls.
- No way to mock dependencies or parts of the codebase.
- No way to control randomness (tests may not be deterministic).
- No way to set environment variable values from within tests.

To test your functions in JS with a mocked Convex backend, check out
[convex-test](/testing/convex-test.mdx).

## CI

See [Continuous Integration](/testing/ci.mdx) to run your tests on a shared
remote machine.



================================================
FILE: npm-packages/docs/docs/testing/convex-test.mdx
================================================
---
title: convex-test
sidebar_label: convex-test
sidebar_position: 100
description: "Mock Convex backend for fast automated testing of functions"
---

import Demo from "!!raw-loader!@site/../demos/convex-test/convex/posts.test.ts";
import SchedulingDemo from "!!raw-loader!@site/../demos/convex-test/convex/scheduling.test.ts";
import ChainedSchedulingDemo from "!!raw-loader!@site/../demos/convex-test/convex/chainedScheduling.test.ts";
import AuthDemo from "!!raw-loader!@site/../demos/convex-test/convex/auth.test.ts";
import MockingFetchDemo from "!!raw-loader!@site/../demos/convex-test/convex/mockingFetch.test.ts";
import ErrorDemo from "!!raw-loader!@site/../demos/convex-test/convex/error.test.ts";
import HttpDemo from "!!raw-loader!@site/../demos/convex-test/convex/http.test.ts";
import RunDemo from "!!raw-loader!@site/../demos/convex-test/convex/run.test.ts";

The [`convex-test`](https://www.npmjs.com/package/convex-test) library provides
a mock implementation of the Convex backend in JavaScript. It enables fast
automated testing of the logic in your [functions](/functions.mdx).

## Example

<TSAndJSSnippet
  title="convex/posts.test.ts"
  sourceTS={Demo}
  sourceJS={Demo}
  highlightPatterns={["t.query", "t.mutation", "convexTest(schema)"]}
/>

You can see more examples in the
[test suite](https://github.com/get-convex/convex-test/tree/main/convex) of the
convex-test library.

## Get started

<StepByStep>

  <Step title="Install test dependencies">
    Install [Vitest](https://vitest.dev/) and the [`convex-test`](https://www.npmjs.com/package/convex-test) library.

    ```sh
    npm install --save-dev convex-test vitest @edge-runtime/vm
    ```

  </Step>

  <Step title="Setup NPM scripts">

    Add these scripts to your `package.json`

    ```json title="package.json"
    "scripts": {
      "test": "vitest",
      "test:once": "vitest run",
      "test:debug": "vitest --inspect-brk --no-file-parallelism",
      "test:coverage": "vitest run --coverage --coverage.reporter=text",
    }
    ```

  </Step>

  <Step title="Configure Vitest">

    Add <JSDialectFileName name="vitest.config.ts" /> file to configure the test
    environment to better match the Convex runtime, and to inline the test library
    for better dependency tracking.

    <Details summary={<>If your Convex functions are in a directory other than <code>convex</code></>}>
      If your project has a
      [different name or location configured](/production/project-configuration.mdx#changing-the-convex-folder-name-or-location)
      for the `convex/` folder in `convex.json`, you need to call
      [`import.meta.glob`](https://vitejs.dev/guide/features#glob-import) and pass the
      result as the second argument to `convexTest`.

      The argument to `import.meta.glob` must be a glob pattern matching all the files
      containing your Convex functions. The paths are relative to the test file in
      which `import.meta.glob` is called. It's best to do this in one place in your
      custom functions folder:

      ```ts title="src/convex/test.setup.ts"
      /// <reference types="vite/client" />
      export const modules = import.meta.glob(
        "./**/!(*.*.*)*.*s"
      );
      ```

      This example glob pattern includes all files with a single extension ending in
      `s` (like `js` or `ts`) in the `src/convex` folder and any of its children.

      Use the result in your tests:

      ```ts title="src/convex/messages.test.ts"
      import { convexTest } from "convex-test";
      import { test } from "vitest";
      import schema from "./schema";
      import { modules } from "./test.setup";

      test("some behavior", async () => {
        const t = convexTest(schema, modules);
        // use `t`...
      });
      ```
    </Details>

    <Details summary="Set up multiple test environments (e.g. Convex + frontend)">
      If you want to use Vitest to test both your Convex functions and your React
      frontend, you might want to use multiple Vitest environments depending on the
      test file location via
      [environmentMatchGlobs](https://vitest.dev/config/#environmentmatchglobs):

      ```ts title="vitest.config.ts"
      import { defineConfig } from "vitest/config";

      export default defineConfig({
        test: {
          environmentMatchGlobs: [
            // all tests in convex/ will run in edge-runtime
            ["convex/**", "edge-runtime"],
            // all other tests use jsdom
            ["**", "jsdom"],
          ],
          server: { deps: { inline: ["convex-test"] } },
        },
      });
      ```
    </Details>

    ```ts title="vitest.config.ts"
    import { defineConfig } from "vitest/config";

    export default defineConfig({
      test: {
        environment: "edge-runtime",
        server: { deps: { inline: ["convex-test"] } },
      },
    });
    ```

  </Step>

  <Step title="Add a test file">

    In your `convex` folder add a file ending in <JSDialectFileName name=".test.ts" />

    The example test calls the `api.messages.send` mutation twice
    and then asserts that the `api.messages.list` query returns
    the expected results.

    ```ts title="convex/messages.test.ts"
    import { convexTest } from "convex-test";
    import { expect, test } from "vitest";
    import { api } from "./_generated/api";
    import schema from "./schema";

    test("sending messages", async () => {
      const t = convexTest(schema);
      await t.mutation(api.messages.send, { body: "Hi!", author: "Sarah" });
      await t.mutation(api.messages.send, { body: "Hey!", author: "Tom" });
      const messages = await t.query(api.messages.list);
      expect(messages).toMatchObject([
        { body: "Hi!", author: "Sarah" },
        { body: "Hey!", author: "Tom" }
      ]);
    });
    ```

  </Step>

  <Step title="Run tests">

    Start the tests with `npm run test`. When you change the test file or your
    functions the tests will rerun automatically.

    ```sh
    npm run test
    ```

  </Step>

</StepByStep>

If you're not familiar with Vitest, read the
[Vitest Getting Started docs](https://vitest.dev/guide) first.

## Using convex-test

### Initialize `convexTest`

The library exports a `convexTest` function which should be called at the start
of each of your tests. The function returns an object which is by convention
stored in the `t` variable and which provides methods for exercising your Convex
functions.

If your project uses a [schema](/database/schemas.mdx) you should pass it to the
`convexTest` function:

```ts title="convex/myFunctions.test.ts"
import { convexTest } from "convex-test";
import { test } from "vitest";
import schema from "./schema";

test("some behavior", async () => {
  const t = convexTest(schema);
  // use `t`...
});
```

Passing in the schema is required for the tests to correctly implement schema
validation and for correct typing of
[`t.run`](#setting-up-and-inspecting-data-and-storage-with-trun).

If you don't have a schema, call `convexTest()` with no argument.

### Call functions

Your test can call public and internal Convex [functions](/functions.mdx) in
your project:

```ts title="convex/myFunctions.test.ts"
import { convexTest } from "convex-test";
import { test } from "vitest";
import { api, internal } from "./_generated/api";

test("functions", async () => {
  const t = convexTest();
  const x = await t.query(api.myFunctions.myQuery, { a: 1, b: 2 });
  const y = await t.query(internal.myFunctions.internalQuery, { a: 1, b: 2 });
  const z = await t.mutation(api.myFunctions.mutateSomething, { a: 1, b: 2 });
  const w = await t.mutation(internal.myFunctions.mutateSomething, { a: 1 });
  const u = await t.action(api.myFunctions.doSomething, { a: 1, b: 2 });
  const v = await t.action(internal.myFunctions.internalAction, { a: 1, b: 2 });
});
```

### Modify data outside of functions

Sometimes you might want to directly [write](/database/writing-data.mdx) to the
mock database or [file storage](/file-storage.mdx) from your test, without
needing a declared function in your project. You can use the `t.run` method
which takes a handler that is given a `ctx` that allows reading from and writing
to the mock backend:

<TSAndJSSnippet
  title="convex/tasks.test.ts"
  sourceTS={RunDemo}
  sourceJS={RunDemo}
  highlightPatterns={["t.run"]}
/>

### HTTP actions

Your test can call [HTTP actions](/functions/http-actions.mdx) registered by
your router:

<TSAndJSSnippet
  title="convex/http.test.ts"
  sourceTS={HttpDemo}
  sourceJS={HttpDemo}
  highlightPatterns={["t.fetch"]}
/>

Mocking the global `fetch` function doesn't affect `t.fetch`, but you can use
`t.fetch` in a `fetch` mock to route to your HTTP actions.

### Scheduled functions

One advantage of using a mock implementation running purely in JavaScript is
that you can control time in the Vitest test environment. To test
implementations relying on
[scheduled functions](/scheduling/scheduled-functions.mdx) use
[Vitest's fake timers](https://vitest.dev/guide/mocking.html#timers) in
combination with `t.finishInProgressScheduledFunctions`:

<TSAndJSSnippet
  title="convex/scheduling.test.ts"
  sourceTS={SchedulingDemo}
  sourceJS={SchedulingDemo}
  highlightPatterns={[]}
/>

If you have a chain of several scheduled functions, for example a mutation that
schedules an action that schedules another action, you can use
`t.finishAllScheduledFunctions` to wait for all scheduled functions, including
recursively scheduled functions, to finish:

<TSAndJSSnippet
  title="convex/chainedScheduling.test.ts"
  sourceTS={ChainedSchedulingDemo}
  sourceJS={ChainedSchedulingDemo}
  highlightPatterns={["finishAllScheduledFunctions"]}
/>

Check out more examples in
[this file](https://github.com/get-convex/convex-test/blob/main/convex/scheduler.test.ts).

### Authentication

To test functions which depend on the current [authenticated](/auth.mdx) user
identity you can create a version of the `t` accessor with given
[user identity attributes](/api/interfaces/server.UserIdentity). If you don't
provide them, `issuer`, `subject` and `tokenIdentifier` will be generated
automatically:

<TSAndJSSnippet
  title="convex/tasks.test.ts"
  sourceTS={AuthDemo}
  sourceJS={AuthDemo}
  highlightPatterns={["withIdentity"]}
/>

## Vitest tips

### Asserting results

See Vitest's [Expect](https://vitest.dev/api/expect.html) reference.

[`toMatchObject()`](https://vitest.dev/api/expect.html#tomatchobject) is
particularly helpful when asserting the shape of results without needing to list
every object field.

### Asserting errors

To assert that a function throws, use
[`.rejects.toThrowError()`](https://vitest.dev/api/expect.html#tothrowerror):

<TSAndJSSnippet
  title="convex/messages.test.ts"
  sourceTS={ErrorDemo}
  sourceJS={ErrorDemo}
  highlightPatterns={["toThrowError"]}
/>

### Mocking `fetch` calls

You can use Vitest's
[vi.stubGlobal](https://vitest.dev/guide/mocking.html#globals) method:

<TSAndJSSnippet
  title="convex/ai.test.ts"
  sourceTS={MockingFetchDemo}
  sourceJS={MockingFetchDemo}
  highlightPatterns={["stubGlobal"]}
/>

### Measuring test coverage

You can get a printout of the code coverage provided by your tests. Besides
answering the question "how much of my code is covered by tests" it is also
helpful to check that your test is actually exercising the code that you want it
to exercise.

Run <CodeWithCopyButton text="npm run test:coverage" />. It will ask you to
install a required dependency the first time you run it.

<p style={{ textAlign: "center" }}>
  <img
    src="/screenshots/testing_coverage.png"
    alt="example coverage printout"
    width={700}
  />
</p>

### Debugging tests

You can attach a debugger to the running tests. Read the Vitest
[Debugging docs](https://vitest.dev/guide/debugging.html) and then use

<CodeWithCopyButton text="npm run test:debug" />.

## Limitations

Since `convex-test` is only a mock implementation, it doesn't have many of the
behaviors of the real Convex backend. Still, it should be helpful for testing
the logic in your functions, and catching regressions caused by changes to your
code.

Some of the ways the mock differs:

- Error messages content. You should not write product logic that relies on the
  content of error messages thrown by the real backend, as they are always
  subject to change.
- Limits. The mock doesn't enforce size and time
  [limits](/production/state/limits.mdx).
- ID format. Your code should not depend on the document or storage ID format.
- Runtime built-ins. Most of your functions are written for the
  [Convex default runtime](/functions/runtimes.mdx), while Vitest uses a mock of
  Vercel's Edge Runtime, which is similar but might differ from the Convex
  runtime. You should always test new code manually to make sure it doesn't use
  built-ins not available in the Convex runtime.
- Some features have only simplified semantics, namely:
  - [Text search](/search.mdx) returns all documents that include a word for
    which at least one word in the searched string is a prefix. It does not sort
    the results by relevance.
  - [Vector search](/search/vector-search.mdx) returns results sorted by cosine
    similarity, but doesn't use an efficient vector index in its implementation.
  - There is no support for [cron jobs](/scheduling/cron-jobs.mdx), you should
    trigger your functions manually from the test.

To test your functions running on a real Convex backend, check out
[Testing Local Backend](/testing/convex-backend.mdx).

## CI

See [Continuous Integration](/testing/ci.mdx) to run your tests on a shared
remote machine.



================================================
FILE: npm-packages/docs/docs/tutorial/actions.mdx
================================================
---
title: "Convex Tutorial: Calling External Services"
sidebar_label: "2. Calling external services"
slug: "actions"
sidebar_position: 200
hide_table_of_contents: true
description:
  "Extend your chat app by calling external APIs using Convex actions and the
  scheduler to integrate Wikipedia summaries into your application."
---

# Convex Tutorial: Calling external services

In the [previous step](/tutorial/index.mdx), you built a fully self-contained
chat app. Data in, data out.

In order to power the automatic reactivity we just saw while providing strong
database transactions, query and mutation functions in Convex are not allowed to
make `fetch` calls to the outside world.

Real apps aren't this simple. They often need to talk to the rest of the
internet directly from the backend. Convex lets you do this too via **action**
functions.

Action functions let the sync engine access the external world by scheduling out
work that can then write data back via mutations.

Let's make our chat app a bit smarter by letting anyone in the chat get the
Wikipedia summary of a topic using the Wikipedia API.

<div className="center-image" style={{ maxWidth: "560px" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/0bn9RcwOwOQ?si=C5Gvz2Us2H1KIAQu"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>

## Your first `action`

**Add the following action to your `convex/chat.ts` file.**

```typescript
// highlight-next-line
// Update your server import like this:
// highlight-next-line
import { query, mutation, internalAction } from "./_generated/server";

//...

// highlight-next-line
export const getWikipediaSummary = internalAction({
  // highlight-next-line
  args: { topic: v.string() },
  // highlight-next-line
  handler: async (ctx, args) => {
    // highlight-next-line
    const response = await fetch(
      // highlight-next-line
      "https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&titles=" +
        // highlight-next-line
        args.topic,
      // highlight-next-line
    );
    // highlight-next-line

    // highlight-next-line
    return getSummaryFromJSON(await response.json());
    // highlight-next-line
  },
  // highlight-next-line
});
// highlight-next-line

// highlight-next-line
function getSummaryFromJSON(data: any) {
  // highlight-next-line
  const firstPageId = Object.keys(data.query.pages)[0];
  // highlight-next-line
  return data.query.pages[firstPageId].extract;
  // highlight-next-line
}
```

Let's walk through it:

1. First, we created a new Convex action function called `getWikipediaSummary`.
   We used `internalAction` because we want this function to be private to the
   Convex backend and not exposed as a public API. This function does a simple
   fetch to the Wikipedia API with our topic.
1. Next, we have a helper TypeScript function called `getSummaryFromJSON` to
   pull out the summary text from the JSON response.
1. The `getWikipediaSummary` function calls our helper function like any other
   TypeScript function.

This is great and all, but how do I use it?

To quickly test this function in the Convex dashboard, go to
[https://dashboard.convex.dev](https://dashboard.convex.dev/deployment/functions)
and navigate to your project. Click on the Functions in the left nav, and then
click on the `getWikipediaSummary` function. Click "Run Function".

The function runner UI will pop up. Try making a few searches.

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_dashboard_action.mp4" type="video/mp4" />
  Running a few Wikipedia queries
</video>

## Hooking it up to your app

It's awesome that we can call Wikipedia, but we still need to show up in our
chat. So, let's hook it all up.

**Update your existing `sendMessage` mutation like this:**

```typescript
// highlight-next-line
// Import the api reference
// highlight-next-line
import { api, internal } from "./_generated/api";

//...

export const sendMessage = mutation({
  args: {
    user: v.string(),
    body: v.string(),
  },
  handler: async (ctx, args) => {
    console.log("This TypeScript function is running on the server.");
    await ctx.db.insert("messages", {
      user: args.user,
      body: args.body,
    });

    // highlight-next-line
    // Add the following lines:
    // highlight-next-line
    if (args.body.startsWith("/wiki")) {
      // highlight-next-line
      // Get the string after the first space
      // highlight-next-line
      const topic = args.body.slice(args.body.indexOf(" ") + 1);
      // highlight-next-line
      await ctx.scheduler.runAfter(0, internal.chat.getWikipediaSummary, {
        // highlight-next-line
        topic,
        // highlight-next-line
      });
      // highlight-next-line
    }
  },
});
```

Wait a second! What's with this `ctx.scheduler` stuff? Convex comes with a
powerful durable function scheduler. It's a fundamental part of the sync engine,
and it's the way you coordinate asynchronous functions in Convex.

In the case of mutations, it's the only way to call an action to fetch from the
outside world. The really cool part is, if for some reason your mutation throws
an exception, then nothing is scheduled. This is because mutations are
transactions, and scheduling is just a write in the database to tell Convex to
run this function at a future time.

Ok so, we can schedule our action, but we still need to write the summary back
to the chat.

**Let's go back and update our `getWikipediaSummary` action:**

```typescript
export const getWikipediaSummary = internalAction({
  args: { topic: v.string() },
  handler: async (ctx, args) => {
    const response = await fetch(
      "https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&titles=" +
        args.topic,
    );

    // highlight-next-line
    // Replace the `return ...` with the following.
    // highlight-next-line
    const summary = getSummaryFromJSON(await response.json());
    // highlight-next-line
    await ctx.scheduler.runAfter(0, api.chat.sendMessage, {
      // highlight-next-line
      user: "Wikipedia",
      // highlight-next-line
      body: summary,
      // highlight-next-line
    });
  },
});
```

Just like scheduling the action, we're now scheduling our `sendMessage` mutation
to send the result of our Wikipedia lookup to our chat.

Go ahead, now play with your app!

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_wikipedia.mp4" type="video/mp4" />
  Chat with Wikipedia
</video>

## The scheduler, actions, and the sync engine

<div className="center-image" style={{ maxWidth: "900px" }}>
  ![Sync engine with actions](/img/tutorial/ConvexSyncAction.png)
</div>

Queries and mutations are the only ways to interact with the database and the
scheduler enables building sophisticated workflows with actions in between.

[Actions](/functions/actions.mdx) are normal serverless functions like AWS
Lambda and Google Cloud Run. They help model flows like calling AI APIs and
using the Vector Store. They serve as an escape hatch. They deal with the
reality of the messy outside world with few guarantees.

Actions are not part of the sync engine. To talk to the database they have to
talk through query and mutation functions. This restriction lets Convex enforce
transactional guarantees in the database and keep the sync engine fast and
nimble.

The best way to structure your application for scale is to minimize the work
that happens in an action. Only the part that needs the
[non-determinism](https://en.wikipedia.org/wiki/Deterministic_algorithm), like
making the external `fetch` call should use them. Keeping them as small as
possible is the most scalable way to build Convex apps, enabling the highest
throughput.

The scheduler allows your app to keep most of its important logic in queries and
mutations and structure your code as workflows in and out of actions.

## What you built

In this section of the tutorial, you built an action to talk to the outside
world and used the scheduler to trigger this work.

You learned that keeping our actions small and keeping most of our work in
queries and mutations are fundamental to building scalable Convex backends.

## Next up

You've now learned the most important concepts in Convex. As a full-featured
backend, Convex is capable of many things such as [authentication](/auth.mdx),
[file storage](/file-storage.mdx) and [search](/search.mdx). You can add those
features as needed by following the documentation.

We touched a little bit on setting your app up for success. As your application
scales, you will run into new challenges. Let's learn how to deal with some of
these challenges in the [next section →](/tutorial/scale.mdx).

<CardLink
  className="convex-hero-card"
  item={{
    href: "/tutorial/scale",
    docId: "tutorial/scale",
    label: "Scaling your app",
  }}
/>



================================================
FILE: npm-packages/docs/docs/tutorial/index.mdx
================================================
---
title: "Convex Tutorial: A Chat App"
sidebar_label: "1. A chat app"
sidebar_position: 100
hide_table_of_contents: true
pagination_next: tutorial/actions
pagination_label: "Convex Tutorial: A chat app"
description:
  "Build a real-time chat application with Convex using queries, mutations, and
  the sync engine for automatic updates across all connected clients."
---

# Convex Tutorial: A chat app

Convex provides you with a fully featured backend with cloud functions,
database, scheduling, and a sync engine that keeps your frontend and backend up
to date in real-time.

Today, in about **10 lines of code,** we'll build a backend that reads and
writes to the database and automatically updates all users in a chat app.

After that we'll see how to connect to external services and setup your product
for success and scale.

<div className="center-image" style={{ maxWidth: "560px" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/608khv7qqOI?si=ce-M8pt6EWDZ8tfd"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>

## Start developing with Convex

<Details summary="Before you begin: You'll need Node.js 18+ and Git">

Ensure you have Node.js version 18 or greater installed on your computer. You
can check your version of Node.js by running `node --version` in your terminal.
If you don't have the appropriate version of Node.js installed,
[install it from the Node.js website.](https://nodejs.org/en)

In addition, this walkthrough requires Git, so verify you have it installed by
running `git -v` in your terminal. If not, head over to the
[Git website](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) for
installation instructions.

</Details>

First, clone the example project repo from GitHub and install the dependencies:

```shell
git clone https://github.com/get-convex/convex-tutorial.git
cd convex-tutorial
npm install
```

This app's `dev` npm command sets up Convex and then runs the web app:

```shell
npm run dev
```

During setup, you'll see that Convex uses your GitHub account for
authentication. Sign into Convex with GitHub and then accept the default project
setup prompts.

This will **automatically create your backend** and a folder called `convex/` in
your project, where you'll write your backend code.

**Make sure you keep this command (`npm run dev`) running in the background
throughout this tutorial.** It's running both the dev web server for the
frontend as well as the `convex` command in the background to keep your backend
in sync with your local codebase.

Once your server is up and running, open [localhost:5173](http://localhost:5173)
and check it out:

<div className="center-image" style={{ maxWidth: "676px" }}>
  ![Chat UI](/img/tutorial/tut_chat_ui.png)
</div>

If you try sending a message now, you'll see an alert telling you the mutation
is not yet implemented. We'll do that in a bit, but first here's a quick summary
of how Convex works.

## How Convex works

<div className="center-image" style={{ maxWidth: "700px" }}>
  ![Overview of the sync engine](/img/tutorial/ConvexSyncEngine.png)
</div>

**Database.** The Convex database is a document-relational database, which means
you have tables with JSON like documents in them. All documents have an
auto-generated `_id` that can be used to create relations between documents. You
interact with the database through mutation and query functions that are written
entirely in TypeScript.

**Mutation functions.** Mutations are TypeScript functions that update the
database. All mutation functions in Convex run as a database transaction. So
either all the changes are committed, or none are.

**Query functions.** Queries are TypeScript functions that can only read from
the database. As we'll see in a bit, you subscribe to them from your frontend to
keep your app automatically up to date.

Your frontend registers to listen to query updates through the **client
library**. The client libraries talk to Convex via WebSockets for fast realtime
updates.

The **sync engine** reruns query functions when any input to the function
changes, including any changes to the documents in the database that the query
reads. It then updates every app listening to the query. The sync engine is the
combination of queries, mutations and the database.

Now, let's dive into the code!

## Your first `mutation`

Create a new file in your `convex/` folder called `chat.ts`. This is where
you'll write your Convex backend functions for this application.

**Add the following to your `convex/chat.ts` file.**

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const sendMessage = mutation({
  args: {
    user: v.string(),
    body: v.string(),
  },
  handler: async (ctx, args) => {
    console.log("This TypeScript function is running on the server.");
    await ctx.db.insert("messages", {
      user: args.user,
      body: args.body,
    });
  },
});
```

Let's break this down:

1. You've added a new backend `mutation` function called `sendMessage` and
   exposed it as a public api.
1. The whole function automatically runs as a transaction that will roll back if
   an exception is thrown.
1. Since this is just a TypeScript function you can drop `console.log` lines to
   do simple debugging on the server.
1. `args:` ensures the function arguments are two strings named `user` and
   `body`, both as types and runtime values.
1. `ctx.db.insert` tells Convex to insert a new message document into the table.

Now, let's connect this mutation to your web app.

**Update your `src/App.tsx` file like so:**

```tsx
// highlight-next-line
// Import `useMutation` and `api` from Convex.
// highlight-next-line
import { useMutation } from "convex/react";
// highlight-next-line
import { api } from "../convex/_generated/api";

//...

export default function App() {
  // highlight-next-line
  // Replace the "TODO: Add mutation hook here." with:
  // highlight-next-line
  const sendMessage = useMutation(api.chat.sendMessage);

  //...

  return (
    <main className="chat">
      {/* ... */}
      <form
        onSubmit={async (e) => {
          e.preventDefault();
          // highlight-next-line
          // Replace "alert("Mutation not implemented yet");" with:
          // highlight-next-line
          await sendMessage({ user: NAME, body: newMessageText });

          setNewMessageText("");
        }}
      >
        {/* ... */}
      </form>
    </main>
  );
}
```

There are two steps to call a mutation in your frontend:

1. `const sendMessage = useMutation(api.chat.sendMessage);` gives your frontend
   app a handle to the mutation function
2. `await sendMessage({ user: NAME, body: newMessageText });` calls the mutation
   with the proper parameters.

This is a good time to **open up the Convex dashboard**. Open a new browser
window and go to [https://dashboard.convex.dev](https://dashboard.convex.dev)
and find new `convex-tutorial` project.

**Go to the "Data" screen**. So far, there is no data in your database.

**Keep your chat app and dashboard windows open side by side**. Now try to send
some messages from your chat app.

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_first_mutation.mp4" type="video/mp4" />
  Mutations hooked up to the Convex backend and database.
</video>

You'll notice new chat messages showing up live in the `messages` table.

Convex automatically created a `messages` table when you sent the first message.
In Convex, [schemas](/database/schemas.mdx) are optional. Eventually, you'll
want to enforce the structure of your tables, but for the purposes of the
tutorial we'll skip this.

In the dashboard you can also go to the
[logs screen](https://dashboard.convex.dev/deployment/logs) and see every call
to the mutation as you ran with the log line we added earlier. The logs screen
is a critical part of debugging your backend in development.

You've successfully created a `mutation` function, which is also a database
transaction, and connected it to your UI.

Now, let's make sure your app can update live the same way the dashboard is
updating live.

## Your first `query`

**Update your `convex/chat.ts` file like this:**

```tsx
// highlight-next-line
// Update your server import like this:
// highlight-next-line
import { query, mutation } from "./_generated/server";

// ...

// highlight-next-line
// Add the following function to the file:
// highlight-next-line
export const getMessages = query({
  // highlight-next-line
  args: {},
  // highlight-next-line
  handler: async (ctx) => {
    // highlight-next-line
    // Get most recent messages first
    // highlight-next-line
    const messages = await ctx.db.query("messages").order("desc").take(50);
    // highlight-next-line
    // Reverse the list so that it's in a chronological order.
    // highlight-next-line
    return messages.reverse();
    // highlight-next-line
  },
  // highlight-next-line
});
```

Let's break this down:

1. You've added a new backend `query` function called `getMessages` and exposed
   it as a public api.
1. Since this is a query function, the `ctx.db` in this function only lets you
   read data.
1. In the first line of the `handler` you are querying the most recent 50
   messages from newest to oldest.
1. In the second line you're reversing the list using plain old TypeScript.

**Now update `src/App.tsx` to read from your query:**

```tsx
// highlight-next-line
// Update your convex/react import like this:
// highlight-next-line
import { useQuery, useMutation } from "convex/react";

//...

export default function App() {
  // highlight-next-line
  // Replace the `const messages = ...` line with the following
  // highlight-next-line
  const messages = useQuery(api.chat.getMessages);

  //...
}
```

That one `useQuery` line is doing a lot of work automatically for you. It's
telling the Convex client library to subscribe to your `getMessages` function.
Anytime there are new messages to show the query function is automatically
rerun. The result is put in `const messages` variable and React rerenders your
UI component to show the latest messages.

That's it. Now go back to your app and try sending messages.

Your app should be showing live updates as new messages arrive:

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_first_query.mp4" type="video/mp4" />
  Queries hooked up and live updating to the app.
</video>

<br />
<br />
Don't believe it? Try opening two chat windows side by side and send some
messages:

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_side_by_side.mp4" type="video/mp4" />
  Live syncing chat app.
</video>

## What you built

With just a few lines of code you've built a live updating chat app.

1. You created a `mutation` TypeScript function that, in a transaction, adds new
   chat messages to your database.
1. You created a `query` TypeScript function updates your app with the latest
   data.
1. You used the client library that keeps your frontend in live sync with the
   backend.

You've learned the fundamentals of Convex and the sync engine that powers
everything.

## Next up

In this tutorial we just touched on the very basics. It's ok to just stop here
and go explore the rest of the docs, including
[efficient queries via indexes](/database/reading-data/indexes/indexes.md) and
traversing
[relationships through joins](/database/reading-data/reading-data.mdx#join). If
you're deeply curious about how Convex works, you can read this
[excellent deep dive](https://stack.convex.dev/how-convex-works).

But if you want to see how to call external services and build sophisticated
backend workflows, jump into the [next section →](/tutorial/actions.mdx).

<CardLink
  className="convex-hero-card"
  item={{
    href: "/tutorial/actions",
    docId: "tutorial/actions",
    label: "Calling external services",
  }}
/>



================================================
FILE: npm-packages/docs/docs/tutorial/scale.mdx
================================================
---
title: "Convex Tutorial: Scaling Your App"
sidebar_label: "3. Scaling your app"
slug: "scale"
sidebar_position: 300
hide_table_of_contents: true
description:
  "Learn how to scale your Convex application using indexes, handling write
  conflicts, and leveraging Convex Components for best practices."
---

import ComponentsIcon from "@site/static/img/sidebar-icons/components.svg";

# Convex Tutorial: Scaling your app

Convex was designed from the ground up for scale. In the previous section we
already talked about how keeping your actions small and most of your logic in
queries and mutations are crucial to building fast scalable backends.

Let's talk about a few other ways to keep your app fast and scalable.

<div className="center-image" style={{ maxWidth: "560px" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/7lOGqFHnEsA"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>

## Indexed queries

Indexes tell the database to create a lookup structure to make it really fast to
filter data. If, in our chat app we wanted to build a way to look up `messages`
from just one user, we'd tell Convex to index the `user` field in the `messages`
table and write the query with the `withIndex` syntax.

[Learn how to use indexes](/database/reading-data/indexes/indexes.md).

## Too many writes on the same document

Let's say you decide to show a counter in your app. You may write a mutation
that reads a number field, adds 1, and updates the same field in the database.
At some point, this pattern may cause an
[optimistic concurrency control conflict](/error#1). That means that the
database isn't able to handle updating the document that fast. All databases
have trouble with this sort of pattern.

There are a [few ways to deal with this](/error#remediation), including building
something called a sharded counter...

But before you go learn advanced scaling techniques on your own, there is a
better way with [Convex Components](/components.mdx).

## Scaling best practices with Convex Components

In the case of the counter above, the Convex team has already built a
[scalable counter](https://www.convex.dev/components/sharded-counter) Convex
component for you to use.

Convex Components are deployed along with your Convex backend but have their own
tables and functions.

As you build more complicated features like [AI agents](/agents.mdx),
[workflows](https://www.convex.dev/components/workflow),
[leaderboards](https://www.convex.dev/components/aggregate),
[feature flags](https://www.convex.dev/components/launchdarkly) or
[rate limiters](https://www.convex.dev/components/rate-limiter), you may find
that there is already a Convex Component that solves this problem.
[Learn more about Convex Components here](/components.mdx).

<CardLink
  className="convex-hero-card"
  item={{
    icon: <ComponentsIcon height={40} />,
    href: "https://www.convex.dev/components",
    label: "Components directory",
  }}
/>

## Wrap up

We've covered a lot of ground in this tutorial. We started by
[building a chat app](/tutorial/index.mdx) with queries, mutations and the
database that form the fundamental building blocks of the Convex sync engine. We
then called an [external API](/tutorial/actions.mdx) from our backend, using the
scheduler to coordinate the work. Finally, we learned that
[Convex Components](/components.mdx) give you scaling best practices in neat
packages.

If you are looking for more tips, read our
[best practices](/understanding/best-practices/best-practices.mdx) and join the
[community](https://www.convex.dev/community).

Convex enables you to build your MVP fast and then scale to new heights. Many
great products have already done so. You're in good company.



================================================
FILE: npm-packages/docs/docs/understanding/index.mdx
================================================
---
title: "Convex Overview"
hidden: false
sidebar_position: 100
pagination_next: understanding/workflow
description:
  "Introduction to Convex - the reactive database with TypeScript queries"
---

Convex is the open source, reactive database where queries are TypeScript code
running right in the database. Just like React components react to state
changes, Convex queries react to database changes.

Convex provides a database, a place to write your server functions, and client
libraries. It makes it easy to build and scale dynamic live-updating apps.

The following diagram shows the standard three-tier app architecture that Convex
enables. We'll start at the bottom and work our way up to the top of this
diagram.

<div
  className="center-image"
  style={{ maxWidth: "600px", background: "white", borderRadius: "10px" }}
>
  ![Convex in your app](/img/basic-diagram.png)
</div>

## Database

The [database](/database.mdx) is at the core of Convex. The Convex database is
automatically provisioned when you create your project. There is no connection
setup or cluster management.

<Admonition type="info">
  In Convex, your database queries are just [TypeScript
  code](/database/reading-data/reading-data.mdx) written in your [server
  functions](/functions.mdx). There is no SQL to write. There are no ORMs
  needed.
</Admonition>

The Convex database is reactive. Whenever any data on which a query depends
changes, the query is rerun, and client subscriptions are updated.

Convex is a "document-relational" database. "Document" means you put JSON-like
nested objects into your database. "Relational" means you have tables with
relations, like `tasks` assigned to a `user` using IDs to reference documents in
other tables.

The Convex cloud offering runs on top of Amazon RDS using MySQL as its
persistence layer. The Open Source version uses SQLite, Postgres and MySQL. The
database is ACID-compliant and uses
[serializable isolation and optimistic concurrency control](/database/advanced/occ.md).
All that to say, Convex provides the strictest possible transactional
guarantees, and you never see inconsistent data.

## Server functions

When you create a new Convex project, you automatically get a `convex/` folder
where you write your [server functions](/functions.mdx). This is where all your
backend application logic and database query code live.

Example TypeScript server functions that read (query) and write (mutation) to
the database.

```typescript title="convex/tasks.ts"
// A Convex query function
export const getAllOpenTasks = query({
  args: {},
  handler: async (ctx, args) => {
    // Query the database to get all items that are not completed
    const tasks = await ctx.db
      .query("tasks")
      .withIndex("by_completed", (q) => q.eq("completed", false))
      .collect();
    return tasks;
  },
});

// A Convex mutation function
export const setTaskCompleted = mutation({
  args: { taskId: v.id("tasks"), completed: v.boolean() },
  handler: async (ctx, { taskId, completed }) => {
    // Update the database using TypeScript
    await ctx.db.patch("tasks", taskId, { completed });
  },
});
```

You read and write to your database through query or mutation functions.
[Query functions](/functions/query-functions.mdx) are pure functions that can
only read from the database.
[Mutation functions](/functions/mutation-functions.mdx) are transactions that
can read or write from the database. These two database functions are
[not allowed to take any non-deterministic](/functions/runtimes.mdx#restrictions-on-queries-and-mutations)
actions like network requests to ensure transactional guarantees.

<Admonition type="info">
  The entire Convex mutation function is a transaction. There are no `begin` or
  `end` transaction statements to write. Convex automatically retries the
  function on conflicts, and you don't have to manage anything.
</Admonition>

Convex also provides standard general-purpose serverless functions called
actions. [Action functions](/functions/actions.mdx) can make network requests.
They have to call query or mutation functions to read and write to the database.
You use actions to call LLMs or send emails.

You can also durably schedule Convex functions via the
[scheduler](scheduling/scheduled-functions.mdx) or
[cron jobs](scheduling/cron-jobs.mdx). Scheduling lets you build workflows like
emailing a new user a day later if they haven't performed an onboarding task.

You call your Convex functions via [client libraries](/client/react.mdx) or
directly via [HTTP](/http-api/index.md#functions-api).

## Client libraries

Convex client libraries keep your frontend synced with the results of your
server functions.

```tsx
// In your React component
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export function TaskList() {
  const data = useQuery(api.tasks.getAllOpenTasks);
  return data ?? "Loading...";
}
```

Like the `useState` hook that updates your React component when local state
changes, the Convex `useQuery` hook automatically updates your component
whenever the result of your query changes. There's no manual subscription
management or state synchronization needed.

When calling query functions, the client library subscribes to the results of
the function. Convex tracks the dependencies of your query functions, including
what data was read from the database. Whenever relevant data in the database
changes, the Convex automatically reruns the query and sends the result to the
client.

The client library also queues up mutations in memory to send to the server. As
mutations execute and cause query results to update, the client library keeps
your app state consistent. It updates all subscriptions to the same logical
moment in time in the database.

Convex provides client libraries for nearly all popular web and native app
frameworks. Client libraries connect to your Convex deployment via WebSockets.
You can then call your public Convex functions
[through the library](/client/react.mdx#fetching-data). You can also use Convex
with [HTTP directly](/http-api/index.md#functions-api), you just won't get the
automatic subscriptions.

## Putting it all together

Let's return to the `getAllOpenTasks` Convex query function from earlier that
gets all tasks that are not marked as `completed`:

```typescript title="convex/tasks.ts"
export const getAllOpenTasks = query({
  args: {},
  handler: async (ctx, args) => {
    // Query the database to get all items that are not completed
    const tasks = await ctx.db
      .query("tasks")
      .withIndex("by_completed", (q) => q.eq("completed", false))
      .collect();
    return tasks;
  },
});
```

Let's follow along what happens when you subscribe to this query:

<div
  className="center-image"
  style={{ maxWidth: "1800px", background: "white", borderRadius: "10px" }}
>
  ![Convex data flow](/img/convex-query-subscription.png)
</div>

The web app uses the `useQuery` hook to subscribe to this query, and the
following happens to get an initial value:

- The Convex client sends a message to the Convex server to subscribe to the
  query
- The Convex server runs the function, which reads data from the database
- The Convex server sends a message to the client with the function's result

In this case the initial result looks like this (1):

```json
[
  { _id: "e4g", title: "Grocery shopping", complete: false },
  { _id: "u9v", title: "Plant new flowers", complete: false },
];
```

Then you use a mutation to mark an item as completed (2). Convex then reruns the
query (3) to get an updated result. And pushes the result to the web app via the
WebSocket connection (4):

```json
[
  { _id: "e4g", title: "Grocery shopping", complete: false },
];
```

## Beyond reactivity

Beyond reactivity, Convex's architecture is crucial for a deeper reason. Convex
does not let your app have inconsistent state at any layer of the stack.

To illustrate this, let's imagine you're building a shopping cart for an
e-commerce store.

<div className="center-image" style={{ maxWidth: "600px" }}>
  ![Convex in your app](/img/convex-swaghaus.png)
</div>

On the product listing page, you have two numbers, one showing the number of
items remaining in stock and another showing the number of items in your
shopping cart. Each number is a result of a different query function.

Every time you press the "Add to Cart" button, a mutation is called to remove
one item from the stock and add it to the shopping cart.

The mutation to change the cart runs in a transaction, so your database is
always in a consistent state. The reactive database knows that the queries
showing the number of items in stock and the number of items in the shopping
cart both need to be updated. The queries are invalidated and rerun. The results
are pushed to the web app via the WebSocket connection.

The client library makes sure that both queries update at the same time in the
web app since they reflect a singular moment in time in your database. You never
have a moment where those numbers don't add up. Your app always shows consistent
data.

You can see this example in action in the
[Swaghaus sample app](https://swaghaus.biz/).

## For human and AI generated code

Convex is designed around a small set of composable abstractions with strong
guarantees that result in code that is not only faster to write, it’s easier to
read and maintain, whether written by a team member or an LLM. Key features make
sure you get bug-free AI generated code:

1. **Queries are Just TypeScript** Your database queries are pure TypeScript
   functions with end-to-end type safety and IDE support. This means AI can
   generate database code using the large training set of TypeScript code
   without switching to SQL.
1. **Less Code for the Same Work** Since so much infrastructure and boiler plate
   is automatically managed by Convex there is less code to write, and thus less
   code to get wrong.
1. **Automatic Reactivity** The reactive system automatically tracks data
   dependencies and updates your UI. AI doesn't need to manually manage
   subscriptions, WebSocket connections, or complex state synchronization—Convex
   handles all of this automatically.
1. **Transactional Guarantees** Queries are read-only and mutations run in
   transactions. These constraints make it nearly impossible for AI to write
   code that could corrupt your data or leave your app in an inconsistent state.

Together, these features mean AI can focus on your business logic while Convex's
guarantees prevent common failure modes.

## Learn more

<div style={{ maxWidth: "560px" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/3d29eKJ2Vws"
    title="YouTube video player"
    frameBorder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerPolicy="strict-origin-when-cross-origin"
    allowFullScreen
  ></iframe>
</div>

If you are intrigued about the details of how Convex pulls this all off, you can
read Convex co-founder Sujay's excellent
[How Convex Works](https://stack.convex.dev/how-convex-works) blog post.

Now that you have a good sense of how Convex fits in your app. Let's walk
through the overall workflow of setting up and launching a Convex app.



================================================
FILE: npm-packages/docs/docs/understanding/workflow.mdx
================================================
---
title: "Dev workflow"
hidden: false
sidebar_position: 200
description:
  "Development workflow from project creation to production deployment"
---

Let's walk through everything that needs to happen from creating a new project
to launching your app in production.

This doc assumes you are building an app with Convex and React and you already
have a basic React app already up and running. You can follow one of our
[quickstarts](/quickstarts.mdx) to set this up.

## Installing and running Convex

You install Convex adding the npm dependency to your app:

```sh
npm i convex
```

Then you create your Convex project and start the backend dev loop:

```sh
npx convex dev
```

The first time you run the `npx convex dev` command you'll be asked whether you
want start developing locally without an account or create an account.

### Developing without an account

`npx convex dev` will prompt you for the name of your project, and then start
running the open-source Convex backend locally on your machine (this is also
called a "deployment").

The data for your project will be saved in the `~/.convex` directory.

1. The name of your project will get saved to your `.env.local` file so future
   runs of `npx convex dev` will know to use this project.
1. A `convex/` folder will be created (if it doesn't exist), where you'll write
   your Convex backend functions.

You can run `npx convex login` in the future to create an account and link any
existing projects.

### Developing with an account

`npx convex dev` will prompt you through creating an account if one doesn't
exist, and will add your credentials to `~/.convex/config.json` on your machine.
You can run `npx convex logout` to log you machine out of the account in the
future.

Next, `npx convex dev` will create a new project and provision a new personal
development deployment for this project:

1.  Deployment details will automatically be added to your `.env.local` file so
    future runs of `npx convex dev` will know which dev deployment to connect
    to.
1.  A `convex/` folder will be created (if it doesn't exist), where you'll write
    your Convex backend functions.

<div className="center-image" style={{ maxWidth: "149px" }}>
  ![Convex directory in your app](/img/convex-directory.png)
</div>

## Running the dev loop

Keep the `npx convex dev` command running while you're working on your Convex
app. This continuously pushes backend code you write in the `convex/` folder to
your deployment. It also keeps the necessary TypeScript types up-to-date as you
write your backend code.

When you're developing with a locally running deployment, `npx convex dev` is
also responsible for running your deployment.

You can then add new server functions to your Convex backend:

```typescript title="convex/tasks.ts"
import { query } from "./_generated/server";
import { v } from "convex/values";

// Return the last 100 tasks in a given task list.
export const getTaskList = query({
  args: { taskListId: v.id("taskLists") },
  handler: async (ctx, args) => {
    const tasks = await ctx.db
      .query("tasks")
      .withIndex("taskListId", (q) => q.eq("taskListId", args.taskListId))
      .order("desc")
      .take(100);
    return tasks;
  },
});
```

When you write and save this code in your editor, several things happen:

1. The `npx convex dev` command typechecks your code and updates the
   `convex/_generated` directory.
1. The contents of your `convex/` directory get uploaded to your dev deployment.
1. Your Convex dev deployment analyzes your code and finds all Convex functions.
   In this example, it determines that `tasks.getTaskList` is a new public query
   function.
1. If there are any changes to the [schema](/database/schemas.mdx), the
   deployment will automatically enforce them.
1. The `npx convex dev` command updates generated TypeScript code in the
   `convex/_generated` directory to provide end to end type safety for your
   functions.

<Admonition type="tip">
  Check in everything in your `convex/_generated/` directory. This it ensures
  that your code immediately type checks and runs without having to first run
  `npx convex dev`. It's particularly useful when non-backend developers are
  writing frontend code and want to ensure their code type checks against
  currently deployed backend code.
</Admonition>

Once this is done you can use your new server function in your frontend:

```typescript title="src/App.tsx"
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export function App() {
  const data = useQuery(api.tasks.getTaskList);
  return data ?? "Loading...";
}
```

If you have other configuration like [crons](/scheduling/cron-jobs.mdx) or
[auth](/auth.mdx) in your `convex/` folder, Convex ensures that they are applied
and enforced on your backend.

## Convex dashboard

The [Convex dashboard](/dashboard/deployments/deployments.md) will be a trusty
helper throughout your dev, debug and deploy workflow in Convex.

`npx convex dashboard` will open a link to the dashboard for your deployment.

### Logs

Since Convex functions are TypeScript functions you can always use the standard
`console.log` and `console.time` functions to debug your apps.

Logs from your functions show up
[in your dashboard](/dashboard/deployments/logs.md).

![Logs Dashboard Page](/screenshots/logs.png)

### Health, Data, Functions and more

- [Health](/dashboard/deployments/health.md) - provides invaluable information
  on how your app is performing in production, with deep insights on how your
  Convex queries are doing.
- [Data](/dashboard/deployments/data.md) - gives you a complete data browser to
  spot check your data.
- [Functions](/dashboard/deployments/functions.md) - gives you stats and run
  functions to debug them.

There is a lot more to to the dashboard. Be sure to click around or
[check out the docs](/dashboard.md).

## Deploying your app

So far you've been working on your app against your personal dev deployment.

All Convex projects have one production deployment running in the cloud. It has
separate data and has a separate push process from personal dev deployments,
which allows you and your teammates to work on new features using personal dev
deployments without disrupting your app running in production.

If you have not created a Convex account yet, you will need to do so with
`npx convex login`. This will automatically link any projects you've started
with your new account, and enable using your production deployment.

To push your code to your production deployment for your project you run the
deploy command:

```sh
npx convex deploy
```

<Admonition type="info">
  If you're running this command for the first time, it will automatically
  provision the prod deployment for your project.
</Admonition>

### Setting up your deployment pipeline

It's rare to run `npx convex deploy` directly. Most production applications run
an automated workflow that runs tests and deploys your backend and frontend
together.

You can see detailed deployment and frontend configuration instructions in the
[Hosting and Deployment](/production/hosting/hosting.mdx) doc. For most React
meta-frameworks Convex
[automatically sets the correct environment variable](/production/hosting/vercel.mdx#how-it-works)
to connect to the production deployment.

## Up next

You now know the basics of how Convex works and fits in your app. Go head and
explore the docs further to learn more about the specific features you want to
use.

Whenever you're ready be sure the read the
[Best Practices](/understanding/best-practices/best-practices.mdx), and then the
[Zen of Convex](/understanding/zen.mdx) once you are ready to "think in Convex."



================================================
FILE: npm-packages/docs/docs/understanding/zen.mdx
================================================
---
title: "The Zen of Convex"
slug: "zen"
hidden: false
sidebar_position: 500
hide_table_of_contents: true
description: "Convex best practices and design philosophy"
---

export function CategoryIcon(props) {
  switch (props.title) {
    case "Performance":
      return (
        <svg
          fill="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
          aria-hidden="true"
          {...props}
        >
          <path
            clipRule="evenodd"
            fillRule="evenodd"
            d="M14.615 1.595a.75.75 0 01.359.852L12.982 9.75h7.268a.75.75 0 01.548 1.262l-10.5 11.25a.75.75 0 01-1.272-.71l1.992-7.302H3.75a.75.75 0 01-.548-1.262l10.5-11.25a.75.75 0 01.913-.143z"
          />
        </svg>
      );
    case "Architecture":
      return (
        <svg
          fill="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
          aria-hidden="true"
        >
          <path d="M11.584 2.376a.75.75 0 01.832 0l9 6a.75.75 0 11-.832 1.248L12 3.901 3.416 9.624a.75.75 0 01-.832-1.248l9-6z" />
          <path
            clipRule="evenodd"
            fillRule="evenodd"
            d="M20.25 10.332v9.918H21a.75.75 0 010 1.5H3a.75.75 0 010-1.5h.75v-9.918a.75.75 0 01.634-.74A49.109 49.109 0 0112 9c2.59 0 5.134.202 7.616.592a.75.75 0 01.634.74zm-7.5 2.418a.75.75 0 00-1.5 0v6.75a.75.75 0 001.5 0v-6.75zm3-.75a.75.75 0 01.75.75v6.75a.75.75 0 01-1.5 0v-6.75a.75.75 0 01.75-.75zM9 12.75a.75.75 0 00-1.5 0v6.75a.75.75 0 001.5 0v-6.75z"
          />
          <path d="M12 7.875a1.125 1.125 0 100-2.25 1.125 1.125 0 000 2.25z" />
          //{" "}
        </svg>
      );
    case "Development workflow":
      return (
        <svg
          fill="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
          aria-hidden="true"
          {...props}
        >
          <path
            clipRule="evenodd"
            fillRule="evenodd"
            d="M2.25 6a3 3 0 013-3h13.5a3 3 0 013 3v12a3 3 0 01-3 3H5.25a3 3 0 01-3-3V6zm3.97.97a.75.75 0 011.06 0l2.25 2.25a.75.75 0 010 1.06l-2.25 2.25a.75.75 0 01-1.06-1.06l1.72-1.72-1.72-1.72a.75.75 0 010-1.06zm4.28 4.28a.75.75 0 000 1.5h3a.75.75 0 000-1.5h-3z"
          />
        </svg>
      );
    default:
      return null;
  }
}

export function ZenHeader({ title }) {
  return (
    <h2 className="zen-header">
      {title} <CategoryIcon title={title} />
    </h2>
  );
}

export function TipIcon({ type }) {
  switch (type) {
    case "do":
      return (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="currentColor"
          className="w-6 h-6"
        >
          <path
            fillRule="evenodd"
            d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zm13.36-1.814a.75.75 0 10-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.14-.094l3.75-5.25z"
            clipRule="evenodd"
          />
        </svg>
      );
    case "do-not":
      return (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="currentColor"
          className="w-6 h-6"
        >
          <path
            fillRule="evenodd"
            d="M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z"
            clipRule="evenodd"
          />
        </svg>
      );
    default:
      return null;
  }
}

export function ZenTip({ type, title, children }) {
  return (
    <div className={`zen-tip zen-${type}`}>
      <h3>
        <TipIcon type={type} /> {title}
      </h3>
      {children}
    </div>
  );
}

<div style={{ maxWidth: "560px" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/dyEWQ9s2ji4?si=ce-M8pt6EWDZ8tfd"
    title="YouTube video player"
    frameBorder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerPolicy="strict-origin-when-cross-origin"
    allowFullScreen
  ></iframe>
</div>

<span className="convex-hero">
Convex is an opinionated framework, with every element designed to pull developers into
[the pit of success](https://blog.codinghorror.com/falling-into-the-pit-of-success/).

The Zen of Convex is a set of guidelines & best practices developers have
discovered that keep their projects falling into this wonderful pit.

</span>

<ZenHeader title="Performance" />

<ZenTip type="do" title={<span>Double down on the <a href="/tutorial#how-convex-works">sync engine</a></span>} >

    There's a reason why a deterministic, reactive database is the beating heart
    of Convex: the more you center your apps around its properties, the better
    your projects will fare over time. Your projects will be easier to
    understand and refactor. Your app's performance will stay screaming fast.
    You won't have any consistency or state management problems.

<Details summary="Use a query for nearly every app read">
  Queries are the reactive, automatically cacheable, consistent and resilient
  way to propagate data to your application and its jobs. With very few
  exceptions, every read operation in your app should happen via a query
  function.
</Details>

<Details summary="Keep sync engine functions light & fast">
  In general, your mutations and queries should be working with less than a few
  hundred records and should aim to finish in less than 100ms. It's nearly
  impossible to maintain a snappy, responsive app if your synchronous
  transactions involve a lot more work than this.
</Details>

<Details summary="Use actions sparingly and incrementally">
  Actions are wonderful for batch jobs and/or integrating with outside services.
  They're very powerful, but they're slower, more expensive, and Convex provides
  a lot fewer guarantees about their behavior. So never use an action if a query
  or mutation will get the job done.
</Details>

</ZenTip>

<ZenTip type="do-not" title="Don't over-complicate client-side state management">

Convex builds in a ton of its own caching and consistency controls into the
app's client library. Rather than reinvent the wheel, let your client-side code
take advantage of these built-in performance boosts.

<Details summary="Let Convex handle caching & consistency">

You might be tempted to quickly build your own local cache or state aggregation
layer in Convex to sit between your components and your Convex functions. With
Convex, most of the time, you won't end up needing this. More often than not,
you can bind your components to Convex functions in pretty simple ways and
things will Just Work and be plenty fast.

</Details>

<Details summary="Be thoughtful about the return values of mutations">
  Mutation return values can be useful to trigger state changes in your app, but
  it's rarely a good idea to use them to set in-app state to update the UI. Let
  queries and the sync engine do that.
</Details>

</ZenTip>

<ZenHeader title="Architecture" />

<ZenTip type="do" title='Create server-side frameworks using "just code"'>
  <p>
    Convex's built-in primitives are pretty low level! They're just functions.
    What about authentication frameworks? What about object-relational mappings?
    Do you need to wait until Convex ships some in-built feature to get those?
    Nope. In general, you should solve composition and encapsulation problems in
    your server-side Convex code using the same methods you use for the rest of
    your TypeScript code bases. After all, this is why Convex is "just code!"
    [Stack](https://stack.convex.dev) always has
    [great](https://stack.convex.dev/functional-relationships-helpers)
    [examples](https://stack.convex.dev/wrappers-as-middleware-authentication)
    of ways to tackle [these
    needs](https://stack.convex.dev/row-level-security).
  </p>
</ZenTip>

<ZenTip type="do-not" title="Don't misuse actions" >

Actions are powerful, but it's important to be intentional in how they fit into
your app's data flow.

<Details summary="Don't invoke actions directly from your app">
  In general, it's an anti-pattern to call actions from the browser. Usually,
  actions are running on some dependent record that should be living in a Convex
  table. So it's best trigger actions by invoking a mutation that both _writes_
  that dependent record and _schedules_ the subsequent action to run in the
  background.
</Details>

<Details summary="Don't think 'background jobs', think 'workflow'">
   When actions are involved, it's useful to write chains of effects and
   mutations, such as:

action code &rarr; mutation &rarr; more action code &rarr; mutation.

Then apps or other jobs can follow along with queries.

</Details>

<Details summary="Record progress one step at a time">
  While actions _could_ work with thousands of records and call dozens of APIs,
  it's normally best to do smaller batches of work and/or to perform individual
  transformations with outside services. Then record your progress with a
  mutation, of course. Using this pattern makes it easy to debug issues, resume
  partial jobs, and report incremental progress in your app's UI.
</Details>

</ZenTip>

<ZenHeader title="Development workflow" />

<ZenTip type="do" title="Keep the dashboard by your side">
  <p>
    Working on your Convex project without using the dashboard is like driving a
    car with your eyes closed. The dashboard lets you view logs, give
    mutations/queries/actions a test run, make sure your configuration and
    codebase are as you expect, inspect your tables, generate schemas, etc. It's
    an invaluable part of your rapid development cycle.
  </p>
</ZenTip>

<ZenTip type="do-not" title="Don't go it alone" >

  <p>
    Between these [docs](https://docs.convex.dev),
    [Stack](https://stack.convex.dev), and [our
    community](https://convex.dev/community), someone has _probably_ encountered
    the design or architectural issue you're facing. So why try to figure things out the hard way, when you can take advantage of a whole community's experience?
   </p>
  
  <Details summary="Leverage Convex developer search">
  With so many great resources from the Convex team & community, it can be hard to know where to look first. If you want a quick way to
    search across all of these, [we have a portal for
    that](https://search.convex.dev)!
  </Details>
   
  <Details summary="Join the Convex community">
  Whether you're stuck on a tricky use case, you have a question or feature request for the Convex team, or you're excited to share the amazing app(s) you've built and help others learn, the Convex community is there for you! Join the party on [Discord](https://convex.dev/community).
  </Details>
</ZenTip>



================================================
FILE: npm-packages/docs/docs/understanding/best-practices/best-practices.mdx
================================================
---
title: "Best Practices"
sidebar_position: 400
toc_max_heading_level: 2
description:
  "Essential best practices for building scalable Convex applications including
  database queries, function organization, validation, and security."
---

import BestPracticesTS from "!!raw-loader!@site/../private-demos/snippets/convex/bestPractices/index.ts";
import HelperFunctionsTS from "!!raw-loader!@site/../private-demos/snippets/convex/bestPractices/helperFunctions.ts";
import UserHelpersJS from "!!raw-loader!@site/../private-demos/snippets/convex/userHelpersJS.js";
import Teams from "!!raw-loader!@site/../private-demos/snippets/convex/bestPracticesHelpersTeams.ts";
import TeamsJS from "!!raw-loader!@site/../private-demos/snippets/convex/bestPracticesHelpersTeamsJS.js";

This is a list of best practices and common anti-patterns around using Convex.
We recommend going through this list before broadly releasing your app to
production. You may choose to try using all of these best practices from the
start, or you may wait until you've gotten major parts of your app working
before going through and adopting the best practices here.

## Await all Promises

### Why?

Convex functions use async / await. If you don't await all your promises (e.g.
`await ctx.scheduler.runAfter`, `await ctx.db.patch`), you may run into
unexpected behavior (e.g. failing to schedule a function) or miss handling
errors.

### How?

We recommend the
[no-floating-promises](https://typescript-eslint.io/rules/no-floating-promises/)
rule of typescript-eslint.

## Avoid `.filter` on database queries

### Why?

Filtering in code instead of using the `.filter` syntax has the same
performance, and is generally easier code to write. Conditions in `.withIndex`
or `.withSearchIndex` are more efficient than `.filter` or filtering in code, so
almost all uses of `.filter` should either be replaced with a `.withIndex` or
`.withSearchIndex` condition, or written as TypeScript code.

Read through the
[indexes documentation](/database/reading-data/indexes/indexes-and-query-perf.md)
for an overview of how to define indexes and how they work.

### Examples

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="filter"
/>

### How?

Search for `.filter` in your Convex codebase — a regex like `\.filter\(\(?q`
will probably find all the ones on database queries.

Decide whether they should be replaced with a `.withIndex` condition — per
[this section](/understanding/best-practices/best-practices.mdx#only-use-collect-with-a-small-number-of-results),
if you are filtering over a large (1000+) or potentially unbounded number of
documents, you should use an index. If not using a `.withIndex` /
`.withSearchIndex` condition, consider replacing them with a filter in code for
more readability and flexibility.

See [this article](https://stack.convex.dev/complex-filters-in-convex) for more
strategies for filtering.

### Exceptions

Using `.filter` on a paginated query (`.paginate`) has advantages over filtering
in code. The paginated query will return the number of documents requested,
including the `.filter` condition, so filtering in code afterwards can result in
a smaller page or even an empty page. Using `.withIndex` on a paginated query
will still be more efficient than a `.filter`.

## Only use `.collect` with a small number of results

### Why?

All results returned from `.collect` count towards database bandwidth (even ones
filtered out by `.filter`). It also means that if any document in the result
changes, the query will re-run or the mutation will hit a conflict.

If there's a chance the number of results is large (say 1000+ documents), you
should use an index to filter the results further before calling `.collect`, or
find some other way to avoid loading all the documents such as using pagination,
denormalizing data, or changing the product feature.

### Example

**Using an index:**

<TSAndJSSnippet
  title="convex/movies.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="collectIndex"
/>

**Using pagination:**

<TSAndJSSnippet
  title="convex/movies.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="collectPaginate"
/>

**Using a limit or denormalizing:**

<TSAndJSSnippet
  title="convex/movies.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="collectCount"
/>

### How?

Search for `.collect` in your Convex codebase (a regex like `\.collect\(` will
probably find these). And think through whether the number of results is small.
This function health page in the dashboard can also help surface these.

The [aggregate component](https://www.npmjs.com/package/@convex-dev/aggregate)
or [database triggers](https://stack.convex.dev/triggers) can be helpful
patterns for denormalizing data.

### Exceptions

If you're doing something that requires loading a large number of documents
(e.g. performing a migration, making a summary), you may want to use an action
to load them in batches via separate queries / mutations.

## Check for redundant indexes

### Why?

Indexes like `by_foo` and `by_foo_and_bar` are usually redundant (you only need
`by_foo_and_bar`). Reducing the number of indexes saves on database storage and
reduces the overhead of writing to the table.

<TSAndJSSnippet
  title="convex/teams.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="redundantIndexes"
  replacements={[[/\sOMIT_ME.*/g, ""]]}
/>

### How?

Look through your indexes, either in your `schema.ts` file or in the dashboard,
and look for any indexes where one is a prefix of another.

### Exceptions

`.index("by_foo", ["foo"])` is really an index on the properties `foo` and
`_creationTime`, while `.index("by_foo_and_bar", ["foo", "bar"])` is an index on
the properties `foo`, `bar`, and `_creationTime`. If you have queries that need
to be sorted by `foo` and then `_creationTime`, then you need both indexes.

For example, `.index("by_channel", ["channel"])` on a table of messages can be
used to query for the most recent messages in a channel, but
`.index("by_channel_and_author", ["channel", "author"])` could not be used for
this since it would first sort the messages by `author`.

## Use argument validators for all public functions

### Why?

Public functions can be called by anyone, including potentially malicious
attackers trying to break your app.
[Argument validators](/functions/validation.mdx) (as well as return value
validators) help ensure you're getting the traffic you expect.

### Example

<TSAndJSSnippet
  title="convex/movies.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="validation"
  replacements={[[/_OMIT_[0-9]+/g, ""]]}
/>

### How?

Search for `query`, `mutation`, and `action` in your Convex codebase, and ensure
that all of them have argument validators (and optionally return value
validators).

You can also check automatically that your functions have argument validators
with the
[`@convex-dev/require-argument-validators` ESLint rule](/eslint#require-argument-validators).

If you use HTTP actions, you may want to use an argument validation library like
[Zod](https://zod.dev) to validate that the HTTP request is the shape you
expect.

## Use some form of access control for all public functions

### Why?

Public functions can be called by anyone, including potentially malicious
attackers trying to break your app. If portions of your app should only be
accessible when the user is signed in, make sure all these Convex functions
check that `ctx.auth.getUserIdentity()` is set.

You may also have specific checks, like only loading messages that were sent to
or from the current user, which you'll want to apply in every relevant public
function.

Favoring more granular functions like `setTeamOwner` over `updateTeam` allows
more granular checks for which users can do what.

Access control checks should either use `ctx.auth.getUserIdentity()` or a
function argument that is unguessable (e.g. a UUID, or a Convex ID, provided
that this ID is never exposed to any client but the one user). In particular,
don't use a function argument which could be spoofed (e.g. email) for access
control checks.

### Example

<TSAndJSSnippet
  title="convex/teams.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="accessControl"
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
/>

### How?

Search for `query`, `mutation`, `action`, and `httpAction` in your Convex
codebase, and ensure that all of them have some form of access control.
[Custom functions](https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#custom-functions)
like
[`authenticatedQuery`](https://stack.convex.dev/custom-functions#modifying-the-ctx-argument-to-a-server-function-for-user-auth)
can be helpful.

Some apps use Row Level Security (RLS) to check access to each document
automatically whenever it's loaded, as described in
[this article](https://stack.convex.dev/row-level-security). Alternatively, you
can check access in each Convex function instead of checking access for each
document.

Helper functions for common checks and common operations can also be useful --
e.g. `isTeamMember`, `isTeamAdmin`, `loadTeam` (which throws if the current user
does not have access to the team).

## Only schedule and `ctx.run*` internal functions

### Why?

Public functions can be called by anyone, including potentially malicious
attackers trying to break your app, and should be carefully audited to ensure
they can't be used maliciously. Functions that are only called within Convex can
be marked as internal, and relax these checks since Convex will ensure that
internal functions can only be called within Convex.

### How?

Search for `ctx.runQuery`, `ctx.runMutation`, and `ctx.runAction` in your Convex
codebase. Also search for `ctx.scheduler` and check the `crons.ts` file. Ensure
all of these use `internal.foo.bar` functions instead of `api.foo.bar`
functions.

If you have code you want to share between a public Convex function and an
internal Convex function, create a helper function that can be called from both.
The public function will likely have additional access control checks.

Alternatively, make sure that `api` from `_generated/api.ts` is never used in
your Convex functions directory.

### Examples

<TSAndJSSnippet
  title="convex/teams.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="internal"
  replacements={[
    [/_OMIT_[0-9]+/g, ""],
    [
      "// REPLACE_WITH_MUTATION_CTX_IMPORT",
      "import { MutationCtx } from './_generated/server';",
    ],
  ]}
/>

## Use helper functions to write shared code

### Why?

Most logic should be written as plain TypeScript functions, with the `query`,
`mutation`, and `action` wrapper functions being a thin wrapper around one or
more helper function.

Concretely, most of your code should live in a directory like `convex/model`,
and your public API, which is defined with `query`, `mutation`, and `action`,
should have very short functions that mostly just call into `convex/model`.

Organizing your code this way makes several of the refactors mentioned in this
list easier to do.

See the [TypeScript page](/understanding/best-practices/typescript.mdx) for
useful types.

### Example

**❌** This example overuses `ctx.runQuery` and `ctx.runMutation`, which is
discussed more in the
[Avoid sequential `ctx.runMutation` / `ctx.runQuery` from actions](/understanding/best-practices/best-practices.mdx#avoid-sequential-ctxrunmutation--ctxrunquery-calls-from-actions)
section.

<TSAndJSSnippet
  title="convex/users.ts"
  sourceTS={HelperFunctionsTS}
  sourceJS={HelperFunctionsTS}
  snippet="usersWrong"
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
/>

<TSAndJSSnippet
  title="convex/conversations.ts"
  sourceTS={HelperFunctionsTS}
  sourceJS={HelperFunctionsTS}
  snippet="conversationsWrong"
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
/>

**✅** Most of the code here is now in the `convex/model` directory. The API for
this application is in `convex/conversations.ts`, which contains very little
code itself.

<TSAndJSSnippet
  title="convex/model/users.ts"
  sourceTS={HelperFunctionsTS}
  sourceJS={HelperFunctionsTS}
  snippet="usersCorrect"
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
  prefix={`import { QueryCtx } from '../_generated/server';\n`}
/>

<TSAndJSSnippet
  title="convex/model/conversations.ts"
  sourceTS={HelperFunctionsTS}
  sourceJS={HelperFunctionsTS}
  snippet="conversationsModelCorrect"
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
  prefix={`import { QueryCtx, MutationCtx } from '../_generated/server';\nimport * as Users from './users';\n`}
/>

<TSAndJSSnippet
  title="convex/conversations.ts"
  sourceTS={HelperFunctionsTS}
  sourceJS={HelperFunctionsTS}
  snippet="conversationsApiCorrect"
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
  prefix={`import * as Conversations from './model/conversations';\n`}
/>

## Use `runAction` only when using a different runtime

### Why?

Calling `runAction` has more overhead than calling a plain TypeScript function.
It counts as an extra function call with its own memory and CPU usage, while the
parent action is doing nothing except waiting for the result. Therefore,
`runAction` should almost always be replaced with calling a plain TypeScript
function. However, if you want to call code that requires Node.js from a
function in the Convex runtime (e.g. using a library that requires Node.js),
then you can use `runAction` to call the Node.js code.

### Example

<TSAndJSSnippet
  title="convex/scrape.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="runAction"
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
/>

<TSAndJSSnippet
  title="convex/model/scrape.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="scrapeModel"
  prefix={`import { ActionCtx } from '../_generated/server';\n`}
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
/>

<TSAndJSSnippet
  title="convex/scrape.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="scrapeAction"
  prefix={`import * as Scrape from './model/scrape';\n`}
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
/>

### How?

Search for `runAction` in your Convex codebase, and see if the function it calls
uses the same runtime as the parent function. If so, replace the `runAction`
with a plain TypeScript function. You may want to structure your functions so
the Node.js functions are in a separate directory so it's easier to spot these.

## Avoid sequential `ctx.runMutation` / `ctx.runQuery` calls from actions

### Why?

Each `ctx.runMutation` or `ctx.runQuery` runs in its own transaction, which
means if they're called separately, they may not be consistent with each other.
If instead we call a single `ctx.runQuery` or `ctx.runMutation`, we're
guaranteed that the results we get are consistent.

### How?

Audit your calls to `ctx.runQuery` and `ctx.runMutation` in actions. If you see
multiple in a row with no other code between them, replace them with a single
`ctx.runQuery` or `ctx.runMutation` that handles both things. Refactoring your
code to use helper functions will make this easier.

### Example: Queries

<TSAndJSSnippet
  title="convex/teams.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="runQueryWrong"
/>

<TSAndJSSnippet
  title="convex/teams.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="runQueryCorrect"
  prefix={`import * as Teams from './model/teams';\nimport * as Users from './model/users';\n`}
/>

### Example: Loops

<TSAndJSSnippet
  title="convex/teams.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="runMutationWrong"
  prefix={`import * as Users from './model/users';\n`}
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
/>

<TSAndJSSnippet
  title="convex/teams.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="runMutationCorrect"
  prefix={`import * as Users from './model/users';\n`}
  replacements={[
    [/\sOMIT_ME.*/g, ""],
    [/_OMIT_[0-9]+/g, ""],
  ]}
/>

### Exceptions

If you're intentionally trying to process more data than fits in a single
transaction, like running a migration or aggregating data, then it makes sense
to have multiple sequential `ctx.runMutation` / `ctx.runQuery` calls.

Multiple `ctx.runQuery` / `ctx.runMutation` calls are often necessary because
the action does a side effect in between them. For example, reading some data,
feeding it to an external service, and then writing the result back to the
database.

## Use `ctx.runQuery` and `ctx.runMutation` sparingly in queries and mutations

### Why?

While these queries and mutations run in the same transaction, and will give
consistent results, they have extra overhead compared to plain TypeScript
functions. Wanting a TypeScript helper function is much more common than needing
`ctx.runQuery` or `ctx.runMutation`.

### How?

Audit your calls to `ctx.runQuery` and `ctx.runMutation` in queries and
mutations. Unless one of the exceptions below applies, replace them with a plain
TypeScript function.

### Exceptions

- If you're using components, these require `ctx.runQuery` or `ctx.runMutation`.
- If you want partial rollback on an error, you will want `ctx.runMutation`
  instead of a plain TypeScript function.

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="partialRollback"
/>

## Always include the table name when calling `ctx.db` functions

### Why?

Since version 1.31.0 of the `convex` NPM package, the `ctx.db` functions accept
a table name as the first argument. While this first argument is currently
optional, passing the table name adds an additional safeguard which will be
required for custom ID generation in the future.

### Example

<TSAndJSSnippet
  title="convex/movies.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="explicitTableIds"
/>

### How?

Search for calls of `db.get`, `db.patch`, `db.replace` and `db.delete` in your
Convex codebase, and ensure that all of them pass a table name as the first
argument.

You can also check automatically that a table name argument is passed with the
[`@convex-dev/explicit-table-ids` ESLint rule](/eslint#explicit-table-ids).

You can migrate existing code automatically by using the autofix in the ESLint
rule, or with the `@convex-dev/codemod` standalone tool.

[Learn more on news.convex.dev →](https://news.convex.dev/db-table-name/)

## Don’t use `Date.now()` in queries \{#date-in-queries}

### Why?

When you subscribe to a query, Convex
[will automatically run it again](/realtime) if the data that it accesses in the
database change. The query is not re-run when `Date.now()` changes, because it
wouldn’t be desirable to re-run a query every millisecond. So, if your query
depends on the current time, it might return stale results.

Also, using `Date.now()` in a query can cause the Convex query cache to be
invalidated more frequently than necessary. In general, Convex will
automatically re-use Convex query results if the query is called with the same
arguments. However, when using `Date.now()` in a query, the query cache will be
invalidated frequently in order to avoid showing results that are too old. This
will unnecessarily increase the work that the database has to do.

### Example

<TSAndJSSnippet
  title="convex/posts.ts"
  sourceTS={BestPracticesTS}
  sourceJS={BestPracticesTS}
  snippet="dateInQueries"
/>

### How?

Search for usages of `Date.now()` in your Convex queries, or in functions that
are called from a Convex query.

If you want to compare the current time with a timestamp stored in a database
document, consider adding a coarser field to the document that you update from a
[scheduled function](/scheduling/scheduled-functions) (see the example above).
This way, the query cache is only invalidated explicitly when data changes.

Alternatively, you can pass in the target time in as an explicit argument from
the client. For best caching results, the client should avoid changing this
argument frequently, for instance by rounding the time down to the most recent
minute, so all client requests within that minute use the same arguments.



================================================
FILE: npm-packages/docs/docs/understanding/best-practices/other-recommendations.mdx
================================================
---
title: "Other Recommendations"
sidebar_position: 170
sidebar_class_name: "hidden"
pagination_next: null
description:
  "Additional Convex development recommendations including TypeScript usage,
  helper functions, database patterns, and UI optimization techniques."
---

import UserHelpers from "!!raw-loader!@site/../private-demos/snippets/convex/userHelpers.ts";
import UserHelpersJS from "!!raw-loader!@site/../private-demos/snippets/convex/userHelpersJS.js";
import Teams from "!!raw-loader!@site/../private-demos/snippets/convex/bestPracticesHelpersTeams.ts";
import TeamsJS from "!!raw-loader!@site/../private-demos/snippets/convex/bestPracticesHelpersTeamsJS.js";

{/* This page was previously the Best Practices page which has been rewritten */}
{/* with some of this content dropped. We are keeping this as a hidden page that is */}
{/* still scrape-able */}

Here's a collection of our recommendations on how best to use Convex to build
your application. If you want guidance specific to your app's needs or have
discovered other ways of using Convex,
[message us on Discord](https://convex.dev/community)!

## Use [TypeScript](/understanding/best-practices/typescript.mdx)

All Convex libraries have complete type annotations and using theses types is a
great way to learn the framework.

Even better, Convex supports [code generation](/generated-api/) to create types
that are specific to your app's [schema](/database/schemas.mdx) and
[Convex functions](/functions.mdx).

Code generation is run automatically by
[`npx convex dev`](/cli.md#run-the-convex-dev-server).

## Check generated code into version control

Inside the convex folder is a `_generated/` directory containing code customized
to your convex functions. Check this folder in to your git repo. That way your
code will typecheck without needing to run `npx convex codegen` or
`npx convex dev` (which includes codegen) first.

This also allows developers to make changes to a project that uses convex by
running it against the production deployment by setting an environment variable,
without ever needing to run the Convex CLI tool. To run against a production
deployment set an environment variable like VITE_CONVEX_URL (the exact variable
name depends on the framework you use) to a production deployment URL like
`https://happy-otter-123.convex.cloud` found in project's production deployment
settings in the dashboard. Most frameworks search for variables like this in a
file called `.env` or `.env.production`.

## Functions

### Use [argument validation](/functions/validation.mdx) in all public functions.

Argument validation prevents malicious users from calling your functions with
the wrong types of arguments. It's okay to skip argument validation for
[internal functions](/functions/internal-functions.mdx) because they are not
publicly accessible.

### Use `console.log` to debug your Convex functions.

All server-side logs from Convex functions are shown on the
[dashboard Logs page](/dashboard/deployments/logs.md). If a server-side
exception occurs, it will also be logged as an error event.

On a **dev deployment** the logs will also be forwarded to the client and will
show up in the browser developer tools Console for the user who invoked the
function call, including full server error messages and server-side stack
traces.

### Use helper functions to write shared code.

Write helper functions in your `convex/` directory and use them within your
Convex functions. Helpers can be a powerful way to share business logic,
authorization code, and more.

Helper functions allow sharing code while still executing the entire query or
mutation in a single transaction. For actions, sharing code via helper functions
instead of using `ctx.runAction` reduces function calls and resource usage.

See the [TypeScript page](/understanding/best-practices/typescript.mdx) for
useful types.

<TSAndJSSnippet sourceTS={Teams} sourceJS={TeamsJS} title="convex/teams.js" />

<TSAndJSSnippet
  sourceTS={UserHelpers}
  sourceJS={UserHelpersJS}
  title="convex/userHelpers.js"
  snippet="userHelpers"
  suffix={`}`}
/>

### Prefer queries and mutations over actions

You should generally avoid using actions when the same goal can be achieved
using queries or mutations. Since actions can have side effects, they can't be
automatically retried nor their results cached. Actions should be used in more
limited scenarios, such as calling third-party services.

## Database

### Use indexes or paginate all large database queries.

[Database indexes](/database/reading-data/indexes/indexes.md) with
[range expressions](/database/reading-data/indexes/indexes.md#querying-documents-using-indexes)
allow you to write efficient database queries that only scan a small number of
documents in the table. [Pagination](/database/pagination.mdx) allows you to
quickly display incremental lists of results. If your table could contain more
than a few thousand documents, you should consider pagination or an index with a
range expression to ensure that your queries stay fast.

For more details, check out our
[Introduction to Indexes and Query Performance](/database/reading-data/indexes/indexes-and-query-perf.md)
article.

### Use tables to separate logical object types.

Even though Convex does support nested documents, it is often better to put
separate objects into separate tables and use `Id`s to create references between
them. This will give you more flexibility when loading and
[querying documents](/database/reading-data/reading-data.mdx).

You can read more about this at [Document IDs](/database/document-ids.mdx).

## UI patterns

### Check for `undefined` to determine if a query is loading.

The [`useQuery` React hook](/api/modules/react#usequery) will return `undefined`
when it is first mounted, before the query has been loaded from Convex. Once a
query is loaded it will never be `undefined` again (even as the data reactively
updates). `undefined` is not a valid return type for queries (you can see the
types that Convex supports at [Data Types](/database/types.md))

You can use this as a signal for when to render loading indicators and
placeholder UI.

### Add optimistic updates for the interactions you want to feel snappy.

By default all relevant `useQuery` hooks will update automatically after a
mutation is synced from Convex. If you would like some interactions to happen
even faster, you can add
[optimistic updates](/client/react/optimistic-updates.mdx) to your `useMutation`
calls so that the UI updates instantaneously.

### Use an exception handling service and error boundaries to manage errors.

Inevitably, your Convex functions will have bugs and hit exceptions. If you have
an exception handling service and error boundaries configured, you can ensure
that you hear about these errors and your users see appropriate UI.

See [Error Handling](/functions/error-handling/error-handling.mdx) for more
information.



================================================
FILE: npm-packages/docs/docs/understanding/best-practices/typescript.mdx
================================================
---
title: "TypeScript"
sidebar_position: 80
description: "Move faster with end-to-end type safety"
pagination_next: null
---

import ArgValidation from "!!raw-loader!@site/../private-demos/snippets/convex/typescriptWithValidation.ts";
import WithSchema from "!!raw-loader!@site/../private-demos/snippets/convex/typescriptWithSchema.ts";
import WithoutArgValidation from "!!raw-loader!@site/../private-demos/snippets/convex/typescriptWithoutValidation.ts";
import ClientDatabaseTypes from "!!raw-loader!@site/../private-demos/snippets/src/typescriptClientDatabaseTypes.tsx";
import ContextTypes from "!!raw-loader!@site/../private-demos/snippets/convex/typescriptContextTypes.ts";
import FunctionReturnTypes from "!!raw-loader!@site/../private-demos/snippets/src/typescriptFunctionReturnTypes.ts";
import ValidatorTypes from "!!raw-loader!@site/../private-demos/snippets/convex/typescriptValidatorTypes.ts";
import SystemFieldsTypes from "!!raw-loader!@site/../private-demos/snippets/convex/typescriptSystemFieldsTypes.ts";

Convex provides end-to-end type support when Convex functions are written in
[TypeScript](https://www.typescriptlang.org/).

You can gradually add TypeScript to a Convex project: the following steps
provide progressively better type support. For the best support you'll want to
complete them all.

**Example:**
[TypeScript and Schema](https://github.com/get-convex/convex-demos/tree/main/typescript)

## Writing Convex functions in TypeScript

The first step to improving type support in a Convex project is to writing your
Convex functions in TypeScript by using the `.ts` extension.

If you are using [argument validation](/functions/validation.mdx), Convex will
infer the types of your functions arguments automatically:

<Snippet title="convex/sendMessage.ts" source={ArgValidation} />

Otherwise you can annotate the arguments type manually:

<Snippet
  title="convex/sendMessage.ts"
  source={WithoutArgValidation}
  highlightPatterns={["body: string"]}
/>

This can be useful for [internal functions](/functions/internal-functions.mdx)
accepting complicated types.

If TypeScript is installed in your project `npx convex dev` and
`npx convex deploy` will typecheck Convex functions before sending code to the
Convex backend.

Convex functions are typechecked with the `tsconfig.json` in the Convex folder:
you can modify some parts of this file to change typechecking settings, or
delete this file to disable this typecheck.

You'll find most database methods have a return type of `Promise<any>` until you
add a schema.

## Adding a schema

Once you [define a schema](/database/schemas.mdx) the type signature of database
methods will be known. You'll also be able to use types imported from
`convex/_generated/dataModel` in both Convex functions and clients written in
TypeScript (React, React Native, Node.js etc.).

The types of documents in tables can be described using the
[`Doc`](/generated-api/data-model#doc) type from the generated data model and
references to documents can be described with parametrized
[Document IDs](/database/document-ids.mdx).

<Snippet title="convex/messages.ts" source={WithSchema} />

## Type annotating server-side helpers

When you want to reuse logic across Convex functions you'll want to define
helper TypeScript functions, and these might need some of the provided context,
to access the database, authentication and any other Convex feature.

Convex generates types corresponding to documents and IDs in your database,
`Doc` and `Id`, as well as `QueryCtx`, `MutationCtx` and `ActionCtx` types based
on your schema and declared Convex functions:

<Snippet title="convex/helpers.ts" source={ContextTypes} />

### Inferring types from validators

Validators can be reused between
[argument validation](/functions/validation.mdx) and
[schema validation](/database/schemas.mdx). You can use the provided
[`Infer`](/api/modules/values#infer) type to get a TypeScript type corresponding
to a validator:

<Snippet title="convex/helpers.ts" source={ValidatorTypes} />

### Document types without system fields

All documents in Convex include the built-in `_id` and `_creationTime` fields,
and so does the generated `Doc` type. When creating or updating a document you
might want use the type without the system fields. Convex provides
[`WithoutSystemFields`](/api/modules/server#withoutsystemfields) for this
purpose:

<Snippet title="convex/helpers.ts" source={SystemFieldsTypes} />

## Writing frontend code in TypeScript

All Convex JavaScript clients, including React hooks like
[`useQuery`](/api/modules/react#usequery) and
[`useMutation`](/api/modules/react#usemutation) provide end to end type safety
by ensuring that arguments and return values match the corresponding Convex
functions declarations. For React, install and configure TypeScript so you can
write your React components in `.tsx` files instead of `.jsx` files.

Follow our [React](/quickstart/react.mdx) or [Next.js](/quickstart/nextjs.mdx)
quickstart to get started with Convex and TypeScript.

### Type annotating client-side code

When you want to pass the result of calling a function around your client
codebase, you can use the generated types `Doc` and `Id`, just like on the
backend:

<Snippet title="src/App.tsx" source={ClientDatabaseTypes} />

You can also declare custom types inside your backend codebase which include
`Doc`s and `Id`s, and import them in your client-side code.

You can also use `WithoutSystemFields` and any types inferred from validators
via `Infer`.

#### Using inferred function return types

Sometimes you might want to annotate a type on the client based on whatever your
backend function returns. Beside manually declaring the type (on the backend or
on the frontend), you can use the generic `FunctionReturnType` and
`UsePaginatedQueryReturnType` types with a function reference:

<Snippet title="src/Components.tsx" source={FunctionReturnTypes} />

## Turning `string`s into valid document IDs

See [Serializing IDs](/database/document-ids.mdx#serializing-ids).

## Required TypeScript version

Convex requires TypeScript version
[5.0.3](https://www.npmjs.com/package/typescript/v/5.0.3) or newer.

<StackPosts query="types" />



================================================
FILE: npm-packages/docs/src/plugins/zoom-vanilla/README.md
================================================
Forked from https://github.com/spinningarrow/zoom-vanilla.js

## License

The MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



================================================
FILE: npm-packages/js-integration-tests/README.md
================================================
# Integration Tests

These tests use the `ConvexHttpClient` and `ConvexReactClient` to talk to a real
backend.

Run `just test` from this directory to run a rush build, and then run
integration tests.

Once that's done, you can run `just _test` during subsequent iterations if
you're only modifying the test suite. This will speed things up as it does not
rerun the rush build, it only spins up a backend and re-runs the test suite.

## Run individual test files

```sh
just test someFile.test.ts
just _test conductor-debug someFile.test.ts
```

Remember that your file name needs to end in `.test.ts` or `.test.tsx`.

## State and Concurrency

Because all of these tests run against the same backend, there is a large risk
of leaking state between tests.

To solve this we:

1. Set Jest's `maxWorkers` to 1 so only 1 test runs at a time.
2. Have a `cleanUp` mutation that deletes all data after each test.

To ensure that `cleanUp` is complete, make sure to:

1. Add it to every new suite.
2. Put all new table names in `schema.ts:ALL_TABLE_NAMES` so we clear the table
   after every test.



================================================
FILE: npm-packages/js-integration-tests/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/node-executor/README.md
================================================
This package contains source code to be executed in node (possibly on AWS).

# To run

Run backend locally (eg via `just run-local-backend`) Deploy code (eg via
`just convex deploy`) Run a function (eg via `just convex run` or by starting up
the UI of a demo and using it) The backend logs emits a `node` command which you
can rerun manually to speed up the edit-test-run loop.

`just run-conductor-aws-wasteland` - to run on AWS lambda in wasteland testing
acct



================================================
FILE: npm-packages/package-tests/README.md
================================================
Tests based on the convex tarball by using "injected": true in the package.json.

This might be able to replace package-tests.



================================================
FILE: npm-packages/private-demos/README.md
================================================
Demos used for manual or automatic regression testing, but not published to
https://github.com/get-convex/convex-demos.

Demos in this directory might be incomplete or demonstrate patterns we don't
want users to follow.



================================================
FILE: npm-packages/private-demos/actions/README.md
================================================
Demonstrates using actions (functions with side effects) on Convex.



================================================
FILE: npm-packages/private-demos/actions/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/bundle-size/README.md
================================================
A simple project that imports everything we expect users to import, for checking
bundle size in bundlers.

Use https://bundle-buddy.com to view the output of each bundler.



================================================
FILE: npm-packages/private-demos/bundle-size/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/cjs-typescript/README.md
================================================
This is a no-bundle TypeScript Node.js project which uses esbuild to compile the
index files.

It demonstrates

- properly typed imports of library code from module and commonjs TypeScript
  files with `"module": "node16"` and `"moduleResolution": "node"`
- runtime importing library code from compiled CJS JavaScript files
- CJS code generation via `npx convex codegen --commonjs`
- propertly typed imports of CJS codegen'd code
- runtime importing generated code `convex/_generated`

Using TypeScript to compile the project does not work: `tsc` compiles too many
files and changes the relative locations of convex/ functions.

Deploying functions with the command line requires extra steps: codegen may need
to be re-run `npx convex codegen --commonjs` after deploying. This project
cannot use `just convex dev` because that command will continue to generate
non-commonjs code.



================================================
FILE: npm-packages/private-demos/cjs-typescript/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/clerk-initial-auth/README.md
================================================
# Users and Authentication Example App

This example demonstrates how to add users and authentication to a basic chat
app. It uses [Clerk](https://clerk.dev/) for authentication.

Users are initially presented with a "Log In" button. After user's log in, their
information is persisted to a `users` table. When users send messages, each
message is associated with the user that sent it. Lastly, users can log out with
a "Log Out" button.

## Running the App

```sh
npm run dev
```

### Using your own Clerk instance

Follow the instructions in https://docs.convex.dev/auth/clerk#get-started to
obtain:

- A _publishable key_, use it in `main.tsx`
- A JWT template Issuer URL, use it in `auth.config.ts`.



================================================
FILE: npm-packages/private-demos/clerk-initial-auth/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/components-api-import/README.md
================================================
# Component API imports demo

This is a demo of components similar to `components-poc`, but it sets the
`codegen.useApiImports` flag to test that pointing directly to the API that a
component exposes works as expected.



================================================
FILE: npm-packages/private-demos/components-api-import/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/components-api-import-ts/README.md
================================================
# Component API imports demo

This is a demo of components similar to `components-poc`, but it sets the
`codegen.useApiImports` flag to test that pointing directly to the API that a
component exposes works as expected.



================================================
FILE: npm-packages/private-demos/components-api-import-ts/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/components-legacy/README.md
================================================
# Component API imports demo

This is a demo of components similar to `components-poc`, but it sets the
`codegen.useApiImports` flag to test that pointing directly to the API that a
component exposes works as expected.



================================================
FILE: npm-packages/private-demos/components-legacy/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/components-legacy-ts/README.md
================================================
# Component API imports demo

This is a demo of components similar to `components-poc`, but it sets the
`codegen.useApiImports` flag to test that pointing directly to the API that a
component exposes works as expected.



================================================
FILE: npm-packages/private-demos/components-legacy-ts/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/components-npm/README.md
================================================
# NPM components demo

This is a demo of components similar to `components-poc`, but it uses components
that are fetched from NPM instead of components in the monorepo.



================================================
FILE: npm-packages/private-demos/components-npm/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/components-poc/README.md
================================================
# Components example

Run a local backend with components enabled:

```bash
just run-local-backend
```

Run `convex dev` against the local backend (be sure to `just rush build` if
needed):

```bash
just convex dev
```

Try running the demo function:

```bash
just convex run messages:componentTest
```

# In progress

### Bundling

Definitions work but no explicit functions are being sent up so only implicit
exports are working really.

Some confusion around terms ComponentPath, DefinitionPath, etc.

### Authoring a component

When authoring a component a developer needs to

- run `npx component create somewhere/myComponent`

### Codegen

Components need to generate

1. `_generated/server.ts` for its function wrappers like mutation() generated
   specifically for

   - the parameters of the component definition, (use analysis)
   - the component definition's schema (could be a type import?)
   - the component definitions's child components (use analysis)

2. `_generated/api.ts` for functions to call and schedule other functions. This
   could just be the old lazy api since this isn't imported in the component
   definition.

3. `_generated/component.ts` for the types for `defineComponent` that wil be
   used by componentDefinitions? This will be an autocompletion stumbling block
   no worse than for implementations.

None of these are implemented yet.

For codegen we need a notion of "these components are part of this project; we
are responsible for runnign codegen for them.

When importing a component definition from another package we should consider it
"frozen;' it's read-only, and when we analyze it, we don't need to generate any
code to "fix" the types.

# TODOs removed from public code

Play with npm packaging

> // TODO It will be important when developers write npm package components //
> for these to use a specific entry point or specific file name? // I guess we
> can read the files from the filesystem ourselves! // If developers want to
> import the component definition directly // from somewhere else,

> is the `const candidates = [args.path]` logic really necessary?

Allow transistive imports of component definitions

> // TODO compress these inputs so that everything that is not a
> convex.config.ts has its dependencies compacted down. // Until then we just
> let these missing links slip through.

> I'd like to move all the bundling logic into the existing bundler code // TODO
> These should all come from ../../../bundler/index.js, at least helpers.

And besides, the error reporting code is duplicated

> // TODO In theory we should get exactly the same errors here as we did the
> first time. Do something about that. // TODO abstract out this esbuild wrapper
> stuff now that it's in two places

Node.js bundles

> // TODO Node compilation (how will Lambdas even work?) const \_nodeResult = {
> bundles: [], externalDependencies: new Map(), bundledModuleNames: new Set(),
> };

registerEsbuildReads needs to be stretched out between the two esbuild
invocations! Changes to the component definition dep tree will not be picked up
or invalidated.

in components.ts

> // TODO // Note we need to restart this whole process if any of these files
> change! // We should track these separately if we can: if any thing observed
> // by the definition traversal changes we need to restart at an earlier //
> point than if something in one of the implementations changes. // If one of
> the implementions changes we should be able to just rebuild that.

Gather push dependencies without doing an inadvertent bundle

> // Note that it bundles!!! That's a step we don't need. const { config:
> localConfig } = await configFromProjectConfig(



================================================
FILE: npm-packages/private-demos/components-poc/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/components-ts-alias/README.md
================================================
# Component TS Alias demo

This is a demo of components similar to `components-poc`, but it uses a TS alias
to point to the component, to make sure we can resolve this when evaluating the
convex.config.ts, as well as at runtime.



================================================
FILE: npm-packages/private-demos/components-ts-alias/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/convex-tour-chat-tutorial/README.md
================================================
# Convex Tour Chat

# This Convex Tour Chat is used to populate the modules.json for the onboarding tutorial

This is a sample app used in the convex tutorial to show off the fundamentals of
the Convex platform.

[Go check out the tutorial](https://convex.dev/start)

Jump into any particular step of the tutorial with a branch:

1.  Simple chat app with message display order bug (branch = main, 0-start)
1.  Simple chat app with correct message display (branch = 1-bugfix)
1.  Enhanced chat app a "likes" feature added (branch = 2-likes)
1.  Enhanced chat app with an AI integration (branch = 3-ai)

# To run

    $ npm i
    $ npm run dev



================================================
FILE: npm-packages/private-demos/convex-tour-chat-tutorial/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/cron/README.md
================================================
# Scheduling Example App

This app provides a basic example of how to use Convex scheduling. It allows the
user to type send a messages that we'll delete ever 10s or something.
[tutorial](https://github.com/get-convex/convex/tree/main/npm-packages/demos/tutorial).

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/private-demos/cron/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/deploy-speed-test/README.md
================================================
# Deploy Speed Test

Used for benchmarking CLI deploy speed.

Run this against production to get more realistic numbers.

Install "Network Link Conditioner" on Mac to try slower network speeds.
https://forums.developer.apple.com/forums/thread/690358 which doesn't work on
localhost

Try commands like this:

```
python generate-project.py --node-files 10 --v8-files 10 --file-size 10000; du -sh convex; time npx convex dev --once
```



================================================
FILE: npm-packages/private-demos/http/README.md
================================================
# Convex HTTP actions

Demonstrates defining custom HTTP actions that talk to Convex (e.g. to hook up
to a webhook).

```
curl -v 'http://127.0.0.1:8001/getMessagesByAuthor?authorNumber=123'
curl -v -d '{ "author": "User 123", "body": "Hello world" }' \
    -H 'content-type: application/json' 'http://127.0.0.1:8001/postMessage'
```



================================================
FILE: npm-packages/private-demos/http/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/javascript/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/javascript-old-syntax/README.md
================================================
# JavaScript Old Syntax

Checks that syntax like `useQuery('listMessages')` still works, even though
there are no TypeScript types for this syntax.



================================================
FILE: npm-packages/private-demos/javascript-old-syntax/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/middleware/README.md
================================================
# Middleware

Writing middleware in JavaScript is pretty easy, but writing middleware that
preserves types is tricky. We implement some middleware in the monorepo to
better understand the effect of changes in client APIs, in particular types.

# Types of middleware

Implementing custom behavior in JavaScript is pretty easy, it's preserving the
types that makes this difficult.

### Custom hooks in React

Now that useQuery is not generated code custom hooks should be reusable.

The tricky bit is dealing with the variadicity of these hooks in TypeScript.

```ts
let x = useQuery("listMessages");
let x = useQuery("listMessages", {}); // allowed
let x = useQuery("listMessages", undefined); // allowed
let x = useQuery("listMessagesForChannel", { channel: 17 });
let x = useQuery("listMessagesForChannel"); // type error
```

We have two options for implementing these:

- Overload (write two more specific signatures for) `useQuery<QueryReference>`
  for queries with empty and non-empty args
- Rest arg that may have one or zero elements

Both of these work poorly. We have these type tests here for comparing them.

We could encourage custom hooks to wrap the non-variadic `useQueries` instead,
applying -- although this breaks composition.

We could demonstrate how to cheat the types; it's ok if types break when
_writing_ middleware as long as the experience of _using_ the hooks is good.

### Custom wrappers on the backend

Our code-generated wrappers like `query`, `mutation`, and `action` should be
able to be extended and these extensions should be composeable. Middleware
should be able to:

- modify the .input validator (influencing the type of the handler)
- add an input validator if one was not already set
- write code that wraps the function (wraps it in a try/catch, modifies input
  and output, runs it twice, whatever)
- access the ctx (e.g. validate that a DB record exists) in the before and after
  code
- write code that modifies the result of the function
- compose arbitrarily other middleware

Maybe we want other things

- set new metadata on the function?

Complicated things like

```ts
import { mutation } from "./_generated/server";
const myMutWrapper = withSession(withUser(withCustomerCtx(mutation)))
export myMut = myMutWrapper({
  input: { a: v.string() },
  openAPIexample: "Run the function like this."
  customContext: { foo: 123 },
  handler: ({ user, session, foo }, { a, addedByAWrapper }) => { ... }
}]
```

There are a few ways to wrap Convex functions:

```ts
wrapTheImpl = mutation(modifyTheFunction((ctx, { a: number }) => {}));
wrapTheImpl2 = mutation({
  args: { a: v.number() },
  handler: modifyTheFunction((ctx, { a: number }) => {})
}
wrapTheMutation = modifyTheMutation(mutation((ctx, { a: number }) => {}));
wrapTheMutation2 = modifyTheMutation(mutation({
  args: { a: v.number() },
  handler: (ctx, { a: number }) => {}
}
wrapTheWrapper = modifyTheMutation(mutation)((ctx, { a: number }) => {});
```

We should probably choose one of these to endorse.

Ian say's it's been convenient to run wrappers at definition site instead of
using the `wrapTheWrapper` approach so he can mix and match middleware.

`wrapTheImpl2` isn't generally as powerful: you can't modify args and other
metadata with it.

I wonder if with the `wrapTheMutation` approach it's even possible to influence
the inferred signature of the function. It looks like it wouldn't be? But you
could annotate the return type of mutation() and that could do it.

Ian reports that the `wrapTheMutation1` approach fails to infer the context
type, but `wrapTheMutation2` is fine.

That leaves wrapTheMutation1 and wraptheImpl1.

# Instructions for writing middleware?



================================================
FILE: npm-packages/private-demos/middleware/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/nextjs-15-app/README.md
================================================
This is a [Next.js](https://nextjs.org) project bootstrapped with
[`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the
result.

You can start editing the page by modifying `app/page.tsx`. The page
auto-updates as you edit the file.

This project uses
[`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts)
to automatically optimize and load [Geist](https://vercel.com/font), a new font
family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js
  features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out
[the Next.js GitHub repository](https://github.com/vercel/next.js) - your
feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the
[Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme)
from the creators of Next.js.

Check out our
[Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying)
for more details.



================================================
FILE: npm-packages/private-demos/nextjs-15-app/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/nextjs-15-app-clerk/README.md
================================================
Next.js 15 with Clerk.

Client and server auth. Server-rendered components and client-rendered
components. Next.js-style manual SSR with preloadQuery and usePreloadedQuery.



================================================
FILE: npm-packages/private-demos/nextjs-15-app-clerk/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/nextjs-app-router-snippets/README.md
================================================
# Convex + Next.js SSR

This demo shows how to use the Convex Next.js integration to preload data for
Client Components during server rendering, and query and mutate data from Server
Actions or Route Handlers (API Routes).

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/private-demos/nextjs-app-router-snippets/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/npm-showcase/README.md
================================================
# NPM Showcase

This demonstrates NPM modules that we can support and a small demo of their
support in Node actions.



================================================
FILE: npm-packages/private-demos/npm-showcase/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/openauth-react/README.md
================================================
# OpenAuth with Convex Custom JWT Auth Demo

This is an example of running OpenAuth server(s) to authenticate Convex
WebSocket connections to a Convex deployment.

This example only works against a local backend because server that hosts the
.well-known/jwks.json endpoint that the Convex deployment must hit is hosted
locally in this example at localhost:3000.

A setup that worked for production or cloud development would look similar but
with these OpenAuth servers hosted at domains accessible from the public
internet.

---

You need three servers to run this demo. The first is the web UI:

```bash
bun run dev
```

Then visit `http://localhost:5173` in your browser.

You'll need to run Convex; in the monorepo, run

```bash
just run-local-backend
```

It needs the OpenAuth server running at `http://localhost:3000`. Start it with

```bash
bun run --hot issuer.ts
```

Start a JWT API running to get the user subject on `http://localhost:3001`.

```bash
bun run --hot jwt-api.ts
```



================================================
FILE: npm-packages/private-demos/openauth-react/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/pagination-adversarial/README.md
================================================
# Pagination Example App

This app provides a basic pagination example. A cron inserts items frequently,
so we can test pages growing unboundedly.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/private-demos/pagination-adversarial/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/pagination-visualization/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/README.md
================================================
These projects are not in rush.json to better approximate the way developers
would use them. Just `npm install` them.



================================================
FILE: npm-packages/private-demos/quickstarts/bun/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/expo/README.md
================================================
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with
[`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app
  development with Expo

You can start developing by editing the files inside the **app** directory. This
project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and
create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following
resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into
  advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a
  step-by-step tutorial where you'll create a project that runs on Android, iOS,
  and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform
  and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask
  questions.



================================================
FILE: npm-packages/private-demos/quickstarts/expo/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/nextjs/README.md
================================================
This is a [Next.js](https://nextjs.org/) project bootstrapped with
[`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the
result.

You can start editing the page by modifying `pages/index.js`. The page
auto-updates as you edit the file.

[API routes](https://nextjs.org/docs/api-routes/introduction) can be accessed on
[http://localhost:3000/api/hello](http://localhost:3000/api/hello). This
endpoint can be edited in `pages/api/hello.js`.

The `pages/api` directory is mapped to `/api/*`. Files in this directory are
treated as [API routes](https://nextjs.org/docs/api-routes/introduction) instead
of React pages.

This project uses
[`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to
automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js
  features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out
[the Next.js GitHub repository](https://github.com/vercel/next.js/) - your
feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the
[Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme)
from the creators of Next.js.

Check out our
[Next.js deployment documentation](https://nextjs.org/docs/deployment) for more
details.



================================================
FILE: npm-packages/private-demos/quickstarts/nextjs/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/nextjs-app-dir/README.md
================================================
This is a [Next.js](https://nextjs.org) project bootstrapped with
[`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the
result.

You can start editing the page by modifying `app/page.tsx`. The page
auto-updates as you edit the file.

This project uses
[`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts)
to automatically optimize and load [Geist](https://vercel.com/font), a new font
family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js
  features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out
[the Next.js GitHub repository](https://github.com/vercel/next.js) - your
feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the
[Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme)
from the creators of Next.js.

Check out our
[Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying)
for more details.



================================================
FILE: npm-packages/private-demos/quickstarts/nextjs-app-dir/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/nextjs-app-dir-14/README.md
================================================
Only needed for an Auth0 Next.js doc sample.



================================================
FILE: npm-packages/private-demos/quickstarts/nextjs-app-dir-14/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/nextjs-app-dir-js/README.md
================================================
This is a [Next.js](https://nextjs.org/) project bootstrapped with
[`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the
result.

You can start editing the page by modifying `app/page.js`. The page auto-updates
as you edit the file.

This project uses
[`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to
automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js
  features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out
[the Next.js GitHub repository](https://github.com/vercel/next.js/) - your
feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the
[Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme)
from the creators of Next.js.

Check out our
[Next.js deployment documentation](https://nextjs.org/docs/deployment) for more
details.



================================================
FILE: npm-packages/private-demos/quickstarts/nextjs-app-dir-js/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/nodejs/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/nuxt/README.md
================================================
# Nuxt Minimal Starter

Look at the [Nuxt documentation](https://nuxt.com/docs/getting-started/introduction) to learn more.

## Setup

Make sure to install dependencies:

```bash
# npm
npm install

# pnpm
pnpm install

# yarn
yarn install

# bun
bun install
```

## Development Server

Start the development server on `http://localhost:3000`:

```bash
# npm
npm run dev

# pnpm
pnpm dev

# yarn
yarn dev

# bun
bun run dev
```

## Production

Build the application for production:

```bash
# npm
npm run build

# pnpm
pnpm build

# yarn
yarn build

# bun
bun run build
```

Locally preview production build:

```bash
# npm
npm run preview

# pnpm
pnpm preview

# yarn
yarn preview

# bun
bun run preview
```

Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more information.



================================================
FILE: npm-packages/private-demos/quickstarts/nuxt/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/react-vite/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/react-vite-ts/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/remix/README.md
================================================
# Welcome to Remix + Vite!

📖 See the [Remix docs](https://remix.run/docs) and the [Remix Vite docs](https://remix.run/docs/en/main/guides/vite) for details on supported features.

## Development

Run the Vite dev server:

```shellscript
npm run dev
```

## Deployment

First, build your app for production:

```sh
npm run build
```

Then run the app in production mode:

```sh
npm start
```

Now you'll need to pick a host to deploy it to.

### DIY

If you're familiar with deploying Node applications, the built-in Remix app server is production-ready.

Make sure to deploy the output of `npm run build`

- `build/server`
- `build/client`



================================================
FILE: npm-packages/private-demos/quickstarts/remix/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/sveltekit/README.md
================================================
# create-svelte

Everything you need to build a Svelte project, powered by
[`create-svelte`](https://github.com/sveltejs/kit/tree/main/packages/create-svelte).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```bash
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or
`pnpm install` or `yarn`), start a development server:

```bash
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```bash
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an
> [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.



================================================
FILE: npm-packages/private-demos/quickstarts/sveltekit/src/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/tanstack-start/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/quickstarts/vue/README.md
================================================
# vue

This template should help get you started developing with Vue 3 in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar) (and disable Vetur).

## Type Support for `.vue` Imports in TS

TypeScript cannot handle type information for `.vue` imports by default, so we replace the `tsc` CLI with `vue-tsc` for type checking. In editors, we need [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar) to make the TypeScript language service aware of `.vue` types.

## Customize configuration

See [Vite Configuration Reference](https://vitejs.dev/config/).

## Project Setup

```sh
npm install
```

### Compile and Hot-Reload for Development

```sh
npm run dev
```

### Type-Check, Compile and Minify for Production

```sh
npm run build
```



================================================
FILE: npm-packages/private-demos/quickstarts/vue/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/rust-wasm/README.md
================================================
## WebAssembly notes

Runtimes and bundlers use WebAssembly to produce EcmaScript modules (ESM) in two
different ways.

You've always been able to get the bytes and load them yourself; nothing to do
with ESM here.

```js
// simple, not streaming, not encouraged in browsers
const resp = await fetch("simple.wasm");
const bytes = await resp.arrayBuffer();
const module = WebAssembly.compile(bytes))
const instance = await WebAssembly.instantiate(module, imports)
instance.exports.foo(1, 2, 3);

// fancier, recommended in browsers
const resp = await fetch("simple.wasm");
const instance = WebAssembly.instantiateStreaming(resp, imports);
instance.exports.foo(1, 2, 3);
```

These APIs work everywhere and they've been enough to accomplish a lot with
WebAssembly.

Whenever WebAssembly is used the modules must be compiled into instances and
those instances must be "linked," provided its dependencies in the form of an
object of functions.

```js
const imports = {
  dep1: (a) => a + 1,
  dep2: () => Date.now(),
};
const instance = await WebAssembly.instantiate(module, imports);
instance.exports.foo(1, 2, 3);
```

This linking and instantiation work sounds like a job for modules! How should
they work?

### Instance

The semantics
[originally proposed](https://github.com/WebAssembly/esm-integration/tree/main/proposals/esm-integration)
by WASM folks like Andreas Rossberg are now in stage 2.

Just import a module and it's already instantiated and linked for you!

```js
import * as foo from "./foo.wasm";
foo.bar();
```

This style [has been implemented](https://github.com/nodejs/node/pull/27659)
behind the `--experimental-wasm-modules` flag in Node.js for years, since 12.3
in May of 2019.

You can try this in Node today:

```
$ node --experimental-wasm-modules
> foo = await("foo.wasm")
> foo.bar()
```

This "[asyncWebAssembly](https://webpack.js.org/configuration/experiments/)"
option can be enabled in Webpack will be the default behavior in Webpack 6. We
use this in the dashboard to import Cloudflare's cron parsing library.

The Rust toolchain [wasm-pack](https://rustwasm.github.io/wasm-pack/) generates
code and types that assume this behavior.

There's an
[esbuild plugin that does this](https://github.com/Tschrock/esbuild-plugin-wasm).

There's no movement from V8 on this but WebKit
[has it working behind a flag](https://bugs.webkit.org/show_bug.cgi?id=236268).

### Module

It's been [raised](https://github.com/WebAssembly/esm-integration/issues/14),
[several](https://github.com/WebAssembly/esm-integration/issues/44)
[times](https://github.com/WebAssembly/esm-integration/issues/63) that it's
sometimes useful to work with WebAssembly modules rather than instances.

So what if importing a WebAssembly modules didn't do the linking and
instantiating?

```js
import module from "./foo.wasm";
const instance = WebAssembly.instantiate(module);
instance.exports.bar();
```

This is Cloudflare's
[default behavior](https://developers.cloudflare.com/workers/wrangler/bundling/).

This is what we Convex implements implement with our plugin. We did this to
support @dqbd/tiktoken. In our PR implementing this behavior it's mentioned that
Next works like this, I'm having trouble finding reference to this. In some
bundlers (citation needed) appending the query parameter `?module` to the import
provides this behavior.

A [new proposal](https://github.com/tc39/proposal-source-phase-imports) for
"Source Phase Import" allows explicitly importing the module object. Switching
to this syntax for module object imports will disambiguate standard import
syntax.

```
import source FooModule from "./foo.wasm";
FooModule instanceof WebAssembly.Module; // true
```

## Did we implement the wrong one?

It seems like it, but we have latitude to fix it. We just need to keep
supporting the npm packages we already support. Currently WebAssembly support is
almost certainly only being used in Node.js.

We could support both with configuration, or without configuration we could
require the ?module suffix.

> Question
>
> How do bundlers implement this, do we need to support dynamic imports?

Langchain no longer uses the WebAssembly version of Tiktoken, it now uses
https://www.npmjs.com/package/js-tiktoken

Presumably if we wait long enough V8 will implement this natively.

The cost to our developer users of not implementing the instance approach isn't
clear. I'm annoyed I can't use wasm-bindgen/wasm-pack from Rust, but no customer
has asked for that.

### wasm-bindgen workaround

Until Convex supports bundling this way it's possible to

- wasm-pack build --target bundler // (this is the default target)
- TODO



================================================
FILE: npm-packages/private-demos/snippets/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/static-codegen/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/static-codegen-ts/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/tanstack-start/README.md
================================================
# Using Convex with TanStack Start

Using Convex with TanStack Start provides

- Live-updating queries: updates come in over a WebSocket instead of requiring polling
- Works with TanStack Query `useQuery`, useSuspenseQuery`, etc. hooks
- Automatic query invalidation: when a mutation succeeds all queries it affects update automatically
- Selective optimistic update rollback: when a mutation succeeds only its update will be rolled back, with other optimistic updates reapplied
- Consistent snapshot reads of database state: /messages will never return a foreign key for a /user that doesn't exist until the next fetch

# Examples

### Sibling component calls

During SSR two sibling components make requests at about the same time.

### Subsequent useSuspenseQuery calls

During SSR one component makes one query and then another, as though the second
depended on the first and it was a dependent query (a "waterfall.")



================================================
FILE: npm-packages/private-demos/tanstack-start/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/tanstack-start-clerk/README.md
================================================
# Welcome to TanStack.com!

This site is built with TanStack Router!

- [TanStack Router Docs](https://tanstack.com/router)

It's deployed automagically with Netlify!

- [Netlify](https://netlify.com/)

## Development

From your terminal:

```sh
pnpm install
pnpm dev
```

This starts your app in development mode, rebuilding assets on file changes.

## Editing and previewing the docs of TanStack projects locally

The documentations for all TanStack projects except for `React Charts` are hosted on [https://tanstack.com](https://tanstack.com), powered by this TanStack Router app.
In production, the markdown doc pages are fetched from the GitHub repos of the projects, but in development they are read from the local file system.

Follow these steps if you want to edit the doc pages of a project (in these steps we'll assume it's [`TanStack/form`](https://github.com/tanstack/form)) and preview them locally :

1. Create a new directory called `tanstack`.

```sh
mkdir tanstack
```

2. Enter the directory and clone this repo and the repo of the project there.

```sh
cd tanstack
git clone git@github.com:TanStack/tanstack.com.git
git clone git@github.com:TanStack/form.git
```

> [!NOTE]
> Your `tanstack` directory should look like this:
>
> ```
> tanstack/
>    |
>    +-- form/
>    |
>    +-- tanstack.com/
> ```

> [!WARNING]
> Make sure the name of the directory in your local file system matches the name of the project's repo. For example, `tanstack/form` must be cloned into `form` (this is the default) instead of `some-other-name`, because that way, the doc pages won't be found.

3. Enter the `tanstack/tanstack.com` directory, install the dependencies and run the app in dev mode:

```sh
cd tanstack.com
pnpm i
# The app will run on https://localhost:3000 by default
pnpm dev
```

4. Now you can visit http://localhost:3000/form/latest/docs/overview in the browser and see the changes you make in `tanstack/form/docs`.

> [!NOTE]
> The updated pages need to be manually reloaded in the browser.

> [!WARNING]
> You will need to update the `docs/config.json` file (in the project's repo) if you add a new doc page!



================================================
FILE: npm-packages/private-demos/tanstack-start-clerk/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/tanstack-start-workos/README.md
================================================
# WorkOS + TanStack Start

This demo exists to test WorkOS AuthKit provisioning flows in the Convex CLI:

- Creating an associated WorkOS team + disconnecting this team
- Provisioning an AuthKit environment in dev, preview, and production when a deployment if none exists
- Configuring the AuthKit envirnment and setting local environment variables on dev/deploy



================================================
FILE: npm-packages/private-demos/tanstack-start-workos/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/test-data/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/test-project/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/text-importer/README.md
================================================
All this does is import a ton of text into a table with a text index.

There's some very simply python parsing to extract embeddings specifically from
this file:
https://drive.google.com/file/d/1qRJWC4kiM9xZ-oTbiqK9ii0vPciNHhkI/view?usp=drive_link.
That's a set of embeddings that originated from
https://www.kaggle.com/datasets/stephanst/wikipedia-simple-openai-embeddings
which was MIT licensed at the time it was downloaded.

Download the file from drive or kaggle, extract the archive into a .jsonl file,
then run the script with:

1. `just rush update`
2. `npx convex dev --once`
3. `uv run main <path_to_jsonl>`

You can adapt the python code to parse other formats if you'd like. The main
purpose of this is to test bulk imports, particularly with vectors.



================================================
FILE: npm-packages/private-demos/text-importer/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/tsgo-test/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/tutorial/README.md
================================================
# Convex tutorial

You're just a few minutes away from having a chat app powered by Convex.

Follow the tutorial at
[docs.convex.dev/tutorial](https://docs.convex.dev/tutorial) for instructions.



================================================
FILE: npm-packages/private-demos/typescript-exact-optional-property-types/README.md
================================================
# TypeScript

This is a recent TypeScript version with the tsconfig.json option
`exactOptionalPropertyTypes: true` set.



================================================
FILE: npm-packages/private-demos/typescript-exact-optional-property-types/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/typescript-modern/README.md
================================================
# TypeScript and Schemas Example App

This example demonstrates how to write a Convex app in
[TypeScript](https://docs.convex.dev/using/typescript).

The Convex functions are written in `.ts` files and the React components use
`.tsx`.

This app also defines a Convex
[schema](https://docs.convex.dev/database/schemas) in `convex/schema.ts` to
create TypeScript types specific to the app's data model.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/private-demos/typescript-modern/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/typescript-old/README.md
================================================
Same as demos/typescript, but using older TypeScript settings. Currently the
oldest TypeScript version we support is the same as what's being used everywhere
else (TypeScript 5.0.4) but the tsconfig.json settings are different: in this
project both tsconfig.json files use "moduleResolution": "node", the older style
that doesn't understand package.json exports in libraries among other
shortcomings.



================================================
FILE: npm-packages/private-demos/typescript-old/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/uses-ents/README.md
================================================
# Convex Ents Example

This demo showcases the [Convex Ents](https://labs.convex.dev/convex-ents)
library, which provides an ergonomic layer on top of Convex's database API.

## Features Demonstrated

- **Ent Schema**: Defining entities with relations (edges) between them
- **Unique Fields**: Email and slug fields with uniqueness constraints
- **Relations**: One-to-many and many-to-many relationships
- **Edge Traversal**: Reading related documents using `.edge()` and `.edges()`
- **CRUD Operations**: Creating, reading, updating, and deleting ents
- **Filtering**: Querying ents with filters

## Schema

The example implements a simple blog system with:

- **Users**: Authors with unique emails
- **Posts**: Blog posts with unique slugs, linked to authors
- **Comments**: Comments on posts, linked to both posts and authors
- **Tags**: Tags with unique slugs, many-to-many relationship with posts

## Running the Demo

```bash
just build-js
npm run dev
```



================================================
FILE: npm-packages/private-demos/uses-ents/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/vector-importer/README.md
================================================
All this does is import a ton of vectors into a table with a vector index.

There's some very simply python parsing to extract embeddings specifically from
this file:
https://drive.google.com/file/d/1qRJWC4kiM9xZ-oTbiqK9ii0vPciNHhkI/view?usp=drive_link.
That's a set of embeddings that originated from
https://www.kaggle.com/datasets/stephanst/wikipedia-simple-openai-embeddings
which was MIT licensed at the time it was downloaded.

Download the file from drive or kaggle, extract the archive into a .jsonl file,
then run the script with:

1. `just rush update`
2. `npx convex dev --once`
3. `uv run main <path_to_jsonl>`

You can adapt the python code to parse other formats if you'd like. The main
purpose of this is to test bulk imports, particularly with vectors.



================================================
FILE: npm-packages/private-demos/vector-importer/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/vector-search/README.md
================================================
# Vector search Example App

This example demonstrates how to use Convex vector search.

## Running the App

Run:

```
npm install
npm run dev
```



================================================
FILE: npm-packages/private-demos/vector-search/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/private-demos/waitlist/README.md
================================================
# Convex waitlist

This private demo is going to be used as a playground for #project-modularity
for prototyping "modules" that allow the waitlist functionality to be easily
encapsulated.



================================================
FILE: npm-packages/private-demos/waitlist/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/publishing-tests/README.md
================================================
Test the publishing process and the final artifact.



================================================
FILE: npm-packages/retention-tester/README.md
================================================
## About

retention-tester is a retention torture tester. It inserts fake data into two
tables every N seconds. It then cleans up old data every M minutes. See the
crons.ts file for how frequently these are run.

To turn this off: Ensure there is a single row in the `yield` table with
`doYouYield` set to `true`. You can do this by running the `yield:convexYields`
function.



================================================
FILE: npm-packages/retention-tester/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/scenario-runner/README.md
================================================
Run client-side scenarios driven by load-generator.

# Usage

Run [LoadGenerator](../../crates/load_generator/README.md). LoadGenerator will
provision a backend and start ScenarioRunner with the given parameters.

## Adding new scenarios

To add a new scenario,

1. Name the scenario and add it to `ScenarioName` and the `main` control flow in
   `index.ts`.
2. Write a class that implements the `IScenario` interface and extends the
   `Scenario` class and drop the class in the `scenarios` folder. Run this new
   scenario from the `main` control flow.
3. In LoadGenerator, add a new scenario to the `Scenario` struct.



================================================
FILE: npm-packages/shared-cursors/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/simulation/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/system-udfs/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/system-udfs/convex/_system/cli/README.md
================================================
These UDFs are not used by the dashboard, but they are used by the CLI.

They get deployed with a funrun push, just like the \_system/frontend ones.



================================================
FILE: npm-packages/udf-runtime/README.md
================================================
# UDF Runtime

All of the code the sets up the UDF JS environment for queries and mutations.



================================================
FILE: npm-packages/udf-tests/README.md
================================================
# UDF Tests

A collection of test functions used in testing the isolate layer
(`crates/isolate/src/tests`)



================================================
FILE: npm-packages/udf-tests/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: npm-packages/udf-tests/wasm/README.md
================================================
# WASM tests

This folder has some _very basic_ WASM tests for our V8 runtime. We don't
currently automatically rebuild `main.go` into its `wasmTests.js` binary, so
you'll have to do this manually whenever you make changes. Be sure to have
`tinygo` version `0.33.0` installed.

```bash
go mod tidy
python build.py
```



================================================
FILE: npm-packages/version/README.md
================================================
# version

This Convex project powers the endpoints available at
https://version.convex.dev.

They are used by the CLI to check for updates and to get the latest version of
the `convex` package and Cursor rules. The results are cached in the database.

There is no environment variable or anything else to set up.



================================================
FILE: npm-packages/version/convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: self-hosted/README.md
================================================
<p align="center">
<picture>
  <source media="(prefers-color-scheme: dark)" srcset="https://static.convex.dev/logo/convex-logo-light.svg" width="600">
  <source media="(prefers-color-scheme: light)" srcset="https://static.convex.dev/logo/convex-logo.svg" width="600">
  <img alt="Convex logo" src="https://static.convex.dev/logo/convex-logo.svg" width="600">
</picture>
</p>

If you're new to Convex we recommend starting with the
[onboarding tutorial](https://docs.convex.dev/tutorial/) to familiarize yourself
with the Convex development experience.

If you're in this README, you're interested in self-hosting
[Convex](https://www.convex.dev) on your own infrastructure or a managed hosting
provider. Support is available on the
[Convex Discord](https://discord.gg/convex) in the `#self-hosted` channel.

If you don't specifically want to self-host, head over to
[the Convex docs](https://docs.convex.dev/) to use the cloud-hosted product.
Cloud-hosted Convex includes a generous free tier and provides a seamless,
reliable, cost-effective platform that allows you to focus on building your
application without worrying about infrastructure.

Self-hosting Convex requires deploying three services:

1. The Convex backend
2. The Convex dashboard
3. Your frontend app, which you can either host yourself or on a managed service
   like Netlify or Vercel.

# Self-hosting Convex

By default the Convex backend will store all state in a local SQLite database.
We recommend starting with this basic configuration and then moving the
container to a hosting provider or pointing the backend to a separate SQL
database for a production-ready configuration as needed.

## Docker configuration

First download the
[`docker-compose.yml` file](https://github.com/get-convex/convex-backend/tree/main/self-hosted/docker/docker-compose.yml).
Then, to start the backend and dashboard:

```sh
docker compose up
```

Once the backend is running you can use it to generate admin keys for the
dashboard/CLI:

```sh
docker compose exec backend ./generate_admin_key.sh
```

Visit the dashboard at `http://localhost:6791`. The backend listens on
`http://127.0.0.1:3210`. The backend's http actions are available at
`http://127.0.0.1:3211`.

In your Convex project, add your url and admin key to a `.env.local` file (which
should not be committed to source control):

```sh
CONVEX_SELF_HOSTED_URL='http://127.0.0.1:3210'
CONVEX_SELF_HOSTED_ADMIN_KEY='<your admin key>'
```

Now you can run commands in your Convex project, to push code, run queries,
import data, etc. To use these commands, you'll need the latest version of
Convex.

```sh
npm install convex@latest
```

Now you can push code, run queries, import data, etc.

```sh
npx convex dev
npx convex --help  # see all available commands
```

By default, the backend will store its data in a volume managed by Docker. Note
that you'll need to set up persistent storage on whatever cloud hosting platform
you choose to run the Docker container on (e.g. AWS EBS). By default the
database is stored locally in SQLite but you may also point it to a SQL database
either locally or on a cloud service of your choice following
[these instructions](#running-the-database-on-postgres-or-mysql). You can also
configure the backend to use S3 storage for exports, snapshots, modules, files,
and search indexes following [these instructions](#using-s3-storage).

You should now be able to use the self-hosted backend. Read on for alternative
hosting options for production workloads.

## Convex Auth

If you're using Convex Auth, follow the
[manual instructions](https://labs.convex.dev/auth/setup/manual) to set up. The
CLI does not support self-hosted deployments yet.

# Deploying your frontend app

The Convex backend runs all database and compute functions but it doesn't host
your actual web app. If you're hosting your website on a provider like Netlify
or Vercel using our
[production hosting instructions](https://docs.convex.dev/production/hosting/)
be sure to swap out the environment variables in those instructions for the
`SELF_HOSTED` equivalents.

e.g., instead of setting `CONVEX_DEPLOY_KEY`, you'll need to set
`CONVEX_SELF_HOSTED_URL` to the url where your Convex backend is hosted and
`CONVEX_SELF_HOSTED_ADMIN_KEY` to the admin key you generated with the
`generate_admin_key.sh` script.

## Advanced Configuration

- [Running the binary directly](./advanced/running_binary_directly.md)
- [Hosting on fly.io](./advanced/fly/README.md)
- [Hosting on Railway.com](./advanced/railway/README.md)
- [Hosting on your own servers](./advanced/hosting_on_own_infra.md)
- [Running the database on Postgres or MySQL](./advanced/postgres_or_mysql.md)
- [Storing files in S3 instead of local filesystem](./advanced/s3_storage.md)
- [Running the dashboard locally](./advanced/dashboard.md)
- [Disabling logging features](./advanced/disabling_logging.md)
- [Upgrading Convex self-hosted version](./advanced/upgrading.md)
- [Benchmarking](./advanced/benchmarking.md)
- [Advanced tuning with knobs](./advanced/knobs.md)

# Limitations

Self-hosted Convex supports all the free-tier features of the cloud-hosted
product. The cloud-hosted product is optimized for scale.

# Questions and contributions

- Join our [Discord community](https://discord.gg/convex) for help and
  discussions. The `#self-hosted` channel is the best place to go for questions
  about self-hosting.

- Report issues when building and using the open source Convex backend through
  [GitHub Issues](https://github.com/get-convex/convex-backend/issues)

- We
  [welcome bug fixes](https://github.com/get-convex/convex-backend/blob/main/crates/convex/CONTRIBUTING.md)
  and love receiving feedback. We keep this repository synced with any internal
  development work within a handful of days.



================================================
FILE: self-hosted/CHANGELOG.md
================================================
# Changelog

Find the latest versions of the `convex-backend` package
[here](https://github.com/get-convex/convex-backend/pkgs/container/convex-backend)
and `convex-dashboard` package
[here](https://github.com/get-convex/convex-backend/pkgs/container/convex-dashboard).
Make sure to use the same version of `convex-backend` and `convex-dashboard`.
Different versions are not guaranteed to be compatible with one another.

Follow the instructions in the [README](README.md#software-upgrades) to upgrade
your self-hosted backend and dashboard.

## 2025-09-17

As of ~2025-09-17, we're releasing more frequently, so we're not going to update
this changelog as frequently. Check `git log` for a detailed listing of changes.

## 2025-09-12 `4d3b0a5de955a258e70e3813bbff486051d88820`

- Schema Validation progress on dashboard.
- Improved error messages
- Misc improvements.

## 2025-09-03 `00bd92723422f3bff968230c94ccdeb8c1719832`

- Fix command line / env var configuration flag issue.
- Support AWS credential handling from multiple sources, including IAM. (thanks
  HeathHopkins)
- Support disabling AWS S3 SSE/Checksums for better compatibility with AWS
  compatible services (thanks jovermier)

## 2025-08-27 `08139ef318b1898dad7731910f49ba631631c902`

- Support index backfill progress and staged indexes
- Fix full text search bug where some filters were ignored
- Build database indexes in parallel

## 2025-08-05 `33cef775a8a6228cbacee4a09ac2c4073d62ed13`

- Add support for `AWS_S3_FORCE_PATH_STYLE` (thanks Squipward00 and cayter),
  allowing support for MinIO and DigitalOcean S3-compatible storage.
- Variety of bug fixes and performance improvements to backend

## 2025-07-01 `6efab6f2b6c182b90255774d747328cfc7b80dd9`

- Add support for integrations (axiom/datadog/sentry/fivetran/airbyte) to
  self-hosted
- Fix node actions bug affecting multiple concurrent requests with local node
  executor
- Variety of performance improvements to backend (caching, memory usage, CPU
  usage)

## 2025-05-29 `c1a7ac393888d743e704de56cf569a154b4526d4`

- Fix bug that prevented folks with crons from upgrading existing older
  self-hosted deployments to `478d197d54ee6e873f06cf9e9deae1eb4aa35bb5`.

## 2025-05-23 `478d197d54ee6e873f06cf9e9deae1eb4aa35bb5`

- Tons and tons of backend improvements.
- MCP + Self-hosting works (requires npm package convex >= 1.24.1)
- Speed up pushing to node actions with
  [external packages](https://docs.convex.dev/functions/bundling#external-packages).
- Support setting `CONVEX_CLOUD_ORIGIN`, `CONVEX_SITE_ORIGIN`, and
  `NEXT_PUBLIC_DEPLOYMENT_URL` in .env next to docker compose file. (Thx
  @natac13)
- Add support for CA file for postgres (thx @tahvane1)
- Docs improvements. Incl DevContainer guide (thx @iamfj).

## 2025-03-10 `5143fec81f146ca67495c12c6b7a15c5802c37e2`

- Speed up Node actions by 50x. No more cold starts on every request. See
  [this commit](https://github.com/get-convex/convex-backend/commit/6be386a490909dda5b8fb1c12b6cca25326847c6)
  for more details.

## 2025-03-06 `be8a4f397810ce3d04dc3cb32bc81969fe64685a`

- Add R2 compatibility. See
  https://github.com/get-convex/convex-backend/pull/53.
  [Docs](https://github.com/get-convex/convex-backend/blob/main/self-hosted/README.md#using-s3-storage)
- Tolerate missing or malformed sourcemaps (eg. from `ai` npm library).

## 2025-02-26 `161e32648a971fb8ef591e61212f7b9fb7ff4f2c`

- Add support for S3 storage for exports, snapshots, modules, files, and search
  indexes. Read more on how to set up S3 storage
  [here](README.md#using-s3-storage).

## 2025-02-24 `fff8e431b95f4d9fde899ce348f8e8f23210aad3`

- Support streaming import. Read more on how to set up streaming import
  [here](https://docs.convex.dev/production/integrations/streaming-import-export#streaming-import)
- Fix bug in routing to HTTP actions. Read more
  [here](https://github.com/get-convex/convex-backend/commit/1652ee81d8a01fdeed98b0e4c923a89d1672f8ad).

## 2025-02-19 `86ae5d34c8164075b66fa0c52beabd19212d8df7`

- Fix bug in MySQL where certificates were not verified upon connection. Now,
  you must set `DO_NOT_REQUIRE_SSL` for running locally.

## 2025-02-19 `663640f5a01018914dc4314145f23a31f3afdca6`

- Add support for MySQL! The `DATABASE_URL` env variable is now `POSTGRES_URL`
  or `MYSQL_URL`. Known issue: MySQL certificates are not verified upon
  connection. The next release will include a fix.
- Optimize database queries, so simple mutations get 4x faster when running
  against a Postgres or MySQL db in a different datacenter or region.

## 2025-02-18 `62ef09aa604b0c5f873b59e0944b5e89f84b66b2`

- Add support for running Docker image with local Postgres using the
  `DO_NOT_REQUIRE_SSL` environment variable.

## 2025-02-13 `6c974d219776b753cd23d26f4a296629ff7c2cad`

- Fix a bug where every node action request would write to temporary files that
  were never cleaned up. Caused disk space to fill up on volumes.

## 2025-02-12 `4499dd4fd7f2148687a7774599c613d052950f46`

> ⚠️ **WARNING**: DO NOT use this version in production! This initial release
> contains a critical bug that fills up disk space. Use version
> [6c974d219776b753cd23d26f4a296629ff7c2cad](##6c974d219776b753cd23d26f4a296629ff7c2cad)
> or later.

- Initial release of self-hosted backend and dashboard.



================================================
FILE: self-hosted/advanced/benchmarking.md
================================================
# Benchmarking

Check out our open-source benchmarking tool,
[LoadGenerator](../../crates/load_generator/README.md), for more information on
how to benchmark and load test your Convex instance.



================================================
FILE: self-hosted/advanced/dashboard.md
================================================
## Running the dashboard locally

From the `npm-packages/dashboard-self-hosted` directory, run:

```sh
just rush install
npm run build
NEXT_PUBLIC_DEPLOYMENT_URL="<your-backend-url>" npm run start
```

## Dashboard optional configuration

- The dashboard uses the **monaco-editor** npm package for all the editor-like
  elements. By default, monaco loads it's core from a CDN. You could configure
  it to load internally by setting the `NEXT_PUBLIC_LOAD_MONACO_INTERNALLY`
  environment variable to `true`



================================================
FILE: self-hosted/advanced/disabling_logging.md
================================================
## Redacting logs to client

The cloud-hosted product automatically redacts logs to prevent any leaking of
PII. If you would like to also redact log information in your self-hosted
deployment, set the `REDACT_LOGS_TO_CLIENT` environment variable to `true`.

## Disabling self-hosted beacon

Self-hosted builds contain a beacon to help Convex understand usage of the
product. The information collected is anonymous and minimal, containing a random
identifier plus the version of the backend in use. You may opt out of the beacon
by setting the environment variable `DISABLE_BEACON` to `true`.



================================================
FILE: self-hosted/advanced/hosting_on_own_infra.md
================================================
## Backend hosting on your own infrastructure

It's possible to run Convex on your own servers, with your own routing.

Download the
[`docker-compose.yml` file](https://github.com/get-convex/convex-backend/tree/main/self-hosted/docker/docker-compose.yml)
onto the server you want to run Convex on.

```sh
curl -O https://raw.githubusercontent.com/get-convex/convex-backend/main/self-hosted/docker/docker-compose.yml
```

Your Convex backend will be running on this server at port 3210, with HTTP
actions exposed at port 3211, and the dashboard running on port 6791.

Set up routing to forward requests from your domain to these ports. For example:

- `https://api.my-domain.com` forwards to `http://localhost:3210`
- `https://my-domain.com` forwards to `http://localhost:3211`
- `https://dashboard.my-domain.com` forwards to `http://localhost:6791`

In a `.env` file beside the `docker-compose.yml` file, set the following
environment variables:

```sh
# URL of the Convex API as accessed by the client/frontend.
CONVEX_CLOUD_ORIGIN='https://api.my-domain.com'
# URL of Convex HTTP actions as accessed by the client/frontend.
CONVEX_SITE_ORIGIN='https://my-domain.com'
# URL of the Convex API as accessed by the dashboard (browser).
NEXT_PUBLIC_DEPLOYMENT_URL='https://api.my-domain.com'
```

On the server, start the backend with:

```sh
docker compose up
```

Get an admin key with:

```sh
docker compose exec backend ./generate_admin_key.sh
```

Go to the dashboard at `https://dashboard.my-domain.com` and use the admin key
to authenticate.

In your Convex project (on your local machine, probably not on the hosting
server), add the url and admin key to a `.env.local` file (which should not be
committed to source control):

```sh
CONVEX_SELF_HOSTED_URL='https://api.my-domain.com'
CONVEX_SELF_HOSTED_ADMIN_KEY='<your admin key>'
```

Now you can run commands in your Convex project, to push code, run queries,
import data, etc.

```sh
npx convex dev
```



================================================
FILE: self-hosted/advanced/knobs.md
================================================
# Advanced Configuration and Tuning

There is a large number of detailed configuration options in
[knobs.rs](/crates/common/src/knobs.rs). These options are configurable via
environment variables. In order to tune your Convex instance at scale for your
workload, you may need to adjust these knobs. You will have to set these
environment variables by adding them to your `docker-compose.yml` file. Commonly
overriden knobs are listed in the `env` section of the
[`docker-compose.yml`](../docker/docker-compose.yml)



================================================
FILE: self-hosted/advanced/postgres_or_mysql.md
================================================
## Running the database on Postgres or MySQL

The Convex backend is designed to work well with SQLite, Postgres, or MySQL. By
default, the docker image uses SQLite. If you're running a production workload
that requires guaranteed uptime it's likely you want to use a managed Postgres
or MySQL service. We've included instructions below for connecting to a Postgres
database hosted on [Neon](https://neon.tech) or a MySQL (Vitess) database hosted
on [PlanetScale](https://planetscale.com). We've tested that the Convex backend
works with Postgres v17 and MySQL v8, but it's possible it works with other
versions.

Use `npx convex export` to export your data before moving from one database
provider to another.

**It's very important your backend is hosted in the same region and as close as
possible to your database!** Any additional latency between backend and database
will negatively impact query performance.

### Connecting to Postgres on Neon

Copy the connection string from the Neon dashboard and create the database.

```sh
export DATABASE_CONNECTION='<connection string>'
psql $DATABASE_CONNECTION -c "CREATE DATABASE convex_self_hosted"
```

You can use the `POSTGRES_URL` environment variable to instruct the backend to
connect to a certain database. This URL is the connection string without the db
name and query params. e.g., for Neon it should end in `neon.tech`:

```sh
export POSTGRES_URL=$(echo $DATABASE_CONNECTION | sed -E 's/\/[^/]+(\?.*)?$//')
```

If you're running the backend on a platform like [Fly](https://fly.io), register
this environment variable in the hosting environment, e.g.,:

```sh
fly secrets set POSTGRES_URL=$POSTGRES_URL
```

otherwise if you're running the backend locally you can restart it to pick up
this environment variable.

Check that the database is connected to your self-hosted convex backend. There
should be a line like `Connected to Postgres` in the logs. Note that you'll have
to redeploy any existing Convex functions to the new database with
`npx convex deploy`.

### Connecting to Postgres locally

Create a database called `convex_self_hosted` in your Postgres instance.

```sh
psql postgres -c "CREATE DATABASE convex_self_hosted"
```

Set the `POSTGRES_URL` environment variable to your Postgres connection string
and disable SSL. Do not include the database name in `POSTGRES_URL`.

```sh
export POSTGRES_URL='postgresql://<your-username>@host.docker.internal:5432'
export DO_NOT_REQUIRE_SSL=1
docker compose up
```

### Running MySQL locally

```sh
mysql -e "CREATE DATABASE convex_self_hosted;"
export MYSQL_URL=mysql://<your-username>@host.docker.internal:3306
export DO_NOT_REQUIRE_SSL=1
docker compose up
```

### Running MySQL on PlanetScale

Set up a database on [PlanetScale](https://planetscale.com/). Be sure to name it
`convex_self_hosted`! Do not include the database name in `MYSQL_URL`.

```sh
export MYSQL_URL=mysql://<your-username>:<your-password>@aws.connect.psdb.cloud
docker compose up
```

### Database Names

The database name that the Convex backend uses for persistence is equivalent to
the instance name (replacing `-` with `_`). If no instance name is set, the
Docker image defaults to `convex-self-hosted`, and the Convex backend will
connect to the database `convex_self_hosted`.

For the docker container, you can set the instance name via the `INSTANCE_NAME`
envrionment variable.

For example, using postgres:

```sh
export POSTGRES_URL='<connection string>'
export INSTANCE_NAME='your-instance-name'
psql $POSTGRES_URL -c "CREATE DATABASE your_instance_name;"
```



================================================
FILE: self-hosted/advanced/running_binary_directly.md
================================================
## Running the binary directly

<details>
<summary>Getting the binary</summary>

You can either [build from source](../README.md) or use the precompiled
binaries. You can download the latest precompiled binary release from
[Releases](https://github.com/get-convex/convex-backend/releases). If your
platform is not supported, leave us a GitHub issue. In the meantime, you can
build from source.

_Note: On MacOS you might need to hold the `option` key and double click the
binary file in Finder once, to circumvent the
[Gatekeeper](https://support.apple.com/en-us/102445) warning._

</details>

<details>
<summary>Generate a new instance secret</summary>

Instance secret is the secret to the backend. Keep very safe and only accessible
from the backend itself. Generate a new random instance secret with

```sh
cargo run -p keybroker --bin generate_secret
```

It will look like this:
`4361726e697461732c206c69746572616c6c79206d65616e696e6720226c6974`

</details>

<details>
<summary>Generate a new admin key</summary>

With the instance name and instance secret, generate an admin key. Admin key is
required to push code to the backend and take other administrator operations.

```sh
cargo run -p keybroker --bin generate_key -- convex-self-hosted 4361726e697461732c206c69746572616c6c79206d65616e696e6720226c6974
```

It will look like
`convex-self-hosted|01c046ab1512d9306a6abda3eedec5dfe862f1fe0f66a5aee774fb9ae3fda87706facaf682b9d4f9209a05e038cbd6e9b8`

</details>

<details>
<summary>Run your backend instance</summary>

Adjust the path based on where you downloaded the binary to or add it to your
`PATH`. The backend will store its database in the current-working-directory
(not where the binary file lives).

Use the instance name and instance secret to start your backend.

```sh
./convex-local-backend --instance-name convex-self-hosted --instance-secret 4361726e697461732c206c69746572616c6c79206d65616e696e6720226c6974
```

To run with Postgres, add `--db postgres-v5 <connection string>` to the command,
being sure to strip out the database name and query parameters. See
[Postgres instructions](#connecting-to-postgres-on-neon). To run with MySQL, add
`--db mysql-v5 <connection string>` to the command and similarly strip out the
database name and query parameters.

You can run `./convex-local-backend --help` to see other options for things like
changing ports, convex origin url, convex site url, local storage directories
and other configuration.

</details>



================================================
FILE: self-hosted/advanced/s3_storage.md
================================================
## Using S3 Storage

By default, the backend stores file data on the filesystem within the docker
container. To instead run the backend with S3 storage, set up the following
buckets and environment variables.

```sh
export AWS_REGION="your-region"
export AWS_ACCESS_KEY_ID="your-access-key-id"
export AWS_SECRET_ACCESS_KEY="your-secret-access-key"
export S3_STORAGE_EXPORTS_BUCKET="convex-snapshot-exports"
export S3_STORAGE_SNAPSHOT_IMPORTS_BUCKET="convex-snapshot-imports"
export S3_STORAGE_MODULES_BUCKET="convex-modules"
export S3_STORAGE_FILES_BUCKET="convex-user-files"
export S3_STORAGE_SEARCH_BUCKET="convex-search-indexes"
```

Optionally set the `S3_ENDPOINT_URL` environment variable. This is required for
using [R2](https://www.cloudflare.com/developer-platform/products/r2/) or some
other drop-in replacement compatible with the AWS S3 API.

Then run the backend!

## Migrating storage providers

If you are switching between local storage and S3 storage (or vice versa),
you'll need to run a snapshot export and import to migrate your data.

Run:

```sh
npx convex export --path <path-to-export-file>
```

Then set up a fresh backend with the new storage provider and import the data:

```sh
npx convex import --replace-all <path-to-export-file>
```



================================================
FILE: self-hosted/advanced/upgrading.md
================================================
# Upgrading self-hosted Convex

In order to safely migrate to a new version of self-hosted, there are two
options.

## Option 1: Upgrade in-place

If you want to avoid downtime, you can upgrade in-place. It is highly
recommended that you run an `npx convex export` before you upgrade so that you
can restore in case something goes wrong.

Look for loglines like this - and follow those instructions to complete the
in-place upgrade. Each migration will let you know which logline to wait for to
determine that the in-place upgrade is complete.

```
Executing Migration 114/115. MigrationComplete(115)
```

This will migrate your existing database in-place toward a new one. There may be
rare cases in which this does not work smoothly, in which case you can try
option 2.

## Option 2: Export/Import your database

This allows you to start over your database from scratch, and import your data
directly, instead of trying to migrate in-place.

1. Take down external traffic to your backend.
2. Export your database with `npx convex export`.
3. Save your environment variables with `npx convex env list` (or via
   dashboard).
4. Upgrade the backend docker image.
5. Import from your backup with `npx convex import --replace-all`.
6. Bring back your environment variables with `npx convex env set` (or via
   dashboard)
7. Bring back external traffic to your backend.

Given that exports/imports can be expensive if you have a lot of data, this can
incur downtime. You can get a sense of how much downtime by running a test
export while your self-hosted instance is up. For smaller instances, this may be
quick and easy.

However to safely avoid losing data, it's important that the final export is
done after load is stopped from your instance, since exports are taken at a
snapshot in time.



================================================
FILE: self-hosted/advanced/devcontainer/README.md
================================================
# Running Convex in a DevContainer for Local Development [Community maintained]

If you're working with Convex and want to use a consistent, container-based
development environment, this guide provides a minimal setup using
[DevContainers](https://containers.dev/) and Docker.

> [!IMPORTANT]  
> This approach is meant for **local development** and is not intended for
> self-hosting Convex in production.

## What is a DevContainer?

A DevContainer is a development environment defined as code and backed by a
Docker container. It integrates tightly with Visual Studio Code through the
[Dev Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers).

When you open a project with a `.devcontainer/devcontainer.json` file, VS Code
automatically builds the container, installs dependencies, and mounts your
project directory inside it.

This setup is especially useful for teams, open source contributors, or anyone
who wants to avoid dependency drift between local machines.

## Why use a DevContainer?

- Reproducible local environment with no host machine setup required
- Isolated from other projects and host system
- Preconfigured runtimes, dependencies, tools and extensions (e.g., Node.js,
  pnpm, Convex CLI)
- Easy onboarding for new team members or contributors

## Requirements

To use a DevContainer, you need to have the following installed:

- [Docker](https://www.docker.com/products/docker-desktop)
- [Visual Studio Code](https://code.visualstudio.com/)
- [Dev Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers)

## Minimal DevContainer Example for Convex

The following is a minimal example of a working
`.devcontainer/devcontainer.json` setup using a Node.js/TypeScript base image.
It binds the necessary Convex and pnpm directories, and explicitly forwards the
required ports:

```jsonc
{
  "name": "convex-dev",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:1-22-bookworm",
  "workspaceFolder": "/workspaces/${localWorkspaceFolderBasename}",

  "postCreateCommand": "npm install -g convex && npx convex dev --once",
  "postAttachCommand": "git config --global diff.ool ...",
  "postStartCommand": "git config --global --add safe.directory /workspaces/${localWorkspaceFolderBasename}",

  "mounts": [
    "source=${localEnv:HOME}/.ssh,target=/home/node/.ssh,type=bind,consistency=cached",
    "source=${localEnv:HOME}/.convex,target=/home/node/.convex,type=bind,consistency=cached",
    "source=${localEnv:HOME}/.cache/convex,target=/home/node/.cache,type=bind,consistency=cached",
  ],

  "remoteUser": "node",
  "forwardPorts": [3210, 6790, 6791],
}
```

You can adapt the image, remote user, or mounted paths depending on your project
needs or base OS image.

### Explanation of the Configuration

This minimal setup includes just a few customizations that are important for
Convex to run reliably inside a containerized environment.

#### `.convex` mount

```json
"mounts": [
  "source=${localEnv:HOME}/.convex,target=/home/node/.convex,type=bind"
]
```

Convex stores some local state in the `.convex` directory (such as deployment
metadata and generated admin keys). Mounting it from your host machine into the
container ensures that:

- The state is preserved across container rebuilds.
- You can reuse the same identity and credentials inside and outside the
  container.

Without this mount, Convex might behave as if it's being run for the first time
every time you restart the container.

#### `.cache/convex` mount

```json
"source=${localEnv:HOME}/.cache/convex,target=/home/node/.cache,type=bind,consistency=cached"
```

During `pnpm convex dev`, the Convex CLI downloads necessary artifacts such as
backend binaries and the dashboard frontend into the `.cache/convex` directory.
By mounting this directory from the host into the container, those files are
persisted between container rebuilds and restarts.

This avoids re-downloading the same artifacts every time the container is
recreated, which speeds up startup and reduces bandwidth usage.

#### Forwarded ports

```json
"forwardPorts": [3210, 6790, 6791]
```

Convex uses these ports during local development:

- `3210` — the API server
- `6790` — the web dashboard
- `6791` — the internal health check used by the dashboard to determine if a
  local deployment is available

Forwarding these ports ensures that the services running inside the container
are accessible from your host machine and from the dashboard itself.

#### `postCreateCommand`

```json
"postCreateCommand": "npx convex dev --once"
```

This command ensures the Convex development server is started as soon as the
container is ready. The `--once` flag runs the server in one-off mode, avoiding
watch mode or automatic restarts.

This is useful for initial setup to verify everything is working, but you can
always stop it and run `pnpm convex dev` manually when actively working on your
functions.



================================================
FILE: self-hosted/advanced/fly/README.md
================================================
# Self-hosting Convex with [Fly.io](https://fly.io/)

We include `fly.toml` files to make it easy to deploy your backend to
[Fly.io](https://fly.io/).

## Setup

Copy the
[`fly` files](https://github.com/get-convex/convex-backend/tree/main/self-hosted/fly)
to your local machine. You don't need to copy it into your project directory,
but you can. `degit` is a tool for copying files from git repositories.

```sh
npx degit get-convex/convex-backend/self-hosted/fly fly
cd fly
```

Install the `fly` CLI by following
[these instructions](https://fly.io/docs/flyctl/install/)

## Deploying the backend to Fly.io

The backend "deploy" can mean two things:

1. Deploying the Convex backend docker image to Fly.io.
2. Deploying your app's Convex functions to the fly machine running Convex.

Steps:

1. Deploy the backend to Fly.io.

   ```sh
   cd backend
   fly launch
   ```

   When prompted, hit 'y' to copy the configuration to your new app. Edit the
   location to be in the same region as your database (if you're using
   [Postgres or MySQL](https://github.com/get-convex/convex-backend/tree/main/self-hosted/README.md#running-the-database-on-postgres-or-mysql)).
   Now you have a fly app that is running the Convex backend, where you can
   deploy your app's Convex functions.

   Note the URL of the app that gets printed out, which will be of the form
   `https://<app-name>.fly.dev`. We'll call this the `fly-backend-url`.

2. Set the environment variables `CONVEX_CLOUD_ORIGIN` and `CONVEX_SITE_ORIGIN`
   for your backend.

   These environment variables are used by the backend so it knows where it is
   hosted. Inside your Convex backend functions, you can access the backend's
   URL with `process.env.CONVEX_CLOUD_URL` for the Convex client API and
   `process.env.CONVEX_SITE_URL` for the HTTP API.

   **Using the fly.toml file:**

   To save them in the fly.toml file, set them in the `[env]` section.

   ```toml
   [env]
   TMPDIR = '/convex/data/tmp'
   CONVEX_CLOUD_ORIGIN = '<fly-backend-url>'
   CONVEX_SITE_ORIGIN = '<fly-backend-url>/http'
   ```

   Then re-deploy to pick up the changes.

   ```sh
   fly deploy
   ```

   **Storing them as secrets:**

   If you'd rather not save the env variables in the fly.toml file, you can set
   them as secrets with `fly secrets set`. This can be useful if multiple
   developers are working on the same repo where the fly.toml file is already
   checked in, and they each have their own fly.io-hosted backend.

   ```sh
   fly secrets set CONVEX_CLOUD_ORIGIN="<fly-backend-url>" CONVEX_SITE_ORIGIN="<fly-backend-url>/http"
   ```

   Now your backend knows its base URL so it can generate URLs that point back
   to itself. This is especially useful for libraries registering webhooks and
   [Convex Auth](https://labs.convex.dev/auth) for generating auth callbacks.

3. Check that the backend is running. Visit the `<fly-backend-url>` and you
   should see a message saying your backend is running! Check the logs with
   `fly logs` if it's not working.

4. Generate an admin key.

   ```sh
   fly ssh console --command "./generate_admin_key.sh"
   ```

   This admin key will be used to authorize the CLI and access the dashboard.

5. Inside your app that uses Convex, create a `.env.local` file with the
   following variables:

   ```sh
   CONVEX_SELF_HOSTED_URL='<fly-backend-url>'
   CONVEX_SELF_HOSTED_ADMIN_KEY='<your-admin-key>'
   ```

6. To deploy your Convex functions to the backend, you'll use the `convex` CLI.

   If you don't already have Convex installed for your app, install it.

   ```sh
   cd <your-frontend-app-directory>
   npm install convex@latest
   ```

   To continuously deploy code for development:

   ```sh
   npx convex dev
   ```

   This will continuously deploy your Convex functions as you edit them. It will
   also set environment variables in `.env.local` for your frontend, like
   `VITE_CONVEX_URL`.

   To deploy code once:

   ```sh
   npx convex deploy --env-file <path to env file>
   ```

   To deploy code to a different backend, you can pass the `--env-file` flag or
   set the self-hosted environment variables before calling `npx convex deploy`.

   **Note:** It's up to you whether a backend is for development or production.
   There is no distinction within the instance. If you only have one backend,
   you can run `npx convex dev` or `npx convex deploy` depending on whether you
   want it to live-update or not.

   An extension of this is that you can have many backends for staging or
   previews. The difference will be in the environment variables.

### HTTP Actions

Note that HTTP actions run on your fly app url under the `/http` path. For
example:

- If your fly app is deployed at `https://self-hosted-backend.fly.dev`
- And you have an HTTP action routed to `/sendEmail`
- You would call it at `https://self-hosted-backend.fly.dev/http/sendEmail`

### Database

At this point, your data is stored in SQLite and your files are stored in the
filesystem in your Fly volume. You can see them in the `data` folder if you run:

```
fly ssh console
ls
```

To store your data in a SQL database of your choice, see
[these instructions](https://github.com/get-convex/convex-backend/tree/main/self-hosted/README.md#running-the-database-on-postgres--or-mysql).

## Deploying the dashboard

The dashboard allows you to see logs, read/write data, run functions, and more.
You can run the dashboard locally with Docker, or deploy it to Fly.io.

### Running the dashboard locally

```sh
docker run -e 'NEXT_PUBLIC_DEPLOYMENT_URL=<fly-backend-url>' -p '6791:6791' 'ghcr.io/get-convex/convex-dashboard:latest'
```

### Fly.io deployment

1. Go into the dashboard directory where you copied the self-hosted files.

   ```sh
   cd dashboard
   ```

2. Deploy the dashboard to Fly.io with the url to your fly-hosted backend.

   **Saving the url in the fly.toml file:**

   ```sh
   fly launch -e NEXT_PUBLIC_DEPLOYMENT_URL="<fly-backend-url>"
   ```

   **Saving the url as a secret:**

   If you'd rather not have the url in the fly.toml file, you can set it as a
   secret. This can be useful if multiple developers are working on the same
   repo where the fly.toml file is already checked in, and they each have their
   own fly.io-hosted dashboard.

   ```sh
   fly launch
   fly secrets set NEXT_PUBLIC_DEPLOYMENT_URL="<fly-backend-url>"
   ```

   You should now be able to visit the dashboard at the url output by fly.

3. Visit the dashboard and enter the admin key. To log in, it will need the
   admin key you generated earlier. We recommend saving it in your password
   manager for ease, but you can always regenerate it with
   `fly ssh console --command "./generate_admin_key.sh"`.

   You should see your tables, functions, logs, etc.

## Deploying your frontend app

See
[these instructions](https://github.com/get-convex/convex-backend/tree/main/self-hosted/README.md#deploying-your-frontend-app).

## Troubleshooting

- **Performance issues**: The default fly configuration allocates the minimum
  possible resources to get up and running. If your app has high load, you may
  see ratelimiting from Fly and poor performance. We recommend increasing your
  memory and CPU.
- **Running out of disk space**: The default fly configuration allocates 1GB to
  the `convex_data` volume where your SQLite database and storage lives. If you
  run out of space, you can increase the volume size with `fly volume extend`.



================================================
FILE: self-hosted/advanced/railway/README.md
================================================
# Self-hosting Convex with [Railway.com](https://railway.com/)

Instructions for railway self-hosting is community maintained. For help, please
join the [community discord](https://convex.dev/community). Thanks to
[orenaksakal](https://github.com/orenaksakal) for the work in putting the
instructions together.

## Deploying to Railway.com

You can view the ready to deploy template here

- [Convex + SQLite](https://railway.com/deploy/OKpPqB)
- [Convex + Postgres](https://railway.com/deploy/convex-postgres)
- [Convex + Mysql](https://railway.com/deploy/convex-mysql)

or use one click deploy buttons below:

Convex + SQLite

[![Deploy on Railway.com](https://railway.com/button.svg)](https://railway.com/template/OKpPqB)

Convex + Postgres

[![Deploy on Railway.com](https://railway.com/button.svg)](https://railway.com/deploy/convex-postgres)

Convex + Mysql

[![Deploy on Railway.com](https://railway.com/button.svg)](<[https://railway.com/deploy/convex-postgres](https://railway.com/deploy/convex-mysql)>)

## Setup

The template comes with pre-configured env-variables and you need to follow some
setup steps to make it fully work.

1. Deploying the template
2. Generating admin key with railway ssh

Steps:

1. Deploying the template

   Just deploy the template and enjoy. 🚀

   ℹ️ (Optional): If you would like to separete api and http domains follow
   steps below:

   - Select `convex-backend` service
   - Select Settings tab and scroll to `Public Networking` section
   - Hover on the domain and click on edit or delete buttons
   - Click on `Generate Domain` for auto generated one or `Custom Domain` if you
     want to setup custom domain
   - Make sure to select port `3210` and add your domain for convex (api) url
     and select port `3211` for http (action) routes
   - Re-deploy both `convex-dashboard` and `convex-backend` services

2. Generating admin key with railway ssh

   Follow [these](https://blog.railway.com/p/ssh#how-to-ssh-on-railway)
   instructions to setup railway SSH on your machine

   - Link your convex deployment project
   - Run `railway ssh` and select `convex-backend` when prompted
   - Run `ls` and then `./generate_admin_key.sh`
   - Copy the whole admin key logged on the screen
   - This is your admin key keep it secret

### HTTP Actions

Note that HTTP actions run on your railway app url under the `/http` path. For
example:

- If your railway app is deployed at `https://self-hosted-backend.railway.app`
- And you have an HTTP action routed to `/sendEmail`
- You would call it at `https://self-hosted-backend.railway.app/http/sendEmail`

### Database

If you deployed SQLite template, your data is stored in local SQLite file and
your files are stored in the Railway volume. You can see them in the `data`
folder if you run:

```
railway ssh
ls
```

To store your data in a SQL database of your choice, see
[these instructions](https://github.com/get-convex/convex-backend/tree/main/self-hosted/README.md#running-the-database-on-postgres--or-mysql).

## Accessing the deployed dashboard

The dashboard allows you to see logs, read/write data, run functions, and more.
You can run the dashboard locally with Docker, or deploy it to Railway.

- Head over to your railway app
- Select `convex-dashboard`
- Visit its public url
- Paste the admin key when prompted
- Enjoy

### Running the dashboard locally

```sh
docker run -e 'NEXT_PUBLIC_DEPLOYMENT_URL=<backend-url>' -p '6791:6791' 'ghcr.io/get-convex/convex-dashboard:latest'
```

## Deploying your frontend app

See
[these instructions](https://github.com/get-convex/convex-backend/tree/main/self-hosted/README.md#deploying-your-frontend-app).

## Troubleshooting

- **Performance issues**: The default railway configuration allocates the
  minimum possible resources to get up and running. If your app has high load,
  you may see ratelimiting from railway and poor performance. We recommend
  increasing your memory and CPU.
- **Running out of disk space**: The hobby railway configuration allocates 5GB
  to the `convex_data` volume where your SQLite database and storage lives. If
  you run out of space, you can increase the volume to 50GB by upgrading plan.
- If you need more help feel free to join our discord
  [community discord](https://convex.dev/community)



================================================
FILE: self-hosted/docker-build/README.md
================================================
# Building docker images

The contents of this directory are used to build the docker images for the
self-hosted backend and dashboard. If you're looking for ways to run self-hosted
Convex, see the [these instructions](../README.md). You may build the images
locally from here, but we recommend using the images we provide on GHCR.

Build the backend from scratch by running:

```sh
docker build -t convex-backend -f self-hosted/docker-build/Dockerfile.backend .
```

Build the dashboard from scratch by running:

```sh
docker build -t convex-dashboard -f self-hosted/docker-build/Dockerfile.dashboard .
```


